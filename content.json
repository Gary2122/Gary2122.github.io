{"posts":[{"title":"第一篇博客当然是HELLO WORLD","text":"","link":"/2024/02/15/hello-world/"},{"title":"歌词滚动效果的实现","text":"话不多说，先看效果图： 歌词随着时间进行变化，那这种效果我们应该怎么去做呢？实现的思路又是怎样的呢？ 1.先找需要的材料我把材料发放在了网盘里，大家通过链接获取，里面有对应的 mp3 文件及数据 链接：https://pan.baidu.com/s/1RdDty0ctUl3k-7o-43-0nw?pwd=388p提取码：388p 2，对得到的资料进行分析，进行数据处理 这个是我们获取到的数据，由于我是在 vue2 项目里面做的，所以我用了 export 将需要的数据引出，然后在对应的页面进行处理 那么问题来了：我们需要的数据是什么？什么样的数据我们才能让歌词与时间联系起来？ answer：其实就是歌词对应在 MP3 文件中对应的播放时间，所以我们需要获取对应歌曲每句歌词所对应的时间 接下来，我们在对应的文件中引入我们歌曲数据 1import lrcSong from &quot;../assets/js/song&quot;; 然后对取到的数据进行处理：将取到的歌词数据变成对象数组 对于取到的数据，我们只需要 lyric 部分，这部分是每句歌词对应的时间的字符串 由于我们取到的数据是字符串形式的，所以需要对字符串进行拆分，理由很简单，我们最后需要的数据是字符数组的形式 所以parseLrc(lrcSong)函数是对取到的数据变换成对象数组的函数，其中调用了parseTime函数，这个函数是我们用来将字符串的时间转换成秒数的格式， 1234567891011121314151617181920212223parseLrc(lrcSong) { let songdata = lrcSong.parseLrc(lrcSong) { let songdata = lrcSong.lyric; let songArr = songdata.split(&quot;\\n&quot;); let result = []; for (var i = 0; i &lt; songArr.length; i++) { // console.log(songArr[i]); let str = songArr[i]; var parts = str.split(&quot;]&quot;); let timeStr = parts[0].substring(1); let obj = { time: this.parseTime(timeStr), words: parts[1] }; result.push(obj); } this.song = result; //我们最后需要的数组对象，如果用纯js的话，那就直接return就行，最后找个变量接收 }, // 处理时间问题 parseTime(time) { let resultArr = time.split(&quot;:&quot;); return +resultArr[0] * 60 + +resultArr[1]; }, 通过这两个函数对数据的处理，我们最后得到了一个对象数组，打印出来是这样的： 3.联系 dom 元素，将歌词填充到 dom 元素里面HTML 的代码 12345678910&lt;div&gt; &lt;!-- 这种做法不能播放 --&gt; &lt;!-- &lt;audio src=&quot;../assets/1480251493.mp3&quot; controls&gt;&lt;/audio&gt; --&gt; &lt;audio controls&gt; &lt;source src=&quot;../assets/1480251493.mp3&quot; /&gt; &lt;/audio&gt; &lt;div class=&quot;container&quot;&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 注：先开始写的时间第一中 audio 的写法不能播放，第二种写法就可以，实战的时候需要注意一下 我们将处理好的数据放入到对应的 dom 元素里面 所以我们先获取 dom 元素 12345678getDom() { let tempdom = { audio: document.querySelector(&quot;audio&quot;), ul: document.querySelector(&quot;.container ul&quot;), container: document.querySelector(&quot;.container&quot;) }; this.doms = tempdom;//如果用纯js的话，那就直接return就行，最后找个变量接收 }, 这样的话，我们就获取到了我们的 dom 元素，下一步就是将歌词填充到对应的 ul 标签 12345678910111213// 创建歌词元素 createLi() { // 为了提高效率，采用文档片段，因为这种做法不涉及reflow，对浏览器渲染主线程不影响 let temp = document.createDocumentFragment(); let data = this.song; for (var i = 0; i &lt; data.length; i++) { let li = document.createElement(&quot;li&quot;); li.textContent = data[i].words; console.log(data[i].words); temp.appendChild(li); } this.doms.ul.appendChild(temp); }, 通过这种方法我们就将歌词填充到了 ul 标签中这样我们就可以看到 ul 里面 li 了 样式代码： 1234567891011121314151617181920212223242526* { margin: 0; padding: 0;}body { background-color: #000000; color: #666; text-align: center;}audio { width: 420px; margin: 30px 0;}.container { overflow: hidden; height: 420px;}.container ul { transition: 0.8s; list-style: none;}.container li { height: 30px; line-height: 30px; transition: 0.2s;} 现在我们将歌词放入到 ul 标签了，最后一步也就是最重要的，我们如何与 mp3 文件进行联系，形成滚动效果呢？ 4.将歌词与时间联系起来首先我们需要完成一个工作，就是需要知道什么时间到了哪句歌词 1234567891011// 看歌词到了那个位置 findindex() { let data = this.song; let currentTime = this.doms.audio.currentTime; for (var i = 0; i &lt; data.length; i++) { if (currentTime &lt; data[i].time) { return i - 1; } } return data.length - 1; }, 让 audio 当前播放时间与处理好的数据进行对比，获取对应的 index，这样我们就知道当前唱到了第几局句歌词 我们获取到了第几句歌词之后，我们就对歌词进行样式渲染了，就实现我们想要的滚动效果了 在实现这个之间，我们需要思考一个问题，滚动的效果是怎么实现的呢？ 看这张图，我们可以知道，其实就是 ul 标签的滚动，container 位置不进行变化，让 ul 标签向上移动，使得两个元素产生相对移动，形成这种滚动的效果，所以我们对于偏移值的把握是十分重要的 1234567891011121314151617181920212223setOffsetAndliStyle() { let containerHeight = this.doms.container.clientHeight; let liheight = this.doms.ul.children[0].clientHeight; let index = this.findindex(); let maxOffset = this.doms.ul.clientHeight - containerHeight; let offset = liheight * index + liheight / 2 - containerHeight / 2; if (offset &lt; 0) { offset = 0; } if (offset &gt; maxOffset) { offset = maxOffset; } let li = this.doms.ul.querySelector(&quot;.active&quot;); if (li) { li.classList.remove(&quot;active&quot;); } li = this.doms.ul.children[index]; if (li) { li.classList.add(&quot;active&quot;); } console.log(offset); this.doms.ul.style.transform = `translateY(-${offset}px)`; }, 当我们实现 ul 移动的时候，移动的多少是一个问题，还要考虑对应的临界值 偏移值的计算： 蓝线就是代表当前高亮显示的标签到 ul 元素顶部的距离 1liheight * index + liheight / 2 棕线就是代表container 元素的一半 这样我们就可以计算出偏移值了 1let offset = liheight * index + liheight / 2 - containerHeight / 2; 但现在还没有结束，我们还需要对偏移值判断 123456if (offset &lt; 0) { offset = 0;}if (offset &gt; maxOffset) { offset = maxOffset;} 这里面的 maxOffset 是最大的偏移值，代表到了最后一句歌词的位置不能上移了，凭个人喜好，加不加都可 那么我们就差最后一步对li 标签的渲染了 12345678let li = this.doms.ul.querySelector(&quot;.active&quot;);if (li) { li.classList.remove(&quot;active&quot;);}li = this.doms.ul.children[index];if (li) { li.classList.add(&quot;active&quot;);} active 样式 1234.container li.active { color: #fff; transform: scale(1.4);} 这样我们就做好歌词的滚动效果了！下面是我的源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152&lt;template&gt; &lt;div&gt; &lt;!-- &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; --&gt; &lt;!-- 这种做法不能播放 --&gt; &lt;!-- &lt;audio src=&quot;../assets/1480251493.mp3&quot; controls&gt;&lt;/audio&gt; --&gt; &lt;audio controls&gt; &lt;source src=&quot;../assets/1480251493.mp3&quot; /&gt; &lt;/audio&gt; &lt;div class=&quot;container&quot;&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import lrcSong from &quot;../assets/js/song&quot;;export default { name: &quot;HelloWorld&quot;, data() { return { song: [], doms: {}, currentIndex: -1, }; }, mounted() { this.parseLrc(lrcSong); this.getDom(); this.createLi(); this.audioStart(); }, methods: { parseLrc(lrcSong) { let songdata = lrcSong.lyric; let songArr = songdata.split(&quot;\\n&quot;); let result = []; for (var i = 0; i &lt; songArr.length; i++) { // console.log(songArr[i]); let str = songArr[i]; var parts = str.split(&quot;]&quot;); let timeStr = parts[0].substring(1); let obj = { time: this.parseTime(timeStr), words: parts[1], }; result.push(obj); } this.song = result; console.log(this.song); }, // 处理时间问题 parseTime(time) { let resultArr = time.split(&quot;:&quot;); return +resultArr[0] * 60 + +resultArr[1]; }, // 获取dom getDom() { let tempdom = { audio: document.querySelector(&quot;audio&quot;), ul: document.querySelector(&quot;.container ul&quot;), container: document.querySelector(&quot;.container&quot;), }; this.doms = tempdom; }, // 创建歌词元素 createLi() { // 为了提高效率，采用文档片段，因为这种做法不涉及reflow，对浏览器渲染主线程不影响 let temp = document.createDocumentFragment(); let data = this.song; for (var i = 0; i &lt; data.length; i++) { let li = document.createElement(&quot;li&quot;); li.textContent = data[i].words; console.log(data[i].words); temp.appendChild(li); } this.doms.ul.appendChild(temp); }, // 看歌词到了那个位置 findindex() { let data = this.song; let currentTime = this.doms.audio.currentTime; for (var i = 0; i &lt; data.length; i++) { if (currentTime &lt; data[i].time) { return i - 1; } } return data.length - 1; }, setOffsetAndliStyle() { let containerHeight = this.doms.container.clientHeight; let liheight = this.doms.ul.children[0].clientHeight; let index = this.findindex(); let maxOffset = this.doms.ul.clientHeight - containerHeight; let offset = liheight * index + liheight / 2 - containerHeight / 2; if (offset &lt; 0) { offset = 0; } if (offset &gt; maxOffset) { offset = maxOffset; } let li = this.doms.ul.querySelector(&quot;.active&quot;); if (li) { li.classList.remove(&quot;active&quot;); } li = this.doms.ul.children[index]; if (li) { li.classList.add(&quot;active&quot;); } console.log(offset); this.doms.ul.style.transform = `translateY(-${offset}px)`; }, audioStart() { this.doms.audio.addEventListener(&quot;timeupdate&quot;, this.setOffsetAndliStyle); }, },};&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style&gt;* { margin: 0; padding: 0;}body { background-color: #000000; color: #666; text-align: center;}audio { width: 420px; margin: 30px 0;}.container { overflow: hidden; height: 420px; /* border: 2px solid #fff; */}.container ul { transition: 0.8s; list-style: none;}.container li { height: 30px; line-height: 30px; transition: 0.2s;}.container li.active { color: #fff; transform: scale(1.4);}&lt;/style&gt; 这个 demo 是结合 vue2 做的，如果用纯 js 做的同学简单改一下变量就可以，里面的方法思路都是适用的~","link":"/2024/02/21/1-gd/"},{"title":"算法知识1-时空复杂度","text":"时间复杂度时间复杂度就是用来方便开发者估算出程序的运行时间，（这里我们默认 CPU 的每个单元运行消耗的时间都是相同的），假设算法的问题规模为 n，那么操作单元数量便用函数 f(n)来表示】 12345for(i=1; i&lt;=n; ++i){ j = i; j++;} 通过「 大 O 符号表示法 」，这段代码的时间复杂度为：O(n) ，为什么呢? 在 大 O 符号表示法中，时间复杂度的公式是： T(n) = O( f(n) )，其中 f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：算法的渐进时间复杂度。，简称时间复杂度，记为 O(f(n)) 常见的时间复杂度量级有： 常数阶 O(1) 对数阶 O(logN) 线性阶 O(n) 线性对数阶 O(nlogN) 平方阶 O(n²) 立方阶 O(n³) K 次方阶 O(n^k) 指数阶(2^n) 上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。 常数阶 O(1) 无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是 O(1)，如： 12345int i = 1;int j = 2;++i;j++;int m = i + j; 线性阶 O(n) 这个在最开始的代码示例中就讲解过了，如： 12345for(i=1; i&lt;=n; ++i){ j = i; j++;} 这段代码，for 循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的，因此这类代码都可以用 O(n)来表示它的时间复杂度。 对数阶 O(logN) 还是先来看代码： 12345int i = 1;while(i&lt;n){ i = i * 2;} 从上面代码可以看到，在 while 循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环 x 次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(logn) 线性对数阶 O(nlogN) 线性对数阶 O(nlogN) 其实非常容易理解，将时间复杂度为 O(logn)的代码循环 N 遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了 O(nlogN)。 就拿上面的代码加一点修改来举例： 12345678for(m=1; m&lt;n; m++){ i = 1; while(i&lt;n) { i = i * 2; }} 平方阶 O(n²) 平方阶 O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。举例： 12345678for(x=1; i&lt;=n; x++){ for(i=1; i&lt;=n; i++) { j = i; j++; }} 这段代码其实就是嵌套了 2 层 n 循环，它的时间复杂度就是 O(n*n)，即 O(n²)如果将其中一层循环的 n 改成 m，即： 12345678for(x=1; i&lt;=m; x++){ for(i=1; i&lt;=n; i++) { j = i; j++; }} 那它的时间复杂度就变成了 O(m*n) 立方阶 O(n³)、K 次方阶 O(n^k) 参考上面的 O(n²) 去理解就好了，O(n³)相当于三层 n 循环，其它的类似。 指数阶(2^n) 斐波那契数列 递归算法 1234567long aFunc(int n) { if (n &lt;= 1) { return n; } else { return aFunc(n - 1) + aFunc(n - 2); }} 求解 F5 依赖 F4 和 F3 ，我们把 F5 作为树的根节点， F4 和 F3 作为左右两个叶子节点，继续向下递归，左节点 F4 继续向下分解为 F3 和 F2 ，右节点 F3 继续向下分解为 F2 和 F1 ，依此类推，如下图所示： 因此，该算法的时间复杂度为 $$O(2^n)$$ 递归性能优化 12345678910111213定义容器存放计算结果函数F（int n){ if (n &lt;= 1){ return 1; } if (n 在容器中有结果){ return 容器中对应n的值 } else {//没查到 结果 = F(n - 1) + F(n - 2); 容器[n] = 结果; return 结果; }} 优化后的程序相当于给之前的递归树做了剪枝操作，相同的节点仅执行一次，因此时间复杂度降为 $$O(n)$$ 循环解法 如果说前面的递归解法是自顶向下将大问题拆解成小问题求解，那么循环解法则是逆向思维，自底向上，先求出小问题的解，再向上一步一步向上求取最终问题的解。 求解过程分为 n 步，将每一步的结果保存在列表中对应下标的位置，代码如下。 12345678int n; cin &gt;&gt; n; int fibs[n] = {0}; fibs[0] = fibs[1] = 1; for (int i = 2; i &lt;= n; i ++){ fibs[i] = fibs[i - 1] + fibs[i - 2]; } cout &lt;&lt; fibs[n - 1]; 时间复杂度分析 单层循环，时间复杂度为 O(n) ，与优化后的递归解法复杂度相当。 性能优化 时间复杂度已经没有优化空间了，但可以使用两个临时变量替换掉长度为 n 的列表，使空间复杂度从 O(n) 降为 O(1) 。代码如下： 12345678910int n; cin &gt;&gt; n; int fibs_a = 0; int fibs_b = 1; for (int i = 2; i &lt;= n; i ++){ int temp = fibs_b; fibs_b = fibs_a + fibs_b; fibs_a = temp; } cout &lt;&lt; fibs_b; 缺点就是如果取小于 n 对应的斐波那契的数时候，又需要重新计算 空间复杂度既然时间复杂度不是用来计算程序具体耗时的，那么我也应该明白，空间复杂度也不是用来计算程序实际占用的空间的。 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。 空间复杂度比较常用的有：O(1)、O(n)、O(n²)，我们下面来看看： 空间复杂度 O(1) 如果算法执行所需要的临时空间不随着某个变量 n 的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)举例： 12345int i = 1;int j = 2;++i;j++;int m = i + j; 代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1) 空间复杂度 O(n) 我们先看一个代码： 123456int[] m = new int[n]for(i=1; i&lt;=n; ++i){ j = i; j++;} 这段代码中，第一行 new 了一个数组出来，这个数据占用的大小为 n，这段代码的 2-6 行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)","link":"/2024/02/22/2sf-1/"},{"title":"算法知识2-C++和Java算法常用方法","text":"&lt;标语&gt; &lt;以下是竞赛中常用的方法，不管是蓝桥杯还是天梯赛都是很常用的方法，所以放在了第二节，比较基础也比较重要&gt; 🔨JAVA📝 字符串 string1234567891011String sl =&quot;hello world&quot;;// 获取s1[2]中的字符char c = sl.charAt(2);char[] chars = sl.toCharArray();chars[1] ='a';String s2 = new String(chars);// 输出: hallo worldSystem.out.printin(s2);//注意，一定要用equals 方法判断字符串是否相同if (sl.equals(s2)) {// s1和s2相同] else [// s和s2不相同//字符串可以用加号进行拼接String s3 = sl +“!&quot;;// 输出: hello world!System.out.printin(s3); Java 的字符串不能直接修改，要用 tocharArray 转化成 char[]类型的数组后进行修改，然后转换回 string 类型 v另外，虽然字符串支持用+进行拼接，但是效率并不高，不建议在 for 循环中使用如果需要进行频繁的字符串拼接，推荐使用 stringBuilder 12345StringBuilder sb = new StringBuilder();for (char c='a';c&lt;='f'; c++)sb.append(c);// append 方法支持拼接字符、字符串、数字等类型sb.append( ' g' ) . append( &quot;hij&quot; ) .append(123) ;String res = sb.toString(); // 输出:abcdefghij123;System.out.printin(res) 📝 动态数组 ArrayList12345678910//初始化一个存储String 类型数据的动态数组ArrayList&lt;String&gt; nums = new ArrayList&lt;&gt;();//判断数组是否为空boolean isEmpty()//返回数组中元素的个数int size()//返回索引index的元素E get(int index)//在数组尾部添加元素eboolean add(E e) 📝 双链表 LinkedList1234567891011121314151617//初始化一个存储 int 类型数据的双链表LinkedList&lt;Integer&gt; nums = new LinkedList&lt;&gt;();//判断链表是否为空boolean isEmpty()// 返回链表中元素的个数int size()// 判断链表中是否存在元素 oboolean contains(0bject o)//在链表尾部添加元素eboolean add(E e)//在链表头部添加元素evoid addFirst(E e)//删除链表头部第一个元素E removeFirst()//删除链表尾部最后一个元素E removeLast() 📝 哈希表 HashMap1234567891011121314151617//整数映射到字符串的哈希表HashMap&lt;Integer，String&gt; map = new HashMap&lt;&gt;();//判断哈希表中是否存在键 keyboolean containsKey(Object key)//获得键 key 对应的值，若 key 不存在，则返回nullV get(0bject key)//将 key和 value 键值对存入哈希表V put(K key，V value)//如果 key存在，删除 key 并返回对应的值V remove(Object key)//获得 key 的值，如果 key 不存在，则返回 defaultValueV getOrDefault(0bject key，V defaultValue)/获得哈希表中的所有 keySet&lt;K&gt; keySet()//如果 key 不存在，则将键值对 key 和 value 存入哈希表//如果 key存在，则什么都不做V putIfAbsent(K key，V value) 📝 哈希集合 HashSet123456789//新建一个存储 String 的哈希集合Set&lt;String&gt; set = new HashSet&lt;&gt;();// 如果 e不存在，则将e 添加到哈希集合boolean add(E e)//判断元素o是否存在于哈希集合中boolean contains(0bject o)// 如果元素0存在，则删除元素 0boolean remove(0bject o) 📝 队列 Queue12345678910111213//新建一个存储String 的队列Queue&lt;String&gt; q = new LinkedList&lt;&gt;();//判断队列是否为空boolean isEmpty()//返回队列中元素的个数int size()// 返回队头的元素E peek()//删除并返回队头的元素E poll()// 将元素 e插入队尾boolean offer(E e) 📝 堆栈 Stack123456789101112Stack&lt;Integer&gt; s = new Stack&lt;&gt;();//判断堆栈是否为空boolean isEmpty()//返回堆栈中元素的个数int size()//将元素压入栈顶 E push(E item)//返回栈顶元素E peek()//删除并返回栈顶元素E pop() 🔨C++📝 动态数组类型 vector​ 所谓动态数组，就是由标准库封装的数组容器，可以自动扩容、缩容，比 C 语言中用 int[]声明数组更高级。​ 建议不要使用 C 语言中的数组，也不要用 malloc 这类函数自己去管理内存。虽然手动分配内存会给算法的效率带来一定的提升但是你要搞清楚自己是来干什么的，把精力更多地集中在算法思维上的性价比比较高 1234567891011121314151617181920vector&lt;int&gt; nums;//初始化一个大小为 n 的数组 nums，数组中的值默认都为 0vector&lt;int&gt; nums(n);// 初始化一个元素为 1、3、5的数组 numsvector&lt;int&gt; nums[1，3，5};//初始化一个大小为 n的数组 nums，其值全都为2vector&lt;int&gt; nums(n，2);// 初始化一个二维int 数组 dpvector&lt;vector&lt;int&gt;&gt; dp;//初始化一个大小为 m*n的布尔数组 dp/其中的值都为 truevector&lt;vector&lt;bool&gt;&gt; dp(m，vector&lt;bool&gt;(n，true));bool empty()//返回数组的元素个数size type size();//返回数组最后一个元素的引用reference back();//在数组尾部插入一个元素 valvoid push back (const value_type&amp; val)//删除数组尾部的那个元素voidpop back(); 📝String123456789size_t size();//判断字符串是否为空bool empty();// 在字符串尾部插入一个字符 cvoid push back(char c);//删除字符串尾部的那个字符void pop back();// 返回从索引 pos 开始，长度为 Len 的子字符串string substr (size t pos,size t len); 📝unordered_map 哈希表1234567891011unordered_map&lt;string，vector&lt;int&gt;&gt; mapping;//返回哈希表的键值对个数size type size();//返回哈希表是否为空bool empty();// 返回哈希表中 key出现的次数//因为哈希表不会出现重复的键，所以该函数只可能返回0或1//可以用于判断键 key 是否存在于哈希表中size type count (const key type&amp; key);//通过 key 清除哈希表中的键值对size type erase (const key_type&amp; key); 📝 哈希集合 unordered_set1234567891011121314//初始化一个存储 int 的哈希集合unordered set&lt;int&gt; visited;// 返回哈希集合的键值对个数size type size();// 返回哈希集合是否为空bool empty();//类似哈希表，如果 key 存在则返回 1，否则返回0size_type count (const key type&amp; key);//向集合中插入一个元素 keypair&lt;iterator,bool&gt; insert (const key type&amp; key);//删除哈希集合中的元素 key//如果删除成功则返回1，如果 key不存在则返回0size_type erase (const key_type&amp; key); 📝 队列 queue123456789101112//初始化一个存储string 的队列queue&lt;string&gt; q;//返回队列是否为空bool empty();//返回队列中元素的个数size type size();//将元素加入队尾void push (const value type&amp; val);//返回队头元素的引用.value type&amp; front();//删除队头元素void pop(); 📝 堆栈 Stack1234567891011Stack&lt;int&gt; stk；//返回堆栈是否为空bool empty();//返回堆栈中元素的个数size type size();//在栈顶添加元素void push (const value type&amp; val);//返回栈顶元素的引用value type&amp; top();//删除栈顶元素void pop();","link":"/2024/02/23/2sf-2/"},{"title":"算法知识3-数组知识及部分习题","text":"数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 ​ 1、二维数组int m[3][4]; 上述语句定义了一个 3 行 4 列的二维数组。 二维数组的定义与一维数组一样，应该遵循相同的原则。 二维数组 m 共有 12 个元素，每个元素都是 int 类型的。 这 12 个元素的下标分别是： 1234567m[0][0]、m[0][1]、m[0][2]、m[0][3]、m[1][0]、m[1][1]、m[1][2]、m[1][3]、m[2][0]、m[2][1]、m[2][2]、m[2][3]、 2、二维数组的内存映像图二维数组在内存中是一维存放的： C 语言中，二维数组中元素排列的顺序是按行存放的，即在内存中先顺序存放第一行的元素，再存放第二行的元素。 查找方法暴力法 就是枚举 12345678910111213141516171819202122232425public class Array02 { public static void main(String[] args) { int[] arr = {11,22,33,10,32,23,43,12,43}; // 找出arr这个数组中12所在的下标。 // 调用方法。 int num = 12; int index = arraySearch(arr,num); System.out.println(index == -1 ? num + &quot;元素不存在！&quot; : num + &quot;元素的下标：&quot; + index);}/** * 从数组检索某个元素的下标,返回的是第一个该元素的下标，因为for循环是从前到后的 * @param arr 被检索的数组 * @param ele 被检索的元素 * @return -1 表示该元素不存在，其他表示返回目标元素的下标。 */public static int arraySearch(int[] arr, int ele) { for (int i = 0; i &lt; arr.length; i++) { if (ele == arr[i]){ return i; } } return -1;} 二分查找对数组有要求，必须是有序数组 123456789101112131415161718192021222324252627282930313233343536373839404142public class ArrayUtil { public static void main(String[] args) { //数组需要满足什么要求？？？ int[] arr = {100,200,230,235,600,1000,2000,9999}; // 找出arr这个数组中200所在的下标。 // 调用方法。 int num = 200; int index = binarySearch(arr,num); System.out.println(index == -1 ? num + &quot;元素不存在！&quot; : num+ &quot;元素的下标：&quot; + index);}/** * 从数组中查找目标元素的下标。 * @param arr 被查找的数组（这个必须已经排序的）。 * @param dest 目标元素 * @return -1 表示该元素不存在，其他表示返回目标元素的下标。 */public static int binarySearch(int[] arr, int dest) { // 开始下标。 int begin = 0; // 结束下标. int end = arr.length - 1; // 开始元素下标只要在结束元素下标的左边，就有机会继续循环。 while(begin &lt;= end){ // 中间元素下标 int mid = (begin + end) / 2; if (arr[mid] == dest){ return mid; } else if (arr[mid] &lt; dest){ // 目标在“中间“的右边。 // 开始元素下标需要发生变化（开始元素的下标需要重新赋值）。 begin = mid + 1; // 一直增。 } else { // arr[mid] &gt; dest // 目标元素在”中间“左边 // 修改结束元素下标 end = mid - 1; // 一直减 } } return -1;} ​ 求三数之和(Three Sum)题目给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ,请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。示例： 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为： 1234[ [-1, 0, 1], [-1, -1, 2]] 暴力解法 12345678910111213141516171819202122232425/*** 循环三次，结果集使用了set集合，避免了返回值重复 */ private List&lt;List&lt;Integer&gt;&gt; directlySolution(int[] nums) { if (nums == null || nums.length &lt;= 2) { return Collections.emptyList(); } Arrays.sort(nums); //set集合去重 Set&lt;List&lt;Integer&gt;&gt; result = new LinkedHashSet&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) { for (int j = i+1; j &lt; nums.length; j++) { for (int k = j+1; k &lt; nums.length; k++) { if (nums[i] + nums[j] + nums[k] == 0) { List&lt;Integer&gt; value = Arrays.asList(nums[i], nums[j], nums[k]); result.add(value); } } } } return new ArrayList&lt;&gt;(result); } 优秀解法：O（n^2)思路 12345678910111213141516171819202122232425262728class Solution { public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList(); int len = nums.length; if(nums == null || len &lt; 3) return ans; Arrays.sort(nums); // 排序 for (int i = 0; i &lt; len ; i++) { if(nums[i] &gt; 0) break; // 如果当前数字大于0，则三数之和一定大于0，所以结束循环 if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; // 去重 int L = i+1; int R = len-1; while(L &lt; R){ int sum = nums[i] + nums[L] + nums[R]; if(sum == 0){ ans.add(Arrays.asList(nums[i],nums[L],nums[R])); while (L&lt;R &amp;&amp; nums[L] == nums[L+1]) L++; // 去重 while (L&lt;R &amp;&amp; nums[R] == nums[R-1]) R--; // 去重 L++; R--; } else if (sum &lt; 0) L++; else if (sum &gt; 0) R--; } } return ans; }} 前缀和一维数组前缀和 如果你没有了解过「前缀和」，可能会写出两重循环：每个 runningSum[i]，累加从 0 位置到 i 位置的 nums[i] 12345678910111213vector&lt;int&gt; runningSum(vector&lt;int&gt;&amp; nums) { const int N = nums.size(); vector&lt;int&gt; preSum(N, 0); for (int i = 0; i &lt; N; ++i) { int sum = 0; for (int j = 0; j &lt;= i; ++j) { sum += nums[j]; } preSum[i] = sum; } return preSum;} 两重循环的时间复杂度是 O(N^2)，效率比较低。 12345678910111213vector&lt;int&gt; runningSum(vector&lt;int&gt;&amp; nums) { const int N = nums.size(); vector&lt;int&gt; preSum(N, 0); for (int i = 0; i &lt; N; ++i) { if (i == 0) { preSum[i] = nums[i]; } else { preSum[i] = preSum[i - 1] + nums[i]; } } return preSum;} 前缀和方法优化=&gt;时间复杂度变成 O(n) 那么什么是前缀和？ 「前缀和」 是从 nums 数组中的第 0 位置开始累加，到第 i 位置的累加结果，我们常把这个结果保存到数组 preSum 中，记为 preSum[i]。 在前面计算「前缀和」的代码中，计算公式为 preSum[i] = preSum[i - 1] + nums[i] ，为了防止当 i = 0 的时候数组越界，所以加了个 if (i == 0) 的判断，即 i == 0 时让 preSum[i] = nums[i]。 事例样图 下面以 [1, 12, -5, -6, 50, 3] 为例，用动图讲解一下如何求 preSum。（只不过改个下标） 拓展：求数组的区间和利用 preSum 数组，可以在 O(1)O(1)O(1) 的时间内快速求出 nums 任意区间 [i,j][i, j][i,j] (两端都包含) 内的所有元素之和。 一维数组前缀和公式 sum(i,j) = preSum[j+1] − preSum[i] 什么原理呢？其实就是消除公共部分即 0~i-1 部分的和，那么就能得到 i~j 部分的区间和。 注意上面的式子中，使用的是 preSum[j + 1] 和 preSum[i]，需要理解为什么这么做。（如果理解不了的知识，那就记不住，所以一定要理解） preSum[j + 1] 表示的是 nums 数组中 [0,j] 的所有数字之和（包含 0 和 j）。 preSum[i]表示的是 nums数组中 [0,i−1] 的所有数字之和（包含 0 和 i−1）。 当两者相减时，结果留下了 nums数组中 [i,j] 的所有数字之和 前缀和再进阶：二维数组前缀和 帮助理解 代码展示 #include &lt;bits/stdc++.h&gt; using namespace std; const int MAXN = 1e3+2; const int MAXM = 1e3+2; int sum[MAXN][MAXM] = {}; int main() { int n,m; cin&gt;&gt;n&gt;&gt;m; int data; for (int i=1; i&lt;=n; i++) { for (int j=1; j&lt;=m; j++) { cin &gt;&gt; data; sum[i][j] = sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+data; } } for (int i=1; i&lt;=n; i++) { for (int j=1; j&lt;=m; j++) { cout &lt;&lt; sum[i][j] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } return 0; } 二维前缀和小提升：根据 preSum 求子矩形面积 帮助理解","link":"/2024/02/23/2sf-3/"},{"title":"算法知识4-二叉树知识","text":"包含递归知识以及二叉树基本的算法知识 注：递归知识主要围绕二叉树知识展开 树的介绍 树的定义树是一种数据结构，它是由 n（n&gt;=1）个有限节点组成一个具有层次关系的集合。 把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点： 每个节点有零个或多个子节点; 没有父节点的节点称为根节点; 每一个非根节点有且仅有一个父节点; 除了根节点以外，每个子节点可以分为多个不想交的子树。 树的基本术语 节点的度：节点拥有的子树的数目。 叶子：度为零的节点。 分支节点：度不为零的节点。 树的度：树中节点的最大的度。 层次：根节点的层次为 1，其余节点的层次等于该节点的双亲节点加 1。 树的高度：树中节点的最大层次。 无序数：如果树中节点的各子树之间的次序是不重要的，可以交换位置。 有序数：如果树中结点的各子树的次序是重要的，不可以交换位置。 森林：0 个或多个不相交的树组成。对森林加上一个跟，森林即成为树；删去跟，树即成为森林。 相关性质 二叉树（简单介绍） 二叉树的定义​ 二叉树是每个节点最多有两个子树的树结构。 ​ 它有五种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；活着左、右子树皆为空。 二叉树与度为 2 的树的区别 度为 2 的的树必须有三个节点以上(否则就不叫度为二了，一定要先存在)，二叉树可以为空。 二叉树的度不一定为 2,比如斜树。 二叉树有左右节点区分，而度为 2 的树没有左右节点的区分。 二叉树的基本性质 性质 1：二叉树第 i 层上的节点数目最多为 2{i-1} (i≥1)。 (01) 当 i=1 时，第 i 层的节点数目为 2{i-1}=2{0}=1。因为第 1 层上只有一个根结点，所以命题成立。(02) 假设当 i&gt;1，第 i 层的节点数目为 2{i-1}。这个是根据(01)推断出来的！下面根据这个假设，推断出”第(i+1)层的节点数目为 2{i}”即可。由于二叉树的每个结点至多有两个孩子，故”第(i+1)层上的结点数目” 最多是 “第 i 层的结点数目的 2 倍”。即，第(i+1)层上的结点数目最大值=2×2{i-1}=2{i}。 性质 2：深度为 k 的二叉树至多有 2{k}-1 个节点（k&gt;=1）。 在具有相同深度的二叉树中，当每一层都含有最大结点数时，其树中结点数最多。利用”性质 1”可知，深度为 k 的二叉树的结点数至多为：20+21+…+2k-1=2k-1 性质 3：包含 n 个节点的二叉树的高度至少为 log2 (n+1)。 根据”性质 2”可知，高度为 h 的二叉树最多有 2{h}–1 个结点。反之，对于包含 n 个节点的二叉树的高度至少为 log2(n+1)。 性质 4：在任意一颗二叉树中，若终端节点的个数为 n0，度为 2 的节点数为 n2，则 n0=n2+1。 因为二叉树中所有结点的度数均不大于 2，所以结点总数(记为 n)=”0 度结点数(n0)” + “1 度结点数(n1)” + “2 度结点数(n2)”。由此，得到等式一。(等式一) n=n0+n1+n2 另一方面，0 度结点没有孩子，1 度结点有一个孩子，2 度结点有两个孩子，故二叉树中孩子结点总数是：n1+2n2。此外，只有根不是任何结点的孩子。故二叉树中的结点总数又可表示为等式二。(等式二) n=n1+2n2+1由(等式一)和(等式二)计算得到：n0=n2+1。 二叉树的种类满二叉树高度为 h，并且由 2{h} –1 个结点的二叉树，被称为满二叉树。 ![5d6d36fbea67c9e611fbdcf9c84eca67 (1)](F:\\goole 下载\\5d6d36fbea67c9e611fbdcf9c84eca67 (1).png) 完全二叉树一颗二叉树中，只有最下面两层节点的度可以小于 2，并且最下层的叶节点集中在靠左的若干位置上。 一颗满二叉树必定是一颗完全二叉树，而完全而二叉树不一定是满二叉树。 二叉查找树 若任意节点的左子树不空，则左子树上所有的值均小于根节点的值 若任意节点的右子树不空，则右子树上所有节点的值均大于根节点的值（更大于左子树上的值） 任意节点的左、右子树也分别为二叉查找树 没有键值相等的节点 平衡二叉搜索树AVL(Adelson-Velsky and Landis)树，具有以下性质：它是一颗空树或者它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一颗平衡二叉树。 二叉树的存储方式链式存储​ 通过指针把分布在散落在各个地址的节点串联在一起，链式存储如图所示： 顺序存储​ 就是用数组来存储二叉树，顺序存储的方式如图： 数组存储的遍历 ​ 如果父节点的数组下标是 i,那么它的左孩子就是 2 _ i + 1,右孩子就是 i _ 2 + 2。（但是用链式表示的二叉树更有利于我们理解，一般都是用链式存储二叉树） 二叉树的遍历 二叉树的创建参考https://blog.csdn.net/new_aiden/article/details/50968112 前序遍历、中序遍历、后序遍历、层序遍历4 种方式。 前序遍历=&gt;根左右若二叉树非空，则执行以下操作：访问根结点；先序遍历左子树；先序遍历右子树。 123456789// 前序递归遍历 public static void preOrderRecursively(TreeNode tree) { if (tree == null) { return; } System.out.print(tree.val + &quot;\\t&quot;); preOrderRecursively(tree.left); preOrderRecursively(tree.right); } 中序遍历=&gt;左根右若二叉树非空，则执行以下操作：中序遍历左子树；访问根结点；中序遍历右子树。 123456789public static void inOrderRecursively(TreeNode tree) { if (tree == null) { return; } inOrderRecursively(tree.left); System.out.print(tree.val + &quot;\\t&quot;); inOrderRecursively(tree.right); } 后序遍历=&gt;左右根若二叉树非空，则执行以下操作：后序遍历左子树；后序遍历右子树；访问根结点。 123456789// 后序递归遍历 public static void postOrderRecursively(TreeNode tree) { if (tree == null) { return; } postOrderRecursively(tree.left); postOrderRecursively(tree.right); System.out.print(tree.val + &quot;\\t&quot;); } 层序遍历=&gt;逐层遍历，从左到右123456789101112131415161718192021// 层次遍历并顺序打印（借助队列） public static void levelOrder1(TreeNode tree) { if (tree == null) { return; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(tree); TreeNode temp = null; while (!queue.isEmpty()) { temp = queue.poll(); System.out.print(temp.val + &quot;\\t&quot;); if (temp.left != null) { queue.offer(temp.left); } if (temp.right != null) { queue.offer(temp.right); } } System.out.println(); }","link":"/2024/02/24/2sf-4/"},{"title":"算法知识5-递归算法","text":"递归 根据上述二叉树的知识，对递归知识能有更好的理解。 什么是递归？ 递归递归，一个是“递”，一个是“归”。 举个从小就听过的例子： 从前有座山，山中有座庙，庙里有个老和尚，老和尚在给小和尚讲故事：“ 从前有座山，山中有座庙，庙里有个老和尚，老和尚在给小和尚讲故事：“ 从前有座山，山中有座庙，庙里有个老和尚，老和尚在给小和尚讲故事：“ 从前有座山，山中有座庙，庙里有个老和尚，老和尚在给小和尚讲故事：“太困了不讲了”，于是都回去睡觉了。”于是都回去睡觉了。”于是都回去睡觉了。”于是都回去睡觉了。 ​ 在讲故事的过程中，可以看成一个递的过程，在“太困了不讲了”可以看成一个递的边界，接下来执行“归”的过程。所以我理解的递归无非是在边界条件前不断执行“递”的过程，在达到边界值后，执行“归”的过程。 ​ 递归的基本思想是某个函数直接或者间接地调用自身，这样原问题的求解就转换为了许多性质相同但是规模更小的子问题。求解时只需要关注如何把原问题划分成符合条件的子问题，而不需要过分关注这个子问题是如何被解决的。 递归的思想递归有三大要素 第一要素：明确你这个函数想要干什么 对于递归，我觉得很重要的一个事就是，这个函数的功能是什么，他要完成什么样的一件事，而这个，是完全由你自己来定义的。也就是说，我们先不管函数里面的代码什么，而是要先明白，你这个函数是要用来干什么。 12// 算 n 的阶乘(假设n不为0)int f(int n){} 第二要素：寻找递归结束条件 所谓递归，就是会在函数内部代码中，调用这个函数本身，所以，我们必须要找出递归的结束条件，不然的话，会一直调用自己，进入无底洞。也就是说，我们需要找出当参数为啥时，递归结束，之后直接把结果返回，请注意，这个时候我们必须能根据这个参数的值，能够直接知道函数的结果是什么。 123456// 算 n 的阶乘(假设n不为0)int f(int n){ if(n == 1){ return 1; }} 第三要素：找出函数的等价关系式 第三要素就是，我们要不断缩小参数的范围，缩小之后，我们可以通过一些辅助的变量或者操作，使原函数的结果不变。 例如，f(n) 这个范围比较大，我们可以让 f(n) = n * f(n-1)。这样，范围就由 n 变成了 n-1 了，范围变小了，并且为了原函数 f(n) 不变，我们需要让 f(n-1) 乘以 n。 说白了，就是要找到原函数的一个等价关系式，f(n) 的等价关系式为 n * f(n-1)，即 f(n) = n * f(n-1)。 12345678910111213int f(int n){ if(n == 1){ return 1; } else return n * f(n - 1);}int f(int n){ int s = 1; for (int i = 1; i &lt;= n; i ++){ s *= i; } return s;} 题目二叉树的最大深度定义二叉树： 12345678910111213141516171819202122class TreeNode{ /** * 值 */ int val; /** * 左孩子 */ TreeNode left; /** * 右孩子 */ TreeNode right; /** * 构造方法 * @param x */ TreeNode(int x){ this.val=x; } } 代码 12345678910111213141516171819public int maxDepth(TreeNode root) { //如果根结点为空 if (null == root) { //即二叉树的最大深度为0 return 0; } else { //递归调用 //获取左孩子的深度 int left_height = maxDepth(root.left); //获取右孩子的深度 int right_height = maxDepth(root.right); //java.lang.Math.max(参数1，参数2)是一个静态的工具方法，主要用来比较两个相同类型参数的大小， // 支持的类型有double，float，int，long四种类型 // 只要左边孩子或者右边孩子不为空则深度+1 // 返回两个数字中最大的那一个 return Math.max(left_height, right_height) + 1; } }","link":"/2024/02/24/2sf-5/"},{"title":"算法知识4-二叉树的构造","text":"🌺 构建方法二叉树的前序、中序和后序序列中的任何一个都不能唯一确定一棵二叉树， 给出一个遍历序列 A、B、C、D、E 若遍历序列为前序构造： 若遍历序列为中序构造： 若遍历序列为后序构造： 由此可见，通过某一种遍历序列不能精准构造出二叉树，构造的二叉树会有很多种 二叉树的构建主要有三大方法。 通过前序和中序建立二叉树 通过后序和中序建立二叉树 通过层序和中序建立二叉树 前、后、层次序列用来提供根结点信息，中序序列用来区分左右子树； 思考：可否通过前序遍历和后序遍历构造二叉树？ 🌻 通过前序和中序建立二叉树构建过程： 根据给定的树写出前序和中序序列； 前序序列中的第一个数字为根结点，构造根结点； 找到根结点在中序序列中的位置，中序中根结点左右两边分别为左子树和右子树的中序序列，根据左右子树 结点数量可以在前序序列根节点后面分别找到左子树和右子树的前序序列； 递归处理左右子树，返回根结点，完成构造。 实例： 前序序列：A、B、C、D、E 中序序列：C、D、B、E、A 根据前序序列和中序序列构造二叉树 练习： 前序遍历序列为：{1,2,4,7,3,5,6,8}，中序遍历序列为：{4,7,2,1,5,3,8,6}。 根据前序遍历和中序遍历构建唯一的二叉树。 前序序列： 中序序列： 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { if(preorder==null||inorder==null){ return null; } return buildtree(preorder, 0,preorder.length-1,inorder,0,inorder.length-1); } public TreeNode buildtree(int[] preorder, int pleft,int pright,int[] inorder,int ileft,int iright){ if(pleft&gt;pright||ileft&gt;iright){ return null; } //根节点值是前序遍历的第一个 TreeNode root=new TreeNode(preorder[pleft]); //中序遍历第一个为起始点 int middle=ileft; //左子树节点长度 int len=0; //找到中序遍历中的根节点位置记为middle for(;middle&lt;inorder.length;middle++){ if(inorder[middle]==preorder[pleft]){ break; } //计算左子树节点长度len len++; } //递归调用求解左右子树 //左子树：前序遍历为根后一个到根加左子树长度，中序遍历为第一个到根节点位置前一个 root.left=buildtree(preorder,pleft+1,pleft+len,inorder,ileft,middle-1); //右子树：前序遍历为左子树后一个到最后一个，中序为根节点后一个到最后一个 root.right=buildtree(preorder,pleft+len+1,pright,inorder,middle+1,iright); return root; }} map 优化 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); int length = inorder.length; for (int i = 0;i &lt; length;i++) { map.put(inorder[i],i); } return build(map,preorder,inorder,0,length-1,0,length-1); } private TreeNode build(Map&lt;Integer,Integer&gt; map,int[] preorder, int[] inorder,int pl,int pr,int il,int ir) { if (pr &lt; pl || ir &lt; il) { return null; } //首先构建一下根节点 TreeNode root = new TreeNode(preorder[pl]); //定位根节点在中序中的位置 int index = map.get(preorder[pl]); //左子树个数 int leftCount = index-il; //构建根节点的左子树和右子树 //前序的pl+1到pl+leftCount对应着中序的il到index-1 root.left = build(map,preorder,inorder,pl+1,pl+leftCount,il,index-1); //前序的pl+leftCount+1到pr对应着中序的index+1到ir root.right = build(map,preorder,inorder,pl+leftCount+1,pr,index+1,ir); return root; }} 🌻 通过前序和中序建立二叉树构建过程。 根据给定的二叉树，得到后序序列 和中序序列为 后序序列中的最后一个数字为根结点，构造根结点； 找到根结点在中序序列中的位置，中序中根结点左右两边分别为左子树和右子树的中序序列，根据左右子树结点数量可以在后序序列根节点前面分别找到左子树和右子树的后序序列； 递归处理左右子树，返回根结点，完成构造。 实例： 前序序列：C、D、B、E、A 中序序列：C、D、B、E、A 根据后序序列和中序序列构造二叉树 练习： 前序遍历序列为：{1,2,4,7,3,5,6,8}，中序遍历序列为：{4,7,2,1,5,3,8,6}。 根据前序遍历和中序遍历构建唯一的二叉树。 后序序列： 中序序列： 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public TreeNode buildTree(int[] inorder, int[] postorder) { if(postorder==null||postorder==null){ return null; } return buildtree(inorder,0,inorder.length-1,postorder,0,postorder.length-1); } public TreeNode buildtree(int[] inorder,int ileft,int iright,int[] postorder,int pleft,int pright){ if(ileft&gt;iright||pleft&gt;pright){ return null; } //根节点值为后序遍历最后一个 TreeNode root=new TreeNode(postorder[pright]); //中序遍历第一个为起始点 int middle=ileft; //左子树节点长度len int len=0; for(;middle&lt;iright;middle++){ //找到中序遍历中的根节点位置 if(inorder[middle]==postorder[pright]){ break; } //记录左子树节点长度 len++; } //递归调用求解左右子树 //左子树：中序遍历为第一个到根节点前一个，后序遍历为第一个到第一个加左子树节点长度-1 root.left=buildtree(inorder,ileft,middle-1,postorder,pleft,pleft+len-1); //右子树：中序遍历为根节点后一个到最后，后续遍历为第一个加左子树节点长度到最后一个前一个 root.right=buildtree(inorder,middle+1,iright,postorder,pleft+len,pright-1); return root; }} 🌻 通过层序和中序建立二叉树构建过程。 根据给定的二叉树，得到层次序列 {1,2,3,4,5,6,7,8} 和中序序列为 {4,7,2,1,5,3,8,6}； 层次序列中的第一个数字为根结点，构造根结点； 找到根结点在中序序列中的位置，中序中根结点左右两边分别为左子树和右子树的中序序列。根据左右子树结点值在层次序列中按顺序找到左子树和右子树的层次序列； 递归处理左右子树，返回根结点，完成构造。 层次序列： 中序序列： 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// @brief: 根据后序+中序序列构建二叉树// @ret: 二叉树的根结点BinaryTreeNode* constructLevelMid(const vector&lt;int&gt;&amp; levelorder, const vector&lt;int&gt;&amp; midorder) { // 参数检查 if (levelorder.size() == 0 || midorder.size() == 0 || levelorder.size() != midorder.size()) { return nullptr; } // 层次序列的第一个值是根结点 int rootKey = levelorder.front(); BinaryTreeNode* root = new BinaryTreeNode; root-&gt;m_key = rootKey; // 只有一个结点 if (levelorder.size() == 1) { if (levelorder.front() == midorder.front()){ return root; } else { return nullptr; } } // 在中序序列中找到根结点下标 int index = 0; while(index &lt; midorder.size()-1 &amp;&amp; midorder.at(index)!= rootKey) { index++; } // 从层次序列中找到左子树和右子树的层次序列 vector&lt;int&gt; lLevelorder, rLevelorder; for (int i = 1; i &lt; levelorder.size(); i++) { bool isLeft = false; for (int j = 0; j &lt; index; j++) { if (levelorder.at(i) == midorder.at(j)) { isLeft = true; break; } } if (isLeft) { lLevelorder.push_back(levelorder.at(i)); } else { rLevelorder.push_back(levelorder.at(i)); } } // 从中序序列找到左子树和右子树的中序序列 vector&lt;int&gt; lMidorder, rMidorder; for (int i = 0; i &lt; midorder.size(); i++) { if (i &lt; index){ lMidorder.push_back(midorder.at(i)); } else if (i &gt; index) { rMidorder.push_back(midorder.at(i)); } } // 构建左子树 if (lLevelorder.size() &gt; 0) { root-&gt;m_pLeft=constructLevelMid(lLevelorder, lMidorder); } // 构建右子树 if (rLevelorder.size() &gt; 0){ root-&gt;m_pRight = constructLevelMid(rLevelorder, rMidorder); } return root;} 🌻 通过前序和后序建立二叉树通过前序和后序不能建立唯一的二叉树，但是可以对二叉树进行重构 为什么通过前序和后序不能建立唯一的二叉树？ 重构二叉树： ​ 给定两个整数数组，preorder 和 postorder ，其中 preorder 是一个具有 无重复 值的二叉树的前序遍历，postorder 是同一棵树的后序遍历，重构并返回二叉树。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode constructFromPrePost(int[] preorder, int[] postorder) { return build(preorder, 0, preorder.length - 1, postorder, 0, postorder.length - 1); } // 定义：根据 preorder[preStart..preEnd] 和 postorder[postStart..postEnd] // 构建⼆叉树，并返回根节点。 TreeNode build(int[] preorder, int preStart, int preEnd, int[] postorder, int postStart, int postEnd) { if (preStart &gt; preEnd) { return null; } if (preStart == preEnd) { return new TreeNode(preorder[preStart]); } // root 节点对应的值就是前序遍历数组的第⼀个元素 int rootVal = preorder[preStart]; // root.left 的值是前序遍历第⼆个元素 // 通过前序和后序遍历构造⼆叉树的关键在于通过左⼦树的根节点 // 确定 preorder 和 postorder 中左右⼦树的元素区间 int leftRootVal = preorder[preStart + 1]; // leftRootVal 在后序遍历数组中的索引 int index = 0; for (int i = postStart; i &lt; postEnd; i++) { if (postorder[i] == leftRootVal) { index = i; break; } } // 左⼦树的元素个数 int leftSize = index - postStart + 1; // 先构造出当前根节点 TreeNode root = new TreeNode(rootVal); // 递归构造左右⼦树 // 根据左⼦树的根节点索引和元素个数推导左右⼦树的索引边界 root.left = build(preorder, preStart + 1, preStart + leftSize, postorder, postStart, index); root.right = build(preorder, preStart + leftSize + 1, preEnd, postorder, index + 1, postEnd - 1); return root; } }","link":"/2024/02/24/2sf-6/"},{"title":"vue+three.js环境的搭建","text":"在这篇文章中直接讲明关于 three.js 源码包初使用的操作步骤，其他构建项目的过程一带而过。 第一步，创建自己的 vue 项目由于电脑全局安装的还是之前的 vue2 版本，而且在写项目的时候也是一直使用的 vue2，所以这次还是 vue2 创建项目，使用口令 1vue init webpack 项目名 第二步，安装 three 源码包在这里，我遇到很多问题，在之后构建项目的时候，出现了引入的部件 undefined 的情况，我也试过重装的方法，但是都不行，最后我发现我安装的是three.js，而不是three，这两个是有很大区别的！ 以上是 three 资源包的目录，在 three.js 中虽然能找到对应需要引入的部件，但是在项目中是不好用的，会出现对应部件的语法错误的问题，这个地方也是因为马虎的一个小坑。 在我们知道安装 three 而不是 three.js 之后的问题之后，我们就正常使用 npm 安装命令就可以了 1npm i three --save 但是如果单纯是自己测试娱乐的话，可以把 three.js 下载在本地，然后 live example 去跑跑样例，或者是写一些简单的代码运行也可以 通过这种方法引入 轨道控制器 OrbitControls的时候，要注意对应的版本，要不然会出现出错的情况","link":"/2024/02/26/3th-1/"},{"title":"three.js-3D场景Scene的创建","text":"能把模型展示在屏幕上，当然少不了对 3D 场景的创建 三维场景Scene你可以把三维场景Scene (opens new window)对象理解为虚拟的 3D 场景，用来表示模拟生活中的真实三维场景,或者说三维世界。 12// 创建3D场景对象Sceneconst scene = new THREE.Scene(); 接着我们去看如何在场景中添加物体 在我们生活当中的物体，比如棉花，我们知道它是形状不定、蓬松柔软的。在 three.js 中也是如此，也需要对应的形状和材质才能确定这个物体。 那么创建物体第一步，创建一个几何形状 Three.js 提供了各种各样的几何体 API，用来表示三维物体的几何形状。 如果你想定义物体的外观效果，比如颜色，就需要通过材质Material相关的 API 实现。 12//创建一个长方体几何对象Geometryconst geometry = new THREE.BoxGeometry(100, 100, 100); 第二步，创建物体的材质 threejs 不同材质渲染效果不同，下面就以 threejs 最简单的网格基础材质MeshBasicMaterial (opens new window)为例实现一个红色材质效果 1234//创建一个材质对象Materialconst material = new THREE.MeshBasicMaterial({ color: 0xff0000, //0xff0000设置材质颜色为红色}); 最后一步，创建网格模型 12// 两个参数分别为几何体geometry、材质materialconst mesh = new THREE.Mesh(geometry, material); //网格模型对象Mesh 创建好网格模型之后，还需要确定模型位置.position 实际生活中，一个物体往往是有位置的，对于 threejs 而言也是一样的，你可以通过位置属性.position定义网格模型Mesh在三维场景Scene中的位置。 123const mesh = new THREE.Mesh(geometry, material); //网格模型对象Mesh//设置网格模型在三维空间中的位置坐标，默认是坐标原点mesh.position.set(0, 10, 0); 这个时候我们场景 scene和网格模型都已经搭建好了，我们需要使用.add方法将网格模型添加到我们的场景当中 1scene.add(mesh);","link":"/2024/02/27/3th-2/"},{"title":"生活小记-魔方三阶复原公式(初级篇)","text":"目前一共开了四个专栏，前端学习、算法小记、three.js、生活小记，生活小记就是记录生活的小事，可能是学习了什么东西或者对什么东西的感受 1. 黄心白色十字 2.确定中点和最下层一致 并做成白心白色十字对齐固定中点与最下层中点一致 翻转向下 90 度 此时白色为底色 置于最下层 3.确定最下层与中心方块一致当第一层有白色混合棱角 移到另外两色块中间 使用右手公式（上左下右） 多次切换 4.确定第二层与中心方块一致当第一层有不含黄色方块将其面向色块与中心色块保持一致 另一色块在其一侧 移动上层 使其远离另一色块如果方向为左 做右手公式（上左下右） 再将白色方块置于左侧 做左手公式（上右下左）如果方向为右 做左手公式（上右下左） 再将白色方块置于右侧 做右手公式（上左下右）当第一层均包含黄色方块将第二次异常方块置于右手 做右手公式（上左下右） 再将白色方块置于左侧 做左手公式（上右下左）此时异常方块已移动到最上层 再重复（当第一层有不含黄色方块） 5.确定最上层黄心十字当上层无 L 型或横型 选任意方向 前方顺时针 90 度 做右手公式（上左下右） 前方逆时针 90 度此时为 L 型 两边朝向右手 前方顺时针 90 度 做右手公式（上左下右） 前方逆时针 90 度此时为横型 平行横线 前方顺时针 90 度 做右手公式（上左下右） 前方逆时针 90 度 6.确定最上层上平面下右上右下右右上此时有小鱼图样 （有且只有三个黄色块）鱼头朝上 下右上右下右右上此时有两个非黄色色块侧面黄色置于左上朝外 下右上右下右右上此时有小鱼图样 （有且只有三个黄色块）鱼头朝上 下右上右下右右上 7.确定最上层角块有角块颜色一致选择角块颜色一致的朝下 面向黄色 上右上 下面 180° 下左上 下面 180° 右面 180°无角块颜色一致选择任意朝下 面向黄色 上右上 下面 180° 下左上 下面 180° 右面 180°有角块颜色一致 8.确定最上层中点有好的一面好的一面对准自己 下左下右 下右下左 上左 180°没好的一面任意一面对准自己 下左下右 下右下左 上左 180°好的一面 我一定要学会 CFOP！~","link":"/2024/02/28/4sh-1/"},{"title":"生活小记-开学日","text":"0b2f4e5d6eec5d3dd7df5050da23c5c48069d06e8251935a3460c26e532f4749441816f60f8296cfdfa80b3f44648732afd424d40d829741d49eaa055494840e52a208e3e532bb7a534b52090b25f61568f55f50e682ae86dabe435b538b3aff984994d9d4a8024a866df7bd2e0d1b96db4414f360aba828d4b68a207cfa294c58935677185b0399c9d03ecbc03252731af60b6ac4786f99c3e8f1e765a21395983f15a7476299ee59b4e90898a6a0db8739f79e704160d2a418aff9093e387a6605f3aef04aec1654283e4bb83bd655e770fe23db30021af01406facfbf7abea58ba9d9fe1513b7af4b82b4d7cf0456c9e962600752273227b6957e691865a356cd7b2ed2c707899a597810444fcdeeecdba850581130ef85dac0597cb7cd291727dae8a0e262417d60a0fd5a51d1f4821e7293e297fb9255cb3b5b1510d35ea8fc4ac4719b389363951069fe43b595c3a062acebd59557073c8299570a222d74eb8d77902f080289ce65ce1bdefd602bb2983b9f5f5ccaffe23670dbaeea563358f689c1695bbbf9e20f82ee8878f5b928b4bed7c943d39b91e4831b0b6b8d2b88f6662a80b8ad97ad9ee1336b7b4a7eb92895224d834f00c8efe45877ea32fa8d41c2c3f18db1c8729d846b06910987d98ba00b80ce0076cb40c90b644dc230702d6c37b9bf97258a58ee31279a522695b5381f3de50f64acbb1756dc972e0eef04b7928e062f0e8595d7701c696616cc9404adf66ae3b132185e9cfe1279bab9d533cb390e032bdb52cbb106707a8835784b2439970736f637722b987802fdfb102edc41d65807126ffeae0e2db41f96a8d11ed09821125cec130c88cf5eda297d5acd76f650fca0c1b7b258e78f7e281cb3cd293cd02511fd49a982dd7387d269a82e98a9b63d6128ef123f531393adc09443a9f45ea08b710bb8b74b79f3bd6b896b7e966f14bc3d9a919d8481c5765f814105eac7a4876d4eff90e2dc97b5e7c130716e1e6c0627bc3c2f2a0a34eecf7c6f44e33cfa821ecef2f074892215cd5cc701a913280928aa9db35b3908eae51036623184e1a65f3e333098a8fd6fae0043ec50a7dccdbf067e0ed1fb444173435cb36758b6d088bec478ae7de233739af2eff7715fd9ad9016f92c6b9a7400f21fc4342d94c8a775ad0a34fb16901eefede8593a980a8d0cf4900620299f93384c3fcf1fd6a5b6955efa62705df2df89a17c209ef94f234cad6ed35685578b774b3f81ab945dd43ded400f0138ddc95231edae1b5c4344352452c239f28cbe3be35841a30d24bff1d2fab104e2271e309bbf946be51941f1f45e49deb2bd6e8a8999f4f949db847087b6152ead270c6cac35940ffc0aa039b3137cbe8eb8727c5ff2ccf2706c780ab6b8ada542ca293d688a92fb87440cf4ace203d329a112f0a8a9a390d4c88abd0f42323d2d3b7fcc8db5aa3ed3745879f88124f0cb423defe4b2737a1bd44831a9dd5bcbb8cfe256f5bc8677807420071de58793276ecf2a2467cbf6d04e6c5fc52dfd9318a685da0ccb637c3494eae3a1f3ce2a027a5af93ae5c9a45692ba6c47c4566cec05f8309db8cb32a02172808897ea14b205ff0313c7353baba1cdfd181000576a8f0e4d4ab7835c7eb59169bd780dacef7eb1f0867c518276409da59795055db8111d0ebc0201bcd0ed4e99463e3f6c0346ef36326fdbb8ce8b8c399282104dad84c278a24df114b2c29922ec593be00c31096bccdfd9f11d913d2fb4add0c3a4816a928c2bf30c7fa712752066d68c41ddf196870d3e96929252cf9b96146fdcaba622b2c050d0885ce3349e899c47a20a074f5c117f8986e2d1c9b76f722eb7b9e3cf8ab17970fd9f6573c41bc482d8476eb7ec725d4a35edde40415bc154f98f8f5a2c66afbc4e445f575c49b65444ece6724e554c1dd9d1c4785e19b0871f2b059a20d0a02a9213edf68ae555ec9710a42c487b419679016ebf1bf5cc4ac42287819826df486350122f377e0373b58f93fd0df53c07bfb9cbecea669b68000d1a7000f051d0d9b843e111c0eeab371435dad5bf9afa0c10668f28db4983668b37def71a216fefd4d1de233e5397b0266006d6523e1f043973ce5917a7ccd47f24cd4b0a05e0d68b1a39589ea2bb24ac749560056185c48784b5bdf4f3f6 请输入密码","link":"/2024/03/02/4sh-2/"},{"title":"three.js-加载glb模型(含踩坑)","text":"在假期学了 three.js 的教程，但是也只停留在听的层次，没有练习过，听能听懂，但是到实操的时候问题比比皆是，这篇文章是关于如何用 three.js 去加载 glb 模型的，包含找了很久也没解决但是最后成功了的方法 在上一节的 three.js 教程中，学会了怎么搭建一个场景，以及是怎么渲染出来了，再用一句话去概括一下这个过程 这就好比我们的生活中，我们通过眼睛去看这个世界，这个世界里面有很多东西，这个就是由物体和环境构成的场景，也就是我们说的scene，再者，我们通过眼睛去看这个环境的一草一木，一人一物，这个就是对应的camera，也就是那个相机，但是我们随着时间的流逝，也就物体在运动，也可能在静止状态，但是我们不能通过这一瞬间知道物体之后的状态，所以渲染器的持续渲染(实时渲染)就很重要了，有了renderer我们才能知道我们观察物体的状态及运动。 在场景、相机以及渲染器都调试好了之后，我们可以加载我们的模型了，其实加载模型不难，直接用 loader 里面的 load 方法加载不就行了嘛。没错当我在弄得时候也是这么想的，但是在实操的时候我忽略了几个问题： 模型的路径问题 模型放在哪个文件里 这两个问题困扰我很长时间，第二个问题比较好解决。但是第一个问题我找了很多帖子，在我这就是不好用 o(╥﹏╥)o 下面开始一步步在加载模型 1.引用加载器这次加载的模型用到这两个模型 12import { GLTFLoader } from &quot;three/examples/jsm/loaders/GLTFLoader&quot;;import { DRACOLoader } from &quot;three/examples/jsm/loaders/DRACOLoader&quot;; 关于这两个加载器的介绍 GLTFLoader 用于载入glTF 2.0资源的加载器 DRACOLoader DRACOLoader：一个用于加载经过 Draco 压缩的图形库。 Draco是一个开源的库，主要用于压缩和解压缩三维模型及点云。 以客户端上解压缩为代价，显著减少压缩的图形。 2.结合使用123456789const loader = new GLTFLoader();const dracoLoader = new DRACOLoader();dracoLoader.setDecoderPath(&quot;/static/draco/&quot;);// 使用js方式解压dracoLoader.setDecoderConfig({ type: &quot;js&quot; });// 初始化_initDecoder 解码器dracoLoader.preload();loader.setDRACOLoader(dracoLoader); 在这里就需要进行很多操作了，首先先说下这段代码的意思 setDecoderPath：设置解压的路径，这里不是模型的路径，而是采用哪种压缩的方法（我的理解） 然后再进行 js 方式解压，并初始化 Decoder 解码器，最后将初始化好的 dracoLoader 加载器作为 gltf 加载器，这样能提高浏览器响应 那么对应的操作是什么？先看我的文件目录 当时我的 glb 文件就是加载不上，所以听从了网上的建议，将对应的 glb 文件放在static文件夹中，但是我用的 vue2，所以只能新建一个了，说明我的模型文件为静态文件，不需要进行对应的打包，然后将里面的gltf 里面的文件和 gltf 整个文件夹放在 draco 里面，至于怎么在 draco 的文件里面，因为当时我们设置的DecoderPath就是在 static 文件下的 draco 文件夹下，我们需要使用到 draco 里面的文件，自然而然就放到 draco 文件夹下。 3.加载模型当上面都设置好了之后，那就没什么问题了吧？？？ 错错错！精彩才刚刚开始！！！ 因为模型的路径问题，我耗费了整整小一天（也许是我太废物了） 步入正题，首先需要确认模型放在哪？ 我们在上面创建了 static 文件夹，再创建data文件夹，将我们的 glb 文件放在我们data文件夹中 然后我们为我们 glb 资源文件创建一个对象 1234567891011const carModel = [ { name: &quot;EXT&quot;, path: &quot;/static/data/lynkco09/model/Lynkco09_EXT_d.glb&quot;, }, { name: &quot;INT&quot;, path: &quot;/static/data/lynkco09/model/Lynkco09_INT_d.glb&quot;, }, ... ]; 这块问题就很多了，我最先开始不知道将 glb 文件放在 static/data 文件夹下，走了很多坑，一直在试，主要也很奇怪，我用其他的 glb 文件没有问题，但是就是用这个车模的 glb 文件出了问题，所以一直在试错阶段。第二个问题就是资源文件的前缀，要加上/static，我在网上找了很多教程都是不加的，反正也没看到有加的，没加的时候我的资源文件就是不好用的，但是在加了之后，我的 glb 资源文件就可以通过 three.js 渲染出来了，很神奇~ 写到这，其实问题大差不差就解决好了，就是运用 group 将各个 glb 资源文件通过加载器加载，然后组合成一个 model，组合之后放在 scene 里面就行了。最后的代码是这样的 12345678const model = new THREE.Group(); //声明一个组对象，用来添加加载成功的三维场景carModel.forEach((item) =&gt; { loader.load(item.path, (gltf) =&gt; { console.log(gltf); model.add(gltf.scene); });});return model; 让我们看一下最后的渲染结果： 至于为什么问题这么多还加载这个模型，一是踩坑有经验，二是这个车模比较帅哈哈","link":"/2024/02/29/3th-3/"},{"title":"three.js-创建渲染器renderer","text":"到这里，我们所需要的环境 scene（物体在环境中）、看这个三维世界的眼睛 Camera 都有了，但是我们还差一步，就是对这个世界的感受和渲染，这时候就需要 renderer 了 WebGL 渲染器WebGLRenderer通过 WebGL 渲染器WebGLRenderer (opens new window)可以实例化一个 WebGL 渲染器对象。 12// 创建渲染器对象const renderer = new THREE.WebGLRenderer(); 设置 Canvas 画布尺寸.setSize()1234// 定义threejs输出画布的尺寸(单位:像素px)const width = 800; //宽度const height = 500; //高度renderer.setSize(width, height); //设置three.js渲染区域的尺寸(像素px) 但是通过这种方法的话，当窗口大小发生变化的时候，渲染区域不进行变化，这时候在调用 BOM 方法就好了，示例代码： 123456//当窗口变化的时候，窗口实时渲染window.onresize = function () { renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();}; 渲染器渲染方法.render()渲染器WebGLRenderer执行渲染方法.render()就可以生成一个 Canvas 画布(照片)，并把三维场景 Scene 呈现在 canvas 画布上面,你可以把.render()理解为相机的拍照动作“咔”。 1renderer.render(scene, camera); //执行渲染操作 因为是在场景和相机上进行渲染的，所以里面的参数分别是scene和Camera 渲染器 Canvas 画布属性.domElement渲染器WebGLRenderer通过属性.domElement可以获得渲染方法.render()生成的 Canvas 画布，.domElement本质上就是一个 HTML 元素：Canvas 画布。 1document.body.appendChild(renderer.domElement); 我们在网页看 3D 的背景的时候，我们看里面的 HTML 节点都会发现有 canvas 节点 我们除了放在 body 节点下，我们也可以直接插在其他的 DOM 节点下 Canvas 画布插入到任意 HTML 元素中12&lt;div id=&quot;webgl&quot; style=&quot;margin-top: 200px;margin-left: 100px;&quot;&gt;&lt;/div&gt;document.getElementById('webgl').appendChild(renderer.domElement);","link":"/2024/02/28/3th-5/"},{"title":"three.js-创建相机camera","text":"我们通过眼睛去看这个世界，当然当我们去渲染我们的三维场景的时候也需要一个“眼睛”去将这个三维场景渲染出来，所以这个时候相机 camera 就起作用了，充当这个三维世界的眼睛 透视投影相机 PerspectiveCameraThreejs 提供了正投影相机OrthographicCamera (opens new window)和透视投影相机PerspectiveCamera (opens new window)关于这两个相机的介绍 正投影相机 这一摄像机使用orthographic projection（正交投影）来进行投影。 在这种投影模式下，无论物体距离相机距离远或者近，在最终渲染的图片中物体的大小都保持不变。 透视投影相机 这一摄像机使用perspective projection（透视投影）来进行投影。 这一投影模式被用来模拟人眼所看到的景象，它是 3D 场景的渲染中使用得最普遍的投影模式。 12// 实例化一个透视投影相机对象const camera = new THREE.PerspectiveCamera(); 实例方法相机位置.position生活中用相机拍照，你相机位置不同，拍照结果也不同，threejs 中虚拟相机同样如此。 比如有一间房子，你拿着相机站在房间里面，看到的是房间内部，站在房子外面看到的是房子外面效果。 相机对象Camera具有位置属性.position，通过位置属性.position可以设置相机的位置。 123//相机在Three.js三维坐标系中的位置// 根据需要设置相机位置具体值camera.position.set(200, 200, 200); 相机观察目标.lookAt()你用相机拍照你需要控制相机的拍照目标，具体说相机镜头对准哪个物体或说哪个坐标。对于 threejs 相机而言，就是设置.lookAt()方法的参数，指定一个 3D 坐标。 1234//相机观察目标指向Threejs 3D空间中某个位置camera.lookAt(0, 0, 0); //坐标原点camera.lookAt(0, 10, 0); //y轴上位置10camera.lookAt(mesh.position); //指向mesh对应的位置 透视投影相机PerspectiveCamera：视锥体透视投影相机的四个参数fov, aspect, near, far构成一个四棱台3D 空间，被称为视锥体，只有视锥体之内的物体，才会渲染出来，视锥体范围之外的物体不会显示在 Canvas 画布上。 这就好比，我们正在向前面看的时候，既不能看到脚下有什么，也不能看到极远处有什么。 12345// width和height用来设置Three.js输出的Canvas画布尺寸(像素px)const width = 800; //宽度const height = 500; //高度// 30:视场角度, width / height:Canvas画布宽高比, 1:近裁截面, 3000：远裁截面const camera = new THREE.PerspectiveCamera(30, width / height, 1, 3000); PerspectiveCamera参数介绍： 1PerspectiveCamera(fov, aspect, near, far); 参数 含义 默认值 fov 相机视锥体竖直方向视野角度 50 aspect 相机视锥体水平方向和竖直方向长度比，一般设置为 Canvas 画布宽高比 width / height 1 near 相机视锥体近裁截面相对相机距离 0.1 far 相机视锥体远裁截面相对相机距离，far-near 构成了视锥体高度方向 2000","link":"/2024/02/28/3th-4/"},{"title":"生活小记-所想所记3-6","text":"0b2f4e5d6eec5d3dd7df5050da23c5c44739b64c9ecfc068d86ca413ab32bb26164bafc552ed0f378cd6fb1dd0e3f95b227797b8ef9691f3b0904d142a99d5e009cb7281019c5fd101e1420404ba9ad1a22736d707c142e2a41a65493ded92f22ced2e1bff9335836fee727cbf9e11d475a57adbd257cdac59ecdeeb16d767a27743088a8f9664e49d2df4c5c298303a560a9f3eb9b8b109cc5dc3436dbd4b3c786f25c8bb5752cb11208d537ea9ff6c95301ea11e88ecd5e07651d926c9dd558663369dce2a5063fe35d45fb6b9cf7fff9266846752b986f0eda4189951ff77fc218cef99fe1f16e385982d5d1da262dc59f5c657c1ca3958cc1dfd2b83138a5c86a07f84856bd66324957fc8c01f8ecf29c7e448c3b2cfc77a1b7df84c4c49207d3da7a4c293af44eabf5fe983a2568774bfd628d639b1834f3b732be197c9e2f41b9687d0e8f17ba9f7e8cf90ac5a605503992ef27aadac713499e08e5c3f19e56503252f8ce85a8f33d2e8b18f83b1631d234c623912e284cac3cc19f53c7a02bcd2eeea76cafa108be5bb849d84bbe8c1fcefb346a8c67d35c4fd8a30acff55546af7f58c9ee26c644e2835a50be93d1f5a0f3b5148ee80eb4a335fcd2c3e7bf9ec7f414bd5121b45ebcc98e7cfba817db6c88fa50db6048becc46a1624f14f830348a7555b478a51a3b95dac9288e53f820bcee467e7b20dd9186e696dbaf68b257566d033a6fa494d229a072f9ae1ae3feb3962f53a654ed73e7877ce40734c23be622a357d1c03ca00131354442942eea925abb50ac3f3b2758bdf329a68804ffd3a9085b36fa45f430376b41451c103943f3bdc680748cb713df4d9912c73ed22219d8717fd6e90fe50d67f5f15211f3e9beb353670cbe92e3019041e05e753d6a66fe3dbe4f0556c28f6ee7181941c2f00e73e6ebc7cd84b897f8e3bac86d3e22b97ecb16dd7417d1f7e04722889d983adea3c8bd3c8edda1f1ad12fc0910b3549ba19fc05779d893061ac457a36334d3ba0c77a8a3ed66c5bd9b46df9b904c7b11141f6525664587f0c910491e10307021ef5a035226849ba450854dd90bbb9237b24c0c9087e793d73492e01179a614f1dde7a0274f4bfc9c2dbb0a7c480fab72c398d6c556392322f3d37660459443b90e1eeb810c01652bae94b3c94cbdc8a1aeca9702407cbf2e980853ac16b0c05d749edc11e6e4235c20d9ff4103eb7b210ef71a9b0d599ec36ba9b2dd2971a42f3108e2f40a1af8e677ed0e3a479515216bfda979647b68b2cffa1609cf861b2657678aa5f126374343b644f1ec8cdc162eb8e14768826c85343e3f0079c78c99273bca64a40078a58da042a804afd21d6691b60e8a69ce673b005e7202a8851aa93baffedd7d482d7ad1933c38f57ef7f0e1e8090f9ea0d674bcf81ce6d931c24ab199721b430e5e26ee0ea52a774da48f6c3848421405647cc96eff78332c990d0b1054f541fe9043ceac113b71f4c04664959db7612117b596fbfa5ad733a784951c6438ae111c3804cf4a5173e75ee788f889fb3821f12308bc1647a477868cc5a0bf1a2379dc05ad188e2f179c7c7e4d1733774c95ffbc9187a078f1c4894dec7b307819d9b4b860d87e864b36df78326b8466440fb8c8722019b3ddb042a75096db6ab42afd9a66903254d917229c974d05fca820f79939d056d20b0401e237890d8ebb8e1b36845930759f8437b747e6bcb02cf2db5cb23f115ffeba642c553ad760f9adab1495e4c2f01f4211a7223e31f61180ed5ec272e0c7604815cd6f4c7bac7cd11e05da672ebf15058977a34d64aff5b021e0b2b3c120b3e2097a2fa89fc85318ebf89692a9426daf9d7b05e8db56e5aaad17eae50ed5620098919d16c494d9aab1b7b862c9af148d84dcc35b2dd17669a85be916af1e5700e8d2e6c5716083831dab159357e80f1bcd36d710b9e9a4766f8b5264af79f90157d87d231329081c67365a542e481112f24056e09f5254f10e250c60e0cba7e4addcde33a8df96eb08afd4f9d9224260526c8c08b29ed7b1dd9974137330e6ac4c0702a53ef3f932871a3491e19c8edfe5586af3df88e48e292f247897ab88e1ae4ccdf2b535a822b33ae9f86156415dd35afaaa13b8fb969e9b3b08f7a7874d676e5c8f08b5d6b2238d32a5395ec17bd597b514ec1fe22cbf32675aa89c021966677dc8b4a6307dad79f2843823c1b70b36274c4b4dfa8a05772eccbd358726b6835eb3f59a91daea26199b2ea0a34120165705452a6baed47ed0362c0fa1754379e26876624571dc50fde65af92421bdeb61f9d282466bb3a168a4437d407b2852afe3e9811f8753b99d33d8466f7ae8830430aef9f72b8dea528d7f916ef98c5f8a4f203d903bd1702ab96f83a6fa50b36f42915445ff44e7877f952da90fa4338f972e265f6a45b1502ba187d4dd9790634667db7b77e8513d462bac195078994f4097730ee890eb2433380f581073482ac70a008f5cdeb12129537dd9786dabfb17c2606ae287dea8823ce496d1c1c22eb0e8d8d4d4b519dcabdf11968c1afc0d09846eaa2eba48a529d31198f8961b35d3821d953763ae3adad0ea3f15a1121e0859c8d1913a343 请输入密码","link":"/2024/03/06/4sh-3/"},{"title":"生活小记-所想所记3-11","text":"0b2f4e5d6eec5d3dd7df5050da23c5c48069d06e8251935a3460c26e532f47496d6d8bcf7ee954733572ad06e3371a6207440eaa72c3ecd416e2bee13d8184b924a4a3434d7934e415b5f524bed91bdf0c1a0459e5728373e8028c2af69ff3d8a61784d8b0a075164e400aaaf394939bced1796d56b0f03fde3efbfce6b54fbbe2ee57e1738c58950177c84c0ee0a0ec86503ee77c716c203e4377774b8644fa4d2e886959c9108fdedf4815b4d35edc40ffbf1eaaace0b7489e201b1d9966b5d3ff184222da7a156f8898cab88b406fb2dbd120ae2a3018775444e9ce6bed386e5372522fb9cbd9fb261d4ca8447b26a8aed67205ca93ce4657e7372aaa6b1bff48a643c254dcdb9b41a31080ad28d7dddc2eda5691dc8b2e5a68920edd67364590403e6300a716eb745f31af60cb65554d1c01e7a6f365d62db71ac6cc8fffcfc5845f04567a4394a5b8e1476bd9e8c8b5c5620e66120f78f0d3fbde07f612033bca278eead4ac3067f98ca6da356180e2b1f7aed2a522c8c536e684b0af2ec77353decd201e9929112192d098db5c3427187c433ca20f4b8d6bb9034643ac4062471a4280fd2121bea721bd17dfca3331895270f35f7c0d00725c10bde90df2e217f71ce939c0551376a0cd79eacec96b540ee5d90ea7c5b3a1209f139780da291c048dfe70c3fd4addd0fbb9c760e7e0e7b5a2394ce0e719c6ea7d5093382470322ba89b978664a81e89548c82386320908338451831b174fa905a1d1a0a8813c8fa5ef2f7b59817e44b96d0c6c286772ec93743a79a0e8663f5963960c7e50c0eca2daa358533317e17ee91e452540743640ca7494e4cce5fcd07d349a917577699ba278293e476d5267fca2ee23dad0937aba9b67eddbaafcc55f6c93678a44e008ff27d95ca4119eee82e993019f3ea6c8d46c43c52ad16477255c521e469f78a008fbc7978f0a706a3cc3b3d63453e7629e28f0431c66eb5a7f85669e8c24f76bb669d9f953b0d79beafe5abfcd46eb93524ebe353be62ae2b6c108034bd96fa21c10eae7753d068f2b04e3865853865d3b0d49d52a42577837d889b9db107391f1df94b6ee76d3e5cd80972f0556576e20420a7dd6f48e11e43e719477c5331a9c633e840251f5255a584040717810914101e49b0045021c11eccb7f25e85ffd3556216232c878a28eaa86840eaf028258eed858b98de2f64fbd132bb3ad3922900919d0b59aa3db89ee24f11af91e085635f04acb398bd6710cd7272d57e68630582dd654b4ae9d7716362524671642f64d1409d19d8d4c100002e6f1bf10b816ba60208e45c8b6d5d287dacf185d707ce10186d3c8096eb24c3b72af51ec28d90c2d4272fd37d0a15e0c23d85612329cdf42138e5906c46973927aac6842c1b656b5836d65b5b66d87729e503f1f9be25e6a9b6c024060ad3d008e499663a9fba637892f9cde01140df04ba4eb92bd0ba79becb18d5443e5e7624ad33b1bd73c318411155e5079bc78953a9b31d070085504435e3e4a4d640e96b5e9fb4069795b9ba853ab91d3cd7684fed3f48125bc7d1ffc54b874432cf7b9a405f49c90b799ba47f4c09e4b3f19f39e96ec23571115abcdb7a6cacef856d3709f640622399943d5e221445ab56a170 请输入密码","link":"/2024/03/11/4sh-4/"},{"title":"前端-CSS实现滚动高度自动变小的粘滞效果","text":"实现效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; * { margin: 0; padding: 0; } body { --height-outer: 120px; --height-inner: 50px; background-color: #eee; margin: 0; font-family: system-ui; } header { display: flex; align-items: center; position: sticky; height: var(--height-outer); top: calc(var(--height-inner) - var(--height-outer)); border-bottom: 1px solid #ccc; background-color: #fff; } .header-inner { display: flex; line-height: var(--height-inner); width: 980px; max-width: calc(100% - 2rem); margin: 0 auto; justify-content: space-between; position: sticky; top: 0; } main { background-color: aliceblue; min-height: 2500px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt; &lt;div class=&quot;header-inner&quot;&gt; &lt;h1&gt;LOGO&lt;/h1&gt; &lt;nav&gt; &lt;a href=&quot;&quot;&gt;内容&lt;/a&gt; &lt;/nav&gt; &lt;/div&gt; &lt;/header&gt; &lt;main&gt;滚动内容&lt;/main&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2024/03/12/1qd-1/"},{"title":"算法知识5-算法超全模板-数组篇","text":"数组-二分查找模板二分理解： 有一天小明到图书馆借了 N 本书，出图书馆的时候，警报响了，于是保安把小明拦下，要检查一下哪本书没有登记出借。小明正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？于是保安把书分成两堆，让第一堆过一下报警器，报警器响；于是再把这堆书分成两堆…… 最终，检测了 logN 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是小明背着剩下的书走了。 从此，图书馆丢了 N - 1 本书。 二分条件： 用于查找的内容逻辑上来说是需要有序的 查找的数量只能是一个，而不是多个 模板： 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 12345678910111213141516171819202122232425262728293031323334import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class 二分模板 { public static void main(String[] args) throws IOException { BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); // 输入 int target = Integer.valueOf(in.readLine()); String[] numstr = in.readLine().split(&quot; &quot;); int[] nums = new int[numstr.length]; int n = nums.length; for (int i = 0; i &lt; n; i++) { nums[i] = Integer.valueOf(numstr[i]); } System.out.print(ef(nums, target)); } public static int ef(int[] nums, int target){ int left = 0; int right = nums.length - 1; while (left &lt;= right){ int middle = left +((right - left)/2) ; if (target &gt; nums[middle]){ left = middle + 1; continue; } if (target &lt; nums[middle]){ right = middle - 1; continue; } if (target == nums[middle]) return middle; } return -1; }} 数组-前缀和模板一维数组前缀和： 「一维前缀和」 是从 nums 数组中的第 0 位置开始累加，到第 i 位置的累加结果，我们常把这个结果保存到数组 preSum 中，记为 preSum[i]。 模板： 123456789101112131415import java.io.*;public class 一维数组前缀和 { public static void main(String[] args) throws IOException { BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); String[] numstr = in.readLine().split(&quot; &quot;); int n = numstr.length; int[] nums = new int[n]; for (int i = 0; i &lt; n; i++) { if (i == 0) nums[i] = Integer.valueOf(numstr[i]); else nums[i] = Integer.valueOf(numstr[i]) + nums[i - 1]; } System.out.print(nums[n - 1]); }} 二维数组前缀和： 情况一： 模板： 12345678910111213141516171819202122import java.io.*;public class 二维数组前缀和 { public static void main(String[] args) throws IOException{ BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); String[] bounds = in.readLine().split(&quot; &quot;); int n = Integer.valueOf(bounds[0]); int m = Integer.valueOf(bounds[1]); String[] nums = new String[n + 1]; for (int i = 1; i &lt;= n; i ++){ nums[i] = in.readLine(); } int[][] presum = new int[n + 1][m + 1]; for (int i = 1; i &lt;= n; i ++){ for (int j = 1; j &lt;= m; j ++){ int temp = Integer.valueOf(nums[i].split(&quot; &quot;)[j - 1]); presum[i][j] = presum[i - 1][j] + presum[i][j - 1] + temp - presum[i - 1][j - 1]; } } System.out.println(presum[n][m]); }} 由于用了快速输入，所以对于 temp 的值，要从存储数组的下标为 0 出开始，但是在循环里面我们的 i,j 变量是从 1 开始的，所以差 1，因此对应的 Integer.valueOf(nums[i].split(“ “)[j - 1]);中的 j 要减 1 情况二： 这个我们直接根据上个模板然后考虑数组的下标套用公式就行了 数组-全排列模板解释： 全排列：从 n 个不同元素中任取 m（m≤n）个元素，按照一定的顺序排列起来，叫做从 n 个不同元素中取出 m 个元素的一个排列。 当 m=n 时所有的排列情况叫全排列。 公式：全排列数 f (n)=n! 以上废话太多，简言之，就是把一列数生成顺序不同的数列，并将所有情况排列出来 模板： 12345678910111213141516171819202122232425262728293031import java.util.Arrays;import java.util.Scanner;public class 全排列 { public static void main(String[] args) { Scanner in = new Scanner(System.in); int n = in.nextInt(); int a[] = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = in.nextInt(); } prem(a, 0, n); } public static void prem(int a[], int s, int e){ if (s == e - 1){ System.out.println(Arrays.toString(a)); } else { for (int i = s; i &lt; e; i++) { swap(a, s, i); prem(a, s + 1, e); swap(a, s, i); } } } public static void swap(int a[], int i, int s){ int temp = a[i]; a[i] = a[s]; a[s] = temp; }} 数组-背包模板01 背包问题​ 一共有 N 件物品，第 i（i 从 1 开始）件物品的重量为 w[i]，价值为 v[i]。在总重量不超过背包承载上限 W 的情况下，能够装入背包的最大价值是多少？ 思路： 动规四部曲： 确定 dp 数组及其下标的含义 dp[i][j] 表示从下标为 [0 - i] 的物品里任意取，放进容量为 j 的背包，价值总和最大是多少。 确定递推公式 不放物品 i：由 dp[i - 1][j]推出，即背包容量为 j，里面不放物品 i 的最大价值，此时 dp[i][j]就是 dp[i - 1][j]。(其实就是当物品 i 的重量大于背包 j 的重量时，物品 i 无法放进背包中，所以被背包内的价值依然和前面相同。) 放物品 i：由 dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i] 为背包容量为 j - weight[i]的时候不放物品 i 的最大价值，那么 dp[i - 1][j - weight[i]] + value[i] （物品 i 的价值），就是背包放物品 i 得到的最大价值 递推公式： $$dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);$$ dp 数组的初始化 首先从 dp[i][j]的定义出发，如果背包容量 j 为 0 的话，即 dp[i][0]，无论是选取哪些物品，背包价值总和一定为 0 状态转移方程 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出 i 是由 i-1 推导出来，那么 i 为 0 的时候就一定要初始化 dp[0][j]：存放编号 0 的物品的时候，各个容量的背包所能存放的最大重量 j。那么很明显当 j &lt; weight[0]时，dp[0][j] 应该是 0（背包容量比编号 0 的物品重量还小）同理，当 j &gt;= weight[0]时，dp[0][j] 应该是 value[0]（背包容量足够放编号 0 物品 确定遍历顺序 先遍历物品还是先遍历背包都是可以的，且第二层 for 循环是从小到大遍历 模板二维数组： 123456789101112131415161718192021222324252627282930313233import java.io.*;public class 零一背包模板 { public static void main(String[] args) throws IOException{ BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); String[] bounds = in.readLine().split(&quot; &quot;); int n = Integer.valueOf(bounds[0]);//物品数量 int maxWeight = Integer.valueOf(bounds[1]);//最大重量 String[] values = in.readLine().split(&quot; &quot;);//物品价值 String[] weights = in.readLine().split(&quot; &quot;);//物品重量 int[][] dp = new int[n + 1][maxWeight + 1]; int initValue = Integer.valueOf(values[0]); int initWeight = Integer.valueOf(weights[0]); //二维数组初始化 for (int i = 0; i &lt;= maxWeight; i ++){ if (initWeight &lt;= i){ dp[0][i] = initValue; } } //动态规划 for (int i = 1; i &lt; n; i ++){ for (int j = 1; j &lt;= maxWeight; j ++){ if (j &lt; Integer.valueOf(weights[i])){ dp[i][j] = dp[i - 1][j];//不放物品 } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - Integer.valueOf(weights[i])] + Integer.valueOf(values[i])); } } } System.out.println(dp[n - 1][maxWeight]);//输出不高于最大重量的最大价值 }} 一维数组： 123456789101112131415161718192021import java.io.*;public class 零一背包模板 { public static void main(String[] args) throws IOException{ BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); String[] bounds = in.readLine().split(&quot; &quot;); int n = Integer.valueOf(bounds[0]);//物品数量 int maxWeight = Integer.valueOf(bounds[1]);//最大重量 String[] values = in.readLine().split(&quot; &quot;);//物品价值 String[] weights = in.readLine().split(&quot; &quot;);//物品重量 int[] dp = new int[maxWeight + 1]; for (int i = 0; i &lt; n; i ++){ for (int j = maxWeight; j &gt;= Integer.valueOf(weights[i]); j --){ dp[j] = dp[j - Integer.valueOf(weights[i])] + Integer.valueOf(values[i]); } } System.out.println(dp[maxWeight]); }} 从大到小遍历的原因：倒序遍历是为了保证物品 i 只被放入一次！但如果一旦正序遍历了，那么物品 0 就会被重复加入多次！ 这么看还是一维数组简单写一些，只不过需要注意数组遍历方向问题~ 完全背包有 N 件物品和一个最多能背重量为 W 的背包。第 i 件物品的重量是 weight[i]，得到的价值是 value[i]。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。完全背包和 01 背包问题唯一不同的地方就是，每种物品有无限件。 模板我们知道 01 背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即： 1234567891011121314151617181920import java.io.*;public class 完全背包模板 { public static void main(String[] args) throws IOException{ BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); String[] bounds = in.readLine().split(&quot; &quot;); int n = Integer.valueOf(bounds[0]); int maxWeight = Integer.valueOf(bounds[1]); String[] values = in.readLine().split(&quot; &quot;); String[] weights = in.readLine().split(&quot; &quot;); int[] dp = new int[maxWeight + 1]; for (int i = 0; i &lt; n; i ++){ for (int j = Integer.valueOf(weights[i]); j &lt;= maxWeight; j ++){ dp[j] = Math.max(dp[j], dp[j - Integer.valueOf(weights[i])] + Integer.valueOf(values[i])); } } System.out.println(dp[maxWeight]); }} 纯完全背包的一维 dp 数组实现，先遍历物品还是先遍历背包都是可以的，且第二层 for 循环是从小到大遍历（因为这样才能实现覆盖和物品无限数量） 多重背包背包最大重量为 10，物品为： 请问背包能背的物品最大价值为多少？ ​ 直接转换成下面的情况！ 这样就变成 01 背包了，代码实现逻辑一样，就不写模板了 并查集模板对于并查集，我们以一道 PTA 模板题目为例： 在一个社区里，每个人都有自己的小圈子，还可能同时属于很多不同的朋友圈。我们认为朋友的朋友都算在一个部落里，于是要请你统计一下，在一个给定社区中，到底有多少个互不相交的部落？并且检查 任意两个人是否属于同一个部落。 输入格式： 输入在第一行给出一个正整数N（≤104），是已知小圈子的个数。随后N行，每行按下列格式给出一个小圈子里的人： K P[1] P[2] ⋯ P[K] 其中K是小圈子里的人数，P[i]（i=1,⋯,_K_）是小圈子里每个人的编号。这里所有人的编号从 1 开始连续编号，最大编号不会超过 104。 之后一行给出一个非负整数Q（≤104），是查询次数。随后Q行，每行给出一对被查询的人的编号。 输出格式： 首先在一行中输出这个社区的总人数、以及互不相交的部落的个数。随后对每一次查询，如果他们属于同一个部落，则在一行中输出Y，否则输出N。 模板： 测试数据： 1234567843 10 1 22 3 44 1 5 7 83 9 6 4210 53 7 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.*;public class 并查集模板 { public static int[] fa = new int[10010]; public static int[] vis = new int[10010]; public static void main(String[] args) { Scanner in = new Scanner(System.in); int n = in.nextInt(); Arrays.fill(vis, 0); for (int i = 1; i &lt; 10010; i++) { fa[i] = i; } int sum = 0; for (int i = 0; i &lt; n; i ++){ int k = in.nextInt(); int dad = in.nextInt(); if (vis[dad] == 0){ vis[dad] = 1; sum ++; } for (int j = 1; j &lt; k; j ++){ int son = in.nextInt(); if (vis[son] == 0){ vis[son] = 1; sum ++; } merge(son, dad); } } int ans = 0; for (int i = 1; i &lt; 10010; i ++){ if (vis[i] == 1 &amp;&amp; i == find(i)){ ans ++; } } System.out.println(sum + &quot; &quot; + ans); int m = in.nextInt(); while (m -- &gt; 0) { int a = in.nextInt(); int b = in.nextInt(); if (find(a) == find(b)) System.out.println(&quot;Y\\n&quot;); else System.out.println(&quot;N\\n&quot;); } } public static int find(int x){ if (x == fa[x]) return x; return fa[x] = find(fa[x]); } public static void merge(int a, int b){ int x = find(a); int y = find(b); if (x != y) fa[x] = y;//让y当x的爹 }}","link":"/2024/03/14/2sf-7/"},{"title":"算法知识5-算法超全模板-字符串","text":"字符串查找 s**int indexOf(String s)**：字符串 s 在指定字符串中首次出现的索引位置，如果没有检索到字符串 s，该方法返回-1**int lastIndexOf(String s)**：字符串 s 在指定字符串中最后一次出现的索引位置，如果没有检索到字符串 s，该方法返回-1；如果 s 是空字符串，则返回的结果与 length 方法的返回结果相同，即返回整个字符串的长度。 获取指定位置的字符串char charAt(int index)方法：返回指定索引出的字符 12String str = &quot;abcde&quot;;char thischar = str.charAt(3);//索引为3的thischar是&quot;d&quot; 获取子字符串String substring()方法：实现截取字符串，利用字符串的下标索引来截取(字符串的下标是从 0 开始的，在字符串中空格占用一个索引位置) substring(int beginIndex)：截取从指定索引位置开始到字符串结尾的子串substring(int beginIndex, int endIndex)：从 beginIndex 开始，到 endIndex 结束(不包括 endIndex) 123String str = &quot;abcde&quot;;String substr1 = str.substring(2);//substr1为&quot;cde&quot;String substr2 = str.substring(2,4);//substr2为&quot;cd&quot; 去除字符串首尾的空格String trim()方法 12String str = &quot; ab cde &quot;;String str1 = str.trim();//str1为&quot;ab cde&quot; 判断字符串的开始与结尾boolean startsWith() boolean startsWith(String prefix)：判断此字符串是否以指定的后缀 prefix 开始boolean startsWith(String prefix, int beginidx)：判断此字符串中从 beginidx 开始的子串是否以指定的后缀 prefix 开始**boolean endsWith(String suffix)**：判断此字符串是否以指定的后缀 suffix 结束 1234String str = &quot;abcde&quot;;boolean res = str.startsWith(&quot;ab&quot;);//res为trueboolean res = str.StartsWith(&quot;bc&quot;,1);//res为trueboolean res = str.endsWith(&quot;de&quot;);//res为true 判断字符串是否相等boolean equals(Object anObject)：将此字符串与指定的对象比较，区分大小写**boolean equalsIgnoreCase(String anotherString)**：将此 String 与另一个 String 比较，不考虑大小写 123456String str1 = &quot;abcde&quot;;String str2 = str1;//字符串str1和str2都是一个字符串对象String str3 = &quot;ABCDE&quot;;boolean isEqualed = str1.equals(str2);//返回trueboolean isEqualed = str1.equals(str3);//返回falseboolean isEqualed = str1.equlasIgnoreCase(str3);//返回true 比较两个字符串**int compareTo(Object o)**：把这个字符串和另一个对象比较。**int compareTo(String anotherString)**：按字典顺序比较两个字符串。比较对应字符的大小(ASCII 码顺序)，如果参数字符串等于此字符串，则返回值 0；如果此字符串小于字符串参数，则返回一个小于 0 的值；如果此字符串大于字符串参数，则返回一个大于 0 的值。 123456String str1 = &quot;abcde&quot;;String str2 = &quot;abcde123&quot;;String str3 = str1;int res = str1.compareTo(str2);//res = -3int res = str1.compareTo(str3);//res = 0int res = str2.compareTo(str1);//res = 3 把字符串转换为相应的数值String 转 int 型： 1234//第一种int i = Integer.parseInt(String str)//第二种int i = Integer.valueOf(s).intValue(); String 转 long 型： 1long l = Long.parseLong(String str); String 转 double 型： 12double d = Double.valueOf(String str).doubleValue();//doubleValue()不要也可double d = Double.parseDouble(str); 字符串分割String[] split()：根据匹配给定的正则表达式来拆分字符串，将分割后的结果存入字符数组中。 String[] split(String regex)：regex 为正则表达式分隔符, . 、 $、 | 和 * 等转义字符，必须得加 \\；多个分隔符，可以用 | 作为连字符。String[] split(String regex, int limit)：limit 为分割份数 1234567String str = &quot;Hello World A.B.C&quot;String[] res = str.split(&quot; &quot;);//res = {&quot;Hello&quot;,&quot;World&quot;,&quot;A.B.C&quot;}String[] res = str.split(&quot; &quot;,2);//res = {&quot;Hello&quot;,&quot;World A.B.C&quot;}String[] res = str.split(&quot;\\\\.&quot;);//res = {&quot;Hello World A&quot;,&quot;B&quot;,&quot;C&quot;}String str = &quot;A=1 and B=2 or C=3&quot;String[] res = str.split(&quot;and|or&quot;);//res = {&quot;A=1 &quot;,&quot; B=2 &quot;,&quot; C=3&quot;} 字符数组与字符串的转换public String(char[] value) ：通过 char[]数组来创建字符串char[] toCharArray()：将此字符串转换为一个新的字符数组。 12String str = &quot;abcde&quot;;char mychar[] = str.toCharArray();//char[0] = 'a'; char[1] = 'b'.. StringBuffer&amp;[StringBuilder 类]与 String 类最大的不同在于这两个类可以对字符串进行修改。StringBuilder 相较 StringBuffer 来说速度较快，多数情况下使用 StringBuilder，但是 StringBuilder 的方法不是线性安全的（不能同步访问），所以在应用程序要求线程安全的情况下，必须使用 StringBuffer。创建 StringBuffer 字符串 1StringBuffer str = new StringBuffer(&quot;&quot;); 添加字符(最常用方法)123public StringBuffer append(String s)：将指定的字符串追加到字符序列中str.append(&quot;abc&quot;);//此时str为“abc” 删除字符串中的指定字符12345public delete(int start,int end)：移除此序列中的子字符串的内容public deleteCharAt(int i)：删除指定位置的字符str.delete(0,1);//此时str为“c”str.deleteCharAt(str.length()-1);//删除最后一个字符 翻转字符串public StringBuffer reverse() 1str.reverse(); 替换字符串中内容replace(int start,int end,String str)：用 String 类型的字符串 str 替换此字符串的子字符串中的内容 12String s = &quot;1&quot;;str.replace(1,1,s); 插入字符public insert(int offset, int i)：将 int 参数形式的字符串表示形式插入此序列中 1str.insert(1,2); 字符串长度int length()：返回长度（字符数）void setLength(int new Length)：设置字符序列的长度 12str.length();str.setLength(4); 当前容量int capacity()：获取当前容量void ensureCapacity(int minimumCapacity)：确保容量小于指定的最小值 1str.capacity(); 将其转变为 StringString toString() 1str.toString();//将StringBuffer类型的序列转变为String类型的字符串","link":"/2024/03/14/2sf-8/"},{"title":"生活小记-所想所记3-15","text":"0b2f4e5d6eec5d3dd7df5050da23c5c48069d06e8251935a3460c26e532f474993b2627b2fe7a5522abdd43aa2fc314fcb41fbffece21a813b161b28a119378ebc436f2ee502692d63fc7e3c63eb00f40c24d38e4a0364a77fd7d73ae1e7fe76550a2ad52f75903cc8fec6e00638b2201d60ab10d2e9e744b46968cce0ab4cdb8ad6ac7ddb7843a17e62b7927f7fb6f937cc5f87f6e9e8132dc2b8105d09f3592eb63e469295f26d393d53878e862b5fc3475d50814b696ab5334761d0e97df63b07f7d189ce7e760cc47ab29cd455a042e677329f2339c52545f7e1c51703205a6779f57241a612e4724b1a719e76cecef05012c14d63c68b519b9d3b6f80ebfd626fb740eeeefe0f79de55fd5db59c3f70cc8cc08532574a5aac1f014aaeb768e30a24cb7760d8b09ce43106509301e69058b161e26a611d983b00b36f47f6b09e0ceb3df3a39dab8f827964e0fd4169ae3ae7c58e2b6356c0657a7aae16c6af04ebd05e13815d342d9b92fb04636d0672a864055be74a12369133360645b7eed5b1ce0e11bfb6ccf14fed3ed6f8b7fd35a4057f8bfbd7c285135dbc52db4170b1e1f372e05cef515915e19e2306bb339cc15a4dfc4a0646b0aadf8f4d6e97dcef43ff9bd1b91335e7696edc96eec2586607c9b01c9432d9cbec7971852bd39a2b1f550b76589048110e9165fc81e4d1e3f7cfa01219f9ec464af9c883f2f56de7adfeb24a37205cc9ff83655045af0c8d6949de10e893e16cdbbcd4d0af293f831e4fdd68e8369f8b1ff29bcc25d26998e767336f1aecd8c8e0aed1c1e498687c381440dd6bcf6353305608e5cd59e8fa41ac11add8ebda243810f65695681334ac0c9a86c28626bf0af59df0c322b4b9fd9941b8a46ceab35458873e19fe358ed27989a5aa134a790b08037bea5e5a24b87039199b7f2e8d4d0b4492abf675528ca6295a3b894b0e3cc7499b57c44afb0ba63c93e9f191d8009ef88310b37bd6a4263608d80cbc969f4f60c90a7ccaf3d314df04069271fb69dfd6dd7e674708f46cfbd56615b4a49c01cc9d1cdff575a12afec6f86f6307d57afad299843a768982ee74689097ede1ce10651369bad84ae873c0a8fed3c1a0861f679fae106e01695df78014dc3bff4b4989066e545150ef1749006037ddcdfaa4a746bd4727f468cd744282169a725c99503050d61237cd76020ef90e1bcfa19abb6b15c28eec745cd5c84d1a54e51abdd20b37d4b0d7296a6985f35a869cede5b21ca98068448ac5c821f99bb2ed0556471bf6d56b600ad6dddf0c482b4ca4a154f796af28113202b8699290e43e058fc03d15669e2c3ac5135f1949eb5ae653b048881d232f34774d1e69e7c97ae50c22294d523b21e503311180cba4bf547e355b66026b53aa0f4bee59c38054507584a184cfd576ab6bfc21ae739a7ae43e17d4ed0b7b3081bbd35d5d8a16e0bbbea40d7d969a1af78481b56d85277ca83a0f50062c70f4557a0fa806c80429fc417745a0b95518f6977c752222d124dce3438812a12a36f493eabd9f90cbde42ab5125eb066414ce7270076f341704ddd7a1e391919bf85eb3e94546b6bf8117d40da0dfa5ea25c6fc5c2dc492b162df37dc0e02a9c217767ecc70a06ea2d4b813e7bb9f7fca02004994a4fc813ff3f9b91b6cc14834dac20dd92ae2d7d4cb60c7cf2d0f7c5644e3b454b44c3761105aa38969ab172723a95e3370a0a4c9fc71508ae173003be4ff269f8b23d7a0678903e6042d25ff178e85e8feab988061bd334664d8cf3767059cde7d19189c57a80c4e9b4367d1d1fd8069ef8f8eb74fb894a2c7ac71dcf35a1fbfc4f2aafc4f5090e646b25600ed39a53b007bc4cc63f56359c7aceb17ba4a774998e0a4a7eb666c1a9f7b90fd2e920c7dad25f745ce712b7010688f06c28a277df69ff9dd1c941163709809dd1c24902ad9b1388e7eeb30f25ff3e08826223b102cfae79fa8f317f6cf2e4b961d647e8b0f4e603550b773d0084f85ac26c744322c75f8d9bc108b17fb7760ad68581fa34abc8c9a943f568147d1b816b33e54ed38bdedf595bb2fa9082cf052f54c0375e5eaefc0434abe67cc95940fe5157777778711cbc16adb262b6f6df91af05b1ec8ce0d25c489e810e41db1884bab9418cfe619d4d4079b8a8e0519795fa35aebedcd99385d89e51b2b0d597a6fedab8bceff1aa7c61edb11f9ad748a01dbb9dcf0540f1d6066a466759c1c0788eda2d0a9bd7d8df2ebbee9b3b0e2000a996336be8526ff46820b2dacde350b2d10c1a676bd2c1e9109cb8cfb94306e6d52af01f268a79c0b2d179225ce9ff0bafe8ba568b16d5d849cd29a0994d2faaa68b39fd5e0874ed17d13315c92b0f0e469db5d12235998fe24ae0b6ce19f1f25af1e667ec6e9eb6c27b384e855099176c4ea2ac45531c8c72bc7c584dbafe2f0cd18f6ea5b5c762be17d630b6d55eb7c09d0c37cc08e4289239f9954cb5f467d35f575e5eb36f88e1d6c26d1b0f4d0aac9db5ee92112b5437216322a8ed98b8af1be40133bbd2ece627f67b9516b22792e618b868cf3d6936b8339538890f4bbc6fc8b8840209fa3fcf854eecc8c44f38fd52b96dcf95527d4a477818b8e9a728300768f60a3d13450fa0131a0230dc99c2572f2b9b362fa393d5e3d79fd1108dc32bcd58ffeb2a4487863ebdfafce8ad3f787e6cd72e29a8a869dc2bcfcfaff3ac3456906776fb37a181dcf5720193e819d741742d38956fd5795c30925759de3f18ba61c9906fa3c519304273d363b5b7701aacab00b7a0c9b6de3b7941b2f29a6ab2472c830d82bba6c048438f160ee22e66a56f7b4cee5727428a9f664dcd3756a7ac4e68a8b7da064faf169b69afdbcf00a0cbf97a561afe79db5e6c78e1f0838170e34ebe8b6c5b456a368733c43cad0d0a4d88adae27e86635162c668dc44e44595515cb90b343b32e2ea16fc5ecd571604f542373ed2b31721f9cd803b0a6a37996ad8a4c9647644249dc6500361d302fbbb98d95b7e5cf9a31ba0b38d9bb9833cd200a9c63e351edaa1eab335fde9e9fcc9f4dad960793b27f32e6c61a70d9aac95827cdd7dec6d19201a3048c9694acb348cdd2d9571a9b47dc465ba975000cf9fc09f28512821c11ea18a9d161ff85e6d948e32e16e5115a359db2832403b21296fc537298af0de507070d9d354629a42ab1ebe3c1a73d6f548e37a5c9b1e121fbb79146e250ee1194a292f2f6d95049d9f87a6749f77e6c9df93f30960b4aa16690abee9067bdeb240720e53273a66d80e5c1172ab4db2e6b2fc0ec4b987c4db1edb07baece29124fd4fcfb43ed952b61b336e6bb896c1080994c14f65ac9735dcbea27624ed630dcbd247f6e87306cba2fca441ad7e1cafc183c15bef3f495b7889e44942967f2a30cf1b29f8b7a05dcf3f743e13e52f8c17cb634bf6de0389ee3536d3ea74850f88da434649fd390a5d12c84e9f85201f9f36acdf0d2c1ac118c089f45d6a1e3fd43b0e8f66605685820182b63fdaf666760d9448fe01415cb5c24f53fdf8b839749b3c109f80107e8b1cec0648d4411a5f7133f3d6e99149e25a0698303525b3760d8af4c9dfa14765e2fe1c39ad6b26b936ea2d5b2b2d66f1cd4fc1a3ba65ee89bd7ddd48965b74ecc942e05a5e04aa4bca4b669d4f1f4848ac9301218e3c0a27d6ab9e674f7329f86344ebbf04cb7f7d163c7b78b4555034418cd7a7d976496f77c0b16ad577884b80c1595293dda70c14e619b3a5b1136104cbea8b5b507d2d6524b630dc8cb2b1bd85e88b138e6641baa79b9b2fc0443e33eda212e6eb792ef971cb153d35000aab262a68c7c0 请输入密码","link":"/2024/03/15/4sh-5/"},{"title":"前端-面经学习-HTML","text":"HTML（Hypertext Markup Language，又叫‘超文本标记语言’）是一种用于创建 Web 页面的标记语言，它描述了网页的结构和内容。 1，html 标签的类型（head， body，！Doctype） 他们的作用是什么head： 可以说是所有元素容纳的一个容器，这部分元素是不会显示给使用者或者是读者的 该标签下所包含的部分可以加入的标签有、、、、、 body： 用于定义文档的主体，包含了文档的所有内容 该标签支持 HTML 的全局属性和事件属性 !DOCTYPE： 指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。意在告诉浏览器使用怎么样的标准 2，H5 新特性新增选择器：document.querySelector、decument.querySelectorAll querySelector() 方法返回文档中匹配指定 CSS 选择器的一个元素。 注意： querySelector() 方法仅仅返回匹配指定选择器的第一个元素。如果你需要返回所有的元素，请使用 querySelectorAll() 方法替代。 拖拽释放(drag and drop)API 实例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;拖放示例&lt;/title&gt; &lt;style&gt; .dragbox { width: 100px; height: 100px; background-color: #ccc; margin: 10px; padding: 10px; text-align: center; cursor: move; } .dropbox { width: 200px; height: 200px; background-color: #f0f0f0; margin: 10px; padding: 10px; text-align: center; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;dragbox&quot; draggable=&quot;true&quot; ondragstart=&quot;drag(event)&quot;&gt;这是个可拖动的元素&lt;/div&gt; &lt;div class=&quot;dropbox&quot; ondragover=&quot;allowDrop(event)&quot; ondrop=&quot;drop(event)&quot;&gt;将拖动的元素释放到此处&lt;/div&gt; &lt;script&gt; function drag(event) { // 设置拖动数据 event.dataTransfer.setData(&quot;text/plain&quot;, event.target.id); } function allowDrop(event) { // 必须阻止默认的拖放行为，才能实现拖放功能 event.preventDefault(); } function drop(event) { event.preventDefault(); // 获取拖动的数据 var data = event.dataTransfer.getData(&quot;text/plain&quot;); // 将拖动的元素添加到释放的区域中 event.target.appendChild(document.getElementById(data)); } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 媒体播放的 vedio 和 audio 本地储存 localStorage 和 sessionStorage 离线应用 manifest 带有缓存 manifest 的 HTML 文档（用于离线浏览）： 12345678910&lt;!DOCTYPE html&gt;&lt;html manifest=&quot;demo.appcache&quot;&gt; &lt;head&gt; &lt;title&gt;文档标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 文档内容...... &lt;/body&gt;&lt;/html&gt; 桌面通知 Notifications 通过 Web Notifications（桌面通知系统），网站可以在用户桌面弹出一条通知，无论用户是否浏览当前网页，甚至最小化了浏览器，通知均可到达用户桌面。 参考链接：https://cloud.tencent.com/developer/article/1140216 语意化标签 article、footer、header、nav、section 增强表单控件 calendar、date、time、email、url、search 地理位置 Geolocation Geolocation 接口是一个用来获取设备地理位置的可编程的对象，它可以让 Web 内容访问到设备的地理位置，这将允许网站或应用基于用户的地理位置提供定制的信息。 带有此接口的对象可以用由 Navigator 实现的属性 NavigatorGeolocation.geolocation 来获得。 多任务 webworker 全双工通信协议 websocket 历史管理 history 跨域资源共享(CORS) Access-Control-Allow-Origin 页面可见性改变事件 visibilitychange 跨窗口通信 PostMessage Form Data 对象 绘画 canvas H5 移除的元素： 纯表现的元素：basefont、big、center、font、s、strike、tt、u 对可用性产生负面影响的元素：frame、frameset、noframes 3、伪类和伪元素伪类：以冒号(:)开头，用于选择处于特定状态的元素。用在已有元素处于某种状态时为其添加对应的样式，这种状态根据用户行为而动态变化 当用户悬停在某个元素时，可以通过:hover 来描述这个元素的状态，虽然它和一般的 CSS 都可以为元素添加样式，但是它只有处于在 DOM 树无法描述的状态下才能为元素添加样式，所以叫伪类。 伪元素：以双冒号(::)开头，用于在文档中插入虚构的元素。用于创建一些不在 DOM 树中的元素，并为其添加样式 我们可以通过:before 来为一个元素之前添加一些文本，并为这些文本添加样式，虽然用户可以看见这些文本但是实在不在 DOM 文档中。 参考链接：https://juejin.cn/post/7136087057542086693 (很全) 4、HTML 语义化什么是语义化？ ​ 语义化就是文本内容的结构化，选择适合的标签，方便开发者的阅读，方便代码的维护，也能让浏览器更好解析，总结一句话也是用正确的标签做正确的事，方便代码开发维护和浏览器解析 如下图，这个页面结构中摒弃了所有 div 元素，取而代之的是HTML5 语义化标签 HTML5 语义化标签： 1&lt;header&gt; 定义文章的介绍信息：标题，logo，slogan；包裹目录部分，搜索框，一个 nav 或者任何相关的 logo； 一个页面中的个数没有限制，可以为每个内容块添加一个 header； 1&lt;nav&gt; 定义文章导航栏，链接等; nav 一般和 u、li 配合做导航栏； 1&lt;main&gt; 定义文章的主要内容 main 标签在一份文档中是唯一的，其后代元素常常包括&lt;article&gt;； 1&lt;article&gt; 定义文档中可以脱离其他部分，一份独立的内容，通常带有标题，当 article 内嵌 article 时，里外层的内容应该是相关的，比如一篇微博和它的评论； 1&lt;section&gt; 与 article 的差别在于，它是整体的一部分，或者是文章的一节，一般来说 section 也会带有标题； 1&lt;aside&gt; 侧边栏（与 article 并列存在）或者嵌入内容（在 article 内），通常认为是独立拆分出来而不受整体影响的一部分，作为主要内容的附属信息，如索引，词条列表，或者页面及站点的附属信息，如广告，作者资料介绍等 1&lt;footer&gt; 页脚，通常包含作者、版权信息或者相关链接等； 语义化的优点？ 有助于 SEO HTML语义化可以帮助搜索引擎更好地理解页面内容，从而提高页面排名，增加流量。 提高可访问性 HTML 语义化可以帮助屏幕阅读器和其他辅助技术更好地理解页面内容，从而提高可访问性。 提高可读性 提高可维护性 5、audio 常用 API 属性 属性值 注释 src url 播放的音乐的 url 地址（火狐只支持 ogg 的音乐，而 IE9 只支持 MP3 格式的音乐。chrome 貌似全支持） preload preload 预加载（在页面被加载时进行加载或者说缓冲音频），如果使用了 autoplay 的话那么该属性失效。 loop loop 循环播放 controls controls 是否显示默认控制条（控制按钮） autoplay autoplay 自动播放 audio 的属性 属性 注释 duration 获取媒体文件的总时长，以 s 为单位，如果无法获取，返回 NaN paused 如果媒体文件被暂停，那么 paused 属性返回 true，反之则返回 false ended 如果媒体文件播放完毕返回 true muted 用来获取或设置静音状态。值为 boolean volume 控制音量的属性值为 0-1;0 为音量最小，1 为音量最大 startTime 返回起始播放时间 error 返回错误代码，为 uull 的时候为正常。否则可以通过 Music.error.code 来获取具体的错误代码： 1.用户终止 2.网络错误 3.解码错误 4.URL 无效 currentTime 用来获取或控制当前播放的时间，单位为 s。 currentSrc 以字符串形式返回正在播放或已加载的文件 常用的控制用的函数： 函数 作用 load() 加载音频、视频软件 play() 加载并播放音频、视频文件或重新播放暂停的的音频、视频 pause() 暂停出于播放状态的音频、视频文件 canPlayType(obj) 测试是否支持给定的 Mini 类型的文件 事件名称 事件作用 loadstart 客户端开始请求数据 progress 客户端正在请求数据（或者说正在缓冲） play play()和 autoplay 播放时 pause pause()方法促发时 ended 当前播放结束 timeupdate 当前播放时间发生改变的时候。播放中常用的时间处理哦 canplaythrough 歌曲已经载入完全完成 canplay 缓冲至目前可播放状态。 健身去喽~","link":"/2024/03/15/1qd-2/"},{"title":"前端学习-Ant Design Vue的使用","text":"","link":"/2024/03/18/1qd-3/"},{"title":"算法知识-BFS+DFS模板","text":"BFS（广度优先遍历） 其主要思想是从起始点开始，将其邻近的所有顶点都加到一个队列（FIFO）中去，然后标记下这些顶点离起始顶点的距离为 1.最后将起始顶点标记为已访问，今后就不会再访问。然后再从队列中取出最先进队的顶点 A，也取出其周边邻近节点，加入队列末尾，将这些顶点的距离相对 A 再加 1，最后离开这个顶点 A。依次下去，直到队列为空为止。所以我们上图的遍历顺序将会为：A-&gt;C-&gt;D-&gt;B-&gt;E-&gt;F DFS（深度优先遍历） 深度优先搜索是从起始顶点开始，递归访问其所有邻近节点，比如 A 节点是其第一个邻近节点，而 C 节点又是 A 的一个邻近节点，则 DFS 访问 A 节点后再访问 C 节点，如果 C 节点有未访问的邻近节点的话将继续访问其邻近节点，否则继续访问 A 的未访问邻近节点，当所有从 A 节点出去的路径都访问完之后，继续递归访问除 A 以外未被访问的邻近节点。 所以上面我们的示意图的遍历顺序会为：A-&gt;C-&gt;B-&gt;D-&gt;E-&gt;F BFS模板1234567891011121314151617181920// 使用队列public void bfsMain(int[][] matrix){ int numNode = matrix.length; boolean[] visited = new boolean[numNode]; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for(int i=0; i&lt;numNode; i++){ if(!visited[i]){ //将没访问过的节点入队 queue.offer(i); while(!queue.isEmpty()){ v = queue.poll(); //出队判断其是否有未访问过的连接节点，有的话入队标记为以访问 for(int j=0; j&lt;numNode; j++){ if(matrix[v][j] == 1 &amp;&amp; !visited[j]){ visited[j] = true; queue.offer[j] } } } } }} 可以看看本章节的二叉树层序遍历，那个也是经典的 BFS DFS关于 dfs 参数问题，什么在变化，就把什么设置成参数。 模板12345678910111213141516171819202122232425void dfs()//参数用来表示状态{ if(到达终点状态) { ...//根据题意添加 return; } if(越界或者是不合法状态) return; if(特殊状态)//剪枝 return ; for(扩展方式) { if(扩展方式所达到状态合法) { 修改操作;//根据题意来添加 标记； dfs（）； (还原标记)； //是否还原标记根据题意 //如果加上（还原标记）就是 回溯法 } }} 题目对于 DFS 来说，其实还是靠做题的感觉 A,2,3,4,5,6,7,8,9A,2,3,4,5,6,7,8,9 共 9 张纸牌排成一个正三角形（A 按 11 计算）。要求每个边的和相等。 下图就是一种排法。 这样的排法可能会有很多。 如果考虑旋转、镜像后相同的算同一种，一共有多少种不同的排法呢？ 123456789101112131415161718192021222324252627import java.util.*;public class Main { static int[] a = {1,2,3,4,5,6,7,8,9}; static int sum = 0; public static void main(String[] args) { f(0); System.out.print(sum / 2/ 3); } public static void f(int k) {//k代表与后面元素交换的当前位置 if(k == 9) { int b = a[0] + a[1] + a[3] + a[5]; int c = a[0] + a[2] + a[4] + a[8]; int d = a[6] + a[7] + a[8] + a[5]; if (b == c &amp;&amp; c == d) sum ++; } for (int i = k; i &lt; 9; i ++) { int temp = a[k]; a[k] = a[i]; a[i] = temp; f(k + 1);//在当前位置进行全排列 temp = a[k]; a[k] = a[i]; a[i] = temp;//回溯，将后续数字进行排列，所以需要交换回来 } }}","link":"/2024/03/18/2sf-9/"},{"title":"前端学习-vue3.0父组件调用子组件里的方法","text":"这次项目开发采用了 vue3 的框架，对于之前只写过 vue2 框架的我还是有一些不适应，加上自己的基础功也没有那么牢，所以起步还是有一些问题，这不问题就来了，怎么让父组件调用子组件 以上面的 GIF 为例，我需要在导航菜单中调用登录或者是注册页面的组件，我总归不能写在一块对吧，这样不符合模块化的开发，也会让我的代码成为一坨 shit，所以回归正题，怎么实现这个功能。 1.注册组件以登录组件为例 写好组件之后，我们就需要对其进行 export，引出组件，当然 vue3 和 vue2 相比，有了很大的进步，setup 以及 TS 的写法让我们引出组件变得更简单，同样我们也可以使用 vue2 的写法，只需要将其写法进行小小的变化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137&lt;template&gt; &lt;div&gt; &lt;!-- &lt;a-button type=&quot;primary&quot; @click=&quot;showModal&quot;&gt;Open Modal&lt;/a-button&gt; --&gt; &lt;a-modal v-model:open=&quot;open&quot; title=&quot;Sign up&quot; @ok=&quot;handleOk&quot;&gt; &lt;a-form :model=&quot;formState&quot; name=&quot;normal_login&quot; class=&quot;login-form&quot; @finish=&quot;onFinish&quot; @finishFailed=&quot;onFinishFailed&quot; &gt; &lt;a-form-item label=&quot;Username&quot; name=&quot;username&quot; :rules=&quot;[{ required: true, message: 'Please input your username!' }]&quot; &gt; &lt;a-input v-model:value=&quot;formState.username&quot;&gt; &lt;template #prefix&gt; &lt;UserOutlined class=&quot;site-form-item-icon&quot; /&gt; &lt;/template&gt; &lt;/a-input&gt; &lt;/a-form-item&gt; &lt;a-form-item label=&quot;Password&quot; name=&quot;password&quot; :rules=&quot;[{ required: true, message: 'Please input your password!' }]&quot; &gt; &lt;a-input-password v-model:value=&quot;formState.password&quot;&gt; &lt;template #prefix&gt; &lt;LockOutlined class=&quot;site-form-item-icon&quot; /&gt; &lt;/template&gt; &lt;/a-input-password&gt; &lt;/a-form-item&gt; &lt;a-form-item label=&quot;Confirm Password&quot; name=&quot;ConfirmPassword&quot; :rules=&quot;[{ required: true, message: 'Please input your password!' }]&quot; &gt; &lt;a-input-password v-model:value=&quot;formState.password&quot;&gt; &lt;template #prefix&gt; &lt;LockOutlined class=&quot;site-form-item-icon&quot; /&gt; &lt;/template&gt; &lt;/a-input-password&gt; &lt;/a-form-item&gt; &lt;a-form-item label=&quot;UserMail&quot; name=&quot;UserMail&quot; :rules=&quot;[{ required: true, message: 'Please input your mail!' }]&quot; &gt; &lt;a-input v-model:value=&quot;formState.username&quot;&gt; &lt;template #prefix&gt; &lt;UserOutlined class=&quot;site-form-item-icon&quot; /&gt; &lt;/template&gt; &lt;/a-input&gt; &lt;/a-form-item&gt; &lt;a-form-item label=&quot;MailCode&quot; name=&quot;MailCode&quot; :rules=&quot;[{ required: true, message: 'Please input your mailCode!' }]&quot; &gt; &lt;a-input v-model:value=&quot;formState.username&quot; maxlength=&quot;6&quot; style=&quot;width: 80px&quot; &gt; &lt;template #prefix&gt; &lt;UserOutlined class=&quot;site-form-item-icon&quot; /&gt; &lt;/template&gt; &lt;/a-input&gt; &lt;/a-form-item&gt; &lt;!-- &lt;a-form-item&gt; &lt;a-form-item name=&quot;remember&quot; no-style&gt; &lt;a-checkbox v-model:checked=&quot;formState.remember&quot; &gt;Remember me&lt;/a-checkbox &gt; &lt;/a-form-item&gt; &lt;a class=&quot;login-form-forgot&quot; href=&quot;&quot;&gt;Forgot password&lt;/a&gt; &lt;/a-form-item&gt; --&gt; &lt;a-form-item&gt; &lt;a-button :disabled=&quot;disabled&quot; type=&quot;primary&quot; html-type=&quot;submit&quot; class=&quot;login-form-button&quot; &gt; register &lt;/a-button&gt; &lt;/a-form-item&gt; &lt;/a-form&gt; &lt;/a-modal&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import { reactive, computed } from &quot;vue&quot;;import { defineComponent, ref } from &quot;vue&quot;;export default defineComponent({ setup() { const open = ref(false); const showModal = () =&gt; { open.value = true; }; const handleOk = (e: Object) =&gt; { console.log(e); open.value = false; }; const formState = reactive({ username: &quot;&quot;, password: &quot;&quot;, remember: true, }); const onFinish = (values: Object) =&gt; { console.log(&quot;Success:&quot;, values); }; const onFinishFailed = (errorInfo: Object) =&gt; { console.log(&quot;Failed:&quot;, errorInfo); }; const disabled = computed(() =&gt; { return !(formState.username &amp;&amp; formState.password); }); return { showModal, handleOk, onFinish, onFinishFailed, disabled, formState, open, }; },});&lt;/script&gt; 利用defineComponent和set up写出我们引出的代码 2.引入组件 这里面还用了调用子组件方法的方式，让子组件发挥自己的作用 注：如果直接以定义脚本的话，那直接在里面写代码就行，然后直接就可以","link":"/2024/03/18/1qd-4/"},{"title":"前端-面经学习-JS基础","text":"JS 基础1、let，var，constlet—ES6 变量声明方式 变量在声明前会报错 let 为块作用域 let 禁止重复声明变量，否则会报错；var 可以重复声明 var—ES5 变量声明方式 在声明前直接使用不会，若没初始化的话，则会赋值为“undefined” 作用域—var 为方法作用域，只要在方法内定义了，整个方法内的定义变量的代码都可以使用，这也在一定程度上说明，var 的作用域要大于 let 的作用域 const—ES6 变量声明方式 const 作为常量声明方式，声明变量的时候必须进行初始化，在之后的代码中不能修改该常量的值 const 其实保证的并不是变量的值不得改动，而是变量指向的那个内存地址不得改动 2、JS 数据类型及区别​ JavaScript 共有 8 中数据类型，其中包含 7 中基本数据类型，以及一种引用数据类型 基本数据类型： ​ number、string、Boolean、null、undefined、symbol、bigInt 引用数据类型： ​ Object（Object、array、function） 两种数据存储的方式： ​ 基本数据类型是直接在栈中存储简单数据段，占据空间较小，大小固定，而且频繁被使用的数据。栈是存储基本类型和执行代码的空间。 ​ 引用数据类型是存储在堆内存中，占据空间大，大小不固定。引用数据类型在栈中存储了指针，在找对应的引用值时，会检索对应的在栈中的地址，取得地址后从堆中获得实体。 两种数据类型区别： 速度和空间 栈比堆运行速度快，堆比栈空间大 堆内存是无序存储，直接根据引用值获取 基本数据类型比较稳定，而且相对占用空间小 引用数据类型大小是动态且无限的 3、Object.assign 的理解作用：实现对象的合并 语法：Object.assign(target, ...sources) 理解： Object.assign 会将 source 里面的可枚举属性复制到 target，如果和 target 的已有属性重名，则会覆盖 后续的 source 会覆盖前面的 source 同名属性 Object.assign 复制的是属性值，如果属性值是一个引用类型，那么复制的其实是引用地址，就会存在引用共享的问题 12345678910const target = { a: 1, b: 2 };const source = { b: 4, c: 5 };const returnedTarget = Object.assign(target, source);console.log(target);// Expected output: Object { a: 1, b: 4, c: 5 }console.log(returnedTarget === target);// Expected output: true 4、constructor 的理解在 JS 中，每个函数对象都有名为“prototype”的属性用于引用原型对象。此原型对象又名为“constructor”属性，可以通过它反过来引用函数本身。这是一种循环引用，而函数也是对象具有__proto__属性 1234function Animal() {}var anim = new Animal();Animal.prototype.constructor === Animal; //true anim.constructor===anim.__proto_._constructor===Animal.prototype.constructor ​ 所有的函数默认情况下其 constructor 都是在 prototype 上面。所以在创建构造函数的时候经常指定构造函数为自身，这样其实例化的对象的 constructor 就指向了创建他的函数。 123456789101112function Person(name, age, sex) { this.name = name; this.age = age; this.sex = sex;}Person.prototype = { constructor: Person, //指定其构造函数为自身 sayHello: function () { console.log(&quot;hello&quot;); },}; 如果不加 constructor： 12345Person.prototype = { sayHello: function () { console.log(&quot;hello&quot;); },}; 第一级proto没了 constructor，而是在第二级，也就是 Object.prototype.constructor。如果想避免这种情况可以不直接给函数赋对象，而是一个个属性赋值： 123Person.prototype.sayHello = function () { console.log(&quot;hello&quot;);}; 这样的话 constructor 默认指向了 Person 通过字面量构造出的对象的构造函数就是 Object() 每个对象的构造函数指向构造出来他的函数，每个函数的的原型的构造器都指向它自己 5、map 和 forEach 的区别map 使用方法： 123let doubled = arr.map((num) =&gt; { return num * 2;}); forEach 使用方法： 123arr.forEach((num, index) =&gt; { return (arr[index] = num * 2);}); 相同点： 都是循环遍历数组中的每一项 每次执行匿名函数都支持三个参数，参数分别是 item（当前项）、index（索引值）、arr（原数组） 匿名函数的 this 都是指向 window 只能遍历数组 不同点： map 会分配内存空间存储新数组并返回，forEach 不会返回 forEach 允许回调更改原始数组的元素。map 返回新的数组。 6、for of 可以遍历哪些对象12for (let item of arr) {} for of 是 ES6 新增的遍历方法，但是只限于迭代器 可以迭代的对象：array、map、Set、string、typedArray、arguments 7、JS 静态类型检查静态类型语言：类型检查发生在编译阶段，因此除非修复错误，否则会一直编译失败 动态类型语言：只有在程序运行一次的时候才会被发现，即使代码中包含了组织脚本正常运行的错误类型，这段代码也可以通过编译 JS 静态检查的方法： Flow 允许你逐渐地向 JavaScript 代码中添加类型。（Flow是 Facebook 开发和发布的一个开源的静态类型检查库） TypeScript是一个会编译为 JavaScript 的超集 使用静态语言的优势 尽早发现 BUG 数据与行为分离 减少了单元测试的数量 减少了一定的错误处理 …… 使用静态语言的劣势 代码冗长 需要另外花时间学习掌握 8、indexOf格式： 1str.indexOf(search [,fromIndex]); 作用： ​ 查找 search 在 str 字符串中的索引值 参数： ​ search：被查找的字符串值。如果没提供 search 的值，那么会将 search 值变为“undefined”进行查找。 ​ fromIndex：开始查找的索引值。若 fromIndex 的值大于等于 str.length 的值，那么查询结果会直接返回-1 返回值： ​ 如果找到的话，返回第一次查找到的索引，没有找到返回-1 ​ 若被查找的 search 字符串是一个空字符串，如果 fromIndex 值为空，或者 fromIndex 值小于被查找的字符串的长度，返回值和以下的 fromIndex 值一样。如果 fromIndex 值大于等于字符串的长度，将会直接返回字符串的长度（str.length）。 特点： ​ 严格区分大小写 ​ 在使用 indexOf 检索数组的时候，用“===”去匹配，会检查数据类型 9、iframe 的优缺点优点： 能原封不动的把嵌入的网页展现出来 如果有多个网页用 iframe，那么只需要修改 iframe 的内容就能实现快速更改 若网页为了统一风格，头部和版本一样，可以用 iframe 嵌套，增加代码复用性 对于加载缓慢的第三方内容，可以用 iframe 解决 缺点： iframe 会阻塞主页面的 onload 事件 iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。会产生很多页面，不容易管理。 iframe 代码复杂，无法被一些搜索引擎索引到，现在的搜索引擎还不能很好处理 iframe 的内容，使用 iframe 会不利于 SEO（搜索引擎优化） 兼容性差 增加 HTTP 请求，对大型网站不友好 10、web Componentsweb Components 提供封装机制把 web 组件化这个东西标准化，每个框架实现的组件都统一标准地进行输入输出，推动组件的复用。 一共分为四个部门 Custom Elements ​ 提供一种方式让开发者自定义 HTML 元素，包括特定的组成、样式和行为。支持 web Components 标准的浏览器会提供一系列 API 给开发者用于创建自定义的元素，或者拓展现有元素。 HTML Imports ​ 一种在 HTML 引用其它 HTML 文档的格式 HTML templates ​ 模板 shadow DOM ​ 提供一种更好地组织页面元素的方式，避免代码间的相互影响 11、dva 的数据流流向是怎么样的 dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架。 ​ 数据的改变发生通常是通过用户交互行为或者浏览器行为（如路由跳转等）触发的，当此类行为会改变数据 的时候可以通过 dispatch 发起一个 action，如果是同步行为会直接通过 Reducers 改变 State，如果是 异步行为（副作用）会先触发 Effects 然后流向 Reducers 最终改变 State，所以在 dva 中，数据流向非 常清晰简明，并且思路基本跟开源社区保持一致。 12、变量提升​ JS 是单线程语言，按顺序执行。但是不是逐行分析和执行，而是一段一段地分析执行，会先进行编译阶段然后才是执行阶段，在编译阶段，会检测所有的变量和函数声明，所有这些函数和变量声明都被添加到 Lexical Environment 的 JS 数据结构内的内存中，所有这些变量和函数能在它们真正被声明之前使用。 说白了，虽然 JS 是顺序编译，但是跟根据代码段进行预编译，将函数和变量添加到 lexical environment 数据结构的内存中，然后就能在声明之前就对他们进行使用。 13、HashMap 和 Array 有什么区别？ 查找效率 hashmap 根据 hashcode 值算出 index，查找效率随着数组长度增加而增加 ArrayMap 使用的是二分法查找，当数组长度增加一倍时，就多进行一次判断，效率下降 扩充容量 hashmap 初始值 16 个长度，当扩容的时候，直接申请双倍的空间 ArrayMap 每次扩容的时候，如果 size 长度大于 8 的时候，申请 size*1.5 个长度，小于 4 时申请 4 个。Arraymap 申请了更少的空间，但是扩容的频率会更高。如果数据量比较大的时候，hashmap 会更合适，扩容次数少 扩容效率 hashmap 每次扩容的时候都会重新计算每个数组成员的位置，然后放到新的位置 ArrayMap 直接使用 System.arrayCopy。效率上 arraymap 优势高一些 内存消耗 ArrayMap 能够重复利用数据扩容而遗留下来的数组空间，方便下一个 Arraymap 的使用，而 hashmap 没有这个设计。由于 Arraymap 缓存了长度是 4 和 8 的时候，如果数据量较小并频繁使用 map，那 Arraymap 肯定更省内存 数据量较小，频繁使用 map：Arraymap 数据量较大：hashmap 14、hashmap 和 ObjectObjects 和 Maps 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（并且也没有其他内建的替代方式了）过去我们一直都把对象当成 Maps 使用。不过 Maps 和 Objects 有一些重要的区别，在下列情况里使用 Map 会是更好的选择： Map Object 意外的键 Map 默认情况不包含任何键。只包含显式插入的键。 一个 Object 有一个原型, 原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。注意: 虽然 ES5 开始可以用 Object.create(null)来创建一个没有原型的对象，但是这种用法不太常见。 键的类型 一个 Map 的键可以是任意值，包括函数、对象或任意基本类型。 一个 Object 的键必须是一个 String 或是Symbol。 键的顺序 Map 中的 key 是有序的。因此，当迭代的时候，一个 Map 对象以插入的顺序返回键值。 一个 Object 的键是无序的注意：自 ECMAScript 2015 规范以来，对象确实保留了字符串和 Symbol 键的创建顺序； 因此，在只有字符串键的对象上进行迭代将按插入顺序产生键。 Size Map 的键值对个数可以轻易地通过size 属性获取 Object 的键值对个数只能手动计算 迭代 Map 是 iterable 的，所以可以直接被迭代。 迭代一个 Object 需要以某种方式获取它的键然后才能迭代。 性能 在频繁增删键值对的场景下表现更好。 在频繁添加和删除键值对的场景下未作出优化。 15、JS 中 arguments 问题​ arguments 是一个类数组数据，当调用有参数的函数的时候，往这个函数传参的时候，JS 会把所传的参数存到 arguments 对象里面。 ​ Javascrip 中每个函数都会有一个 Arguments 对象实例 arguments，引用着函数的实参。它是寄生在 js 函数当中的，不能显式创建，arguments 对象只有函数开始时才可用 在有了 arguments 对象之后，可以不用预先设定形参了，可以动态通过 arguments 为函数加入参数 16、instanceOf 原理，手动实现 function isInstanceOf (child, Parent)instanceof 主要作用就是判断一个实例是否属于某种类型 123456789function isInstanceOf(l, r){ let lproto = l.prototype; let rproto = r.prototype; while(true){ if (lproto == null) return; if (lproto === rproto) return true; lproto = lproto.__proto__; }} ​ 其实 instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。 ​ 每个 JavaScript 对象均有一个隐式的 proto 原型属性，而显式的原型属性是 prototype，只有 Object.prototype.proto 属性在未修改的情况下为 null 值 123456789101112131415161718192021222324252627282930function instance_of(L, R) { //L 表示左表达式，R 表示右表达式 var O = R.prototype; L = L.__proto__; while (true) { if (L === null) return false; if (O === L) // 这里重点：当 O 严格等于 L 时，返回true return true; L = L.__proto__; }}// 开始测试var a = [];var b = {};function Foo() {}var c = new Foo();function child() {}function father() {}child.prototype = new father();var d = new child();console.log(instance_of(a, Array)); // trueconsole.log(instance_of(b, Object)); // trueconsole.log(instance_of(b, Array)); // falseconsole.log(instance_of(a, Object)); // trueconsole.log(instance_of(c, Foo)); // trueconsole.log(instance_of(d, child)); // trueconsole.log(instance_of(d, father)); // true js 的原型继承原理 17、数组去重ES6 Set 去重 不考虑兼容性，这种去重的方法代码最少。这种方法还无法去掉“{}”空对象 123function unique(arr) { return Array.from(new Set(Arr)); //[...new Set(arr)]} for 循环嵌套，splice 去重 1//NaN和{}没有去重，出现重复的null直接消失了 1234567891011function unique(arr) { for (let i = 0; i &lt; arr.length; i++) { for (let j = i + 1; j &lt; arr.length; j++) { if (arr[i] == arr[j]) { arr.splice(j, 1); j--; } } } return arr;} 利用 indexOf 去重 1//NaN、{}没有去重 建一个空数组，判断数组里面是否存过该元素，有的话就跳过，没有就 push 进去 1234567891011function unique(arr){ if (!Array.isArray(arr)){ .log(&quot;error&quot;); return; } let array = []; for (let i = 0; i &lt; arr.length; i ++){ if (array.indexOf(arr[i]) === -1) array.push(arr[i]); } return array;} sort 去重 12345678function unique(arr) { arr.sort(); let array = []; for (let i = 1; i &lt; arr.length; i++) { if (arr[i] !== arr[i - 1]) array.push(arr[i]); } return array;} includes 去重 1//{}没有去重 跟 indexOf 根绝一模一样…但是能去重 NaN 12345678function unique(arr) { arr.sort(); let array = []; for (let i = 0; i &lt; arr.length; i++) { if (!array.includes(arr[i])) array.push(arr[i]); } return array;} hasOwnProperty 去重 利用 hasOwnProperty 判断是否存在对象属性 1//所有的都去重了 12345678function unique(arr) { var obj = {}; return arr.filter(function (item, index, arr) { return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true); });} filter 去重 filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 123456function unique(arr) { return arr.filter(function (item, index, arr) { //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素 return arr.indexOf(item, 0) === index; });} 利用 Map 数据结构去重 NaN 去不掉 1234567891011121314function arrayNonRepeatfy(arr) { let map = new Map(); let array = new Array(); // 数组用于返回结果 for (let i = 0; i &lt; arr.length; i++) { if (map.has(arr[i])) { // 如果有该key值 map.set(arr[i], true); } else { map.set(arr[i], false); // 如果没有该key值 array.push(arr[i]); } } return array;} reduce+includes 去重 都可以去掉 123456function unique(arr) { return arr.reduce( (prev, cur) =&gt; (prev.includes(cur) ? prev : [...prev, cur]), [] );} 18、编码和字符集的区别​ 字符集是书写系统字母与符号的集合，而字符编码则是字符映射为一特定的字节或字节序列，是一种规则。 拓展： ​ 字符：一个字符是一个单位的字形、类字形单位或符号的基本信息。 ​ 字符集：多个字符的集合 。 ​ 字符编码：把字符集中的字节编码（映射）指定集合中的某一对象。 19、null 和 undefined 的区别，如何让一个属性变为 null​ undefined 表示一个变量自然的、最原始的状态值，而 null 表示一个变量被认为设置为空对象，而不是原始状态。当释放一个对象的时候，直接赋值为 null。 undefined 出现的四种场景： 声明一个变量，但没有赋值 访问对象上不存在的属性 函数定义了形参，但是没有传递实参 使用 void 对表达式求值 因此，undefined 一般都来自于某个表达式最原始的状态值，不是人为操作的结果。当然，你也可以手动给一个变量赋值 undefined，但这样做没有意义，因为一个变量不赋值就是 undefined 。 null 的字面意思是：空值。这个值的语义是，希望表示 一个被人为的重置为空对象，而非一个变量最原始的状态。在内存里的表示就是，栈中的变量没有指向堆中的实体 null 有属于自己的类型 Null，而不属于 Object 类型，typeof 之所以会判定为 Object 类型，是因为 JavaScript 数据类型在底层都是以二进制的形式表示的，二进制的前三位为 0 会被 typeof 判断为对象类型，而 null 的二进制位恰好都是 0 ，因此，null 被误判断为 Object 类型。 20、数组和伪数组的区别数组与常规对象区别： 新元素添加到数组中，length 值自动更新 设置 length 属性，可以截断数组 从 Array.prototype 中继承了方法 属性为 Array 类数组是拥有 length 属性，但是属性是非负整数的普通对象，类数组不能直接调用数组的方法，比如 arguments 就是有着类似的外表，但是里面啥也没有 类数组转换为数组 使用 Array.from() 使用 Array.prototype.slice.call() 使用 Array.prototype.forEach()遍历属性并组成新的数组 转换后的数组长度由 length 属性决定。索引不连续时转换结果是连续的，会自动补位。 123456789let al1 = { length: 4, 0: 0, 1: 1, 3: 3, 4: 4, 5: 5,};console.log(Array.from(al1)); // [0, 1, undefined, 3] ② 仅考虑 0 或正整数 的索引 123456789// 代码示例let al2 = { length: 4, &quot;-1&quot;: -1, 0: 0, a: &quot;a&quot;, 1: 1,};console.log(Array.from(al2)); // [0, 1, undefined, undefined] ③ 使用 slice 转换产生稀疏数组 123456789// 代码示例let al2 = { length: 4, &quot;-1&quot;: -1, 0: 0, a: &quot;a&quot;, 1: 1,};console.log(Array.prototype.slice.call(al2)); //[0, 1, empty × 2] 21、介绍 Set、Map、WeakSet、WeakMap 区别？set 成员不能重复 只有键值，没有键名，跟数组一定相似 可以遍历，方法有 add、delete、has WeakSet 成员都是对象 成员都是弱引用。随时可以消失（不计入垃圾回收机制）。可以用来保存 DOM 节点，不容易造成内存泄漏 不能遍历，方法有 add、delete、has Map 本质上是键值对的集合、类似集合 可以遍历，方法很多，可以跟各种数据格式转换 WeakMap 只接受对象为键名（null 除外），不接受其他类型为键名 键名指向的对象，不计入垃圾回收机制 不能遍历，方法有 get、Set、has、delete 22、内存泄漏的几种情况 意外的全局变量 闭包 未被清空的定时器 未被销毁的时间监听 DOM 引用 23、异步笔试题12345678910111213141516171819202122232425262728293031// 今日头条面试题async function async1() { console.log(&quot;async1 start&quot;); await async2(); console.log(&quot;async1 end&quot;);}async function async2() { console.log(&quot;async2&quot;);}console.log(&quot;script start&quot;);setTimeout(function () { console.log(&quot;settimeout&quot;);});async1();new Promise(function (resolve) { console.log(&quot;promise1&quot;); resolve();}).then(function () { console.log(&quot;promise2&quot;);});console.log(&quot;script end&quot;); 题目的本质，就是考察 setTimeout、promise、async await 的实现及执行顺序，以及 JS 的事件循环的相关问题。 答案： 12345678script startasync1 startasync2promise1script endasync1 endpromise2settimeout 整理一下流程： 1、执行 console.log(‘script start’)，输出 script start；2、执行 setTimeout，是一个异步动作，放入宏任务异步队列中；3、执行 async1()，输出 async1 start，继续向下执行；4、执行 async2()，输出 async2，并返回了一个 promise 对象，await 让出了线程，把返回的 promise 加入了微任务异步队列，所以 async1()下面的代码也要等待上面完成后继续执行;5、执行 new Promise，输出 promise1，然后将 resolve 放入微任务异步队列；6、执行 console.log(‘script end’)，输出 script end；7、到此同步的代码就都执行完成了，然后去微任务异步队列里去获取任务8、接下来执行 resolve（async2 返回的 promise 返回的），输出了 async1 end。9、然后执行 resolve（new Promise 的），输出了 promise2。10、最后执行 setTimeout，输出了 settimeout。 js EventLoop 事件循环机制:JavaScript 的事件分两种，宏任务(macro-task)和微任务(micro-task) 宏任务：包括整体代码 script，setTimeout，setInterval 微任务：Promise.then(非 new Promise)，process.nextTick(node 中) 事件的执行顺序，是先执行宏任务，然后执行微任务，这个是基础，任务可以有同步任务和异步任务，同步的进入主线程，异步的进入 Event Table 并注册函数，异步事件完成后，会将回调函数放入 Event Queue 中(宏任务和微任务是不同的 Event Queue)，同步任务执行完成后，会从 Event Queue 中读取事件放入主线程执行，回调函数中可能还会包含不同的任务，因此会循环执行上述操作。注意： setTimeOut 并不是直接的把你的回掉函数放进上述的异步队列中去，而是在定时器的时间到了之后，把回掉函数放到执行异步队列中去。如果此时这个队列已经有很多任务了，那就排在他们的后面。这也就解释了为什么 setTimeOut 为什么不能精准的执行的问题了。setTimeOut 执行需要满足两个条件： 主进程必须是空闲的状态，如果到时间了，主进程不空闲也不会执行你的回掉函数 这个回掉函数需要等到插入异步队列时前面的异步函数都执行完了，才会执行 上面是比较官方的解释，说一下自己的理解吧： ​ 了解了什么是宏任务和微任务，就好理解多了，首先执行 宏任务 =&gt; 微任务的 Event Queue =&gt; 宏任务的 Event Queue promise、async/await首先，new Promise 是同步的任务，会被放到主进程中去立即执行。而.then()函数是异步任务会放到异步队列中去，那什么时候放到异步队列中去呢？当你的 promise 状态结束的时候，就会立即放进异步队列中去了。 ​ 带 async 关键字的函数会返回一个 promise 对象，如果里面没有 await，执行起来等同于普通函数； ​ await 关键字要在 async 关键字函数的内部，await 写在外面会报错；await 如同他的语意，就是在等待，等待右侧的表达式完成。此时的 await 会让出线程，阻塞 async 内后续的代码，先去执行 async 外的代码。等外面的同步代码执行完毕，才会执行里面的后续代码。就算 await 的不是 promise 对象，是一个同步函数，也会等这样操作 24、JSON 和 xml 数据的区别 数据体积：xml 是重量级的，json 是轻量级的，json 的传递速度更快些 数据传输：xml 在传输过程中比较占带宽，json 占带宽少，易于压缩 数据交互：json 与 js 交互方便，易于解析，更好进行数据交互 数据描述：json 数据描述较差 在项目交互下，xml 多用于配置文件，json 用于数据交互 25、JS 判断变量的类型有几种？ typeOf：当需要判断变量是否是 number, string, boolean, function, undefined 等类型时，可以使用 typeof 进行判断 instanceOf：instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。 constructor：检测 constructor 本来是原型对象上的属性，指向构造函数。但是根据实例对象寻找属性的顺序，若实例对象上没有实例属性或方法时，就去原型链上寻找，因此，实例对象也是能使用 constructor 属性的。 26、max 与 min1234var min = Math.min();max = Math.max();console.log(min &lt; max);// 写出执行结果，并解释原因 答案false 解析 按常规的思路，这段代码应该输出 true，毕竟最小值小于最大值。但是却输出 false MDN 相关文档是这样解释的 Math.min 的参数是 0 个或者多个，如果多个参数很容易理解，返回参数中最小的。如果没有参数，则返回 Infinity，无穷大。 而 Math.max 没有传递参数时返回的是-Infinity.所以输出 false 27、代码解析题（delete）1234567var company = { address: &quot;beijing&quot;,};var yideng = Object.create(company);delete yideng.address;console.log(yideng.address);// 写出执行结果，并解释原因 答案beijing 解析这里的 yideng 通过 prototype 继承了 company 的 address。yideng 自己并没有 address 属性。所以 delete 操作符的作用是无效的。 delete 使用原则：delete 操作符用来删除一个对象的属性。 delete 不能删除的：（2）显式声明的全局变量 （2）内置对象的内置属性 （3）一个对象从原型继承而来的属性 delete 能删除的：（1）可配置对象的属性（2）隐式声明的全局变量 （3）用户定义的属性 （4）在 ECMAScript 6 中，通过 const 或 let 声明指定的 “temporal dead zone” (TDZ) 对 delete 操作符也会起作用 delete 删除数组元素：（1）当你删除一个数组元素时，数组的 length 属性并不会变小，数组元素变成 undefined（2）当用 delete 操作符删除一个数组元素时，被删除的元素已经完全不属于该数组。（3）如果你想让一个数组元素的值变为 undefined 而不是删除它，可以使用 undefined 给其赋值而不是使用 delete 操作符。此时数组元素是在数组中的delete 操作符与直接释放内存（只能通过解除引用来间接释放）没有关系。","link":"/2024/03/21/1qd-5/"},{"title":"生活随记-3月21日","text":"0b2f4e5d6eec5d3dd7df5050da23c5c48069d06e8251935a3460c26e532f4749efb7ed23fc4afa0ba84634f87b70c9c8fe3ade9cae752a2f61fe30b514043f74f22883b5ad3a3a3b66249d1e1bf9eadbe8a6be7bda18c34fd01e7554a0c10e290a860f5dd5ac663acc7e316457c40ade68eea07e8be8bd1b4b657e2fe297ea3992ca157207846d7005c46899f42d8c0c956c226850ac8ea682f7b6a97867770284b126b3a565af558b3de1e18e822d175025931bb4fcda0aed376c2f51e4b14e05a082720381f3ada0b04c7f1d08b95f544c3f822aa4a1daa9c99a2e57d860a85c9ff0fb95a3203ee00c42bfb6a1ff459675a25f4031f3746ba5f0e6683f8e4b01302a5c8b0025775ab8ec93cb90dcf03cbebe82502f405bf77fc052fca8fdf94a077a80b17956bff18f0d6e39f1c0059bc07d93f191829cedeb3c4b90307ec071cc3b7bafd2579ba4c91a5f2a4ef9c6568949ef82b0f9f42d76d96b53e0c755a287f08b960ed461ce0ab2ccf8368df5eaf169f3bc70558b483867708daea9c9664fefdb24aef77f31b274f3eb9a69138e9bd606d73dede44ba1de2696c9f1404b7709b7dc4d1ccbde5f24987481d28c0bd8613ee62ed8a82f454e8b653a8b9c9b877c7070799c0dfc2095cafe90175214bceee416cf879b498b9859f4ad4d6257ac40dde2202c31cf559ee2f2cfb235118d08d43d24d56040005b6a946e79aeeeeb3e2d00540462347fa550cf2bf63974c018d6f54a93379177143ab25ab3c86c70512b8c16f6245ebec511c24003b42d6cf2d3bf0aa951a06e955ab2c4505c3de40ded60a576fdaa3b74fd9b138c9de4aff9cc89d689d7ee931f70872020e350f05018d2b5bc30e2284af65f02c5f58486b64009eddec9aaa737ef7cce27af26ee41614408de0eba32a7a8c7b5a708b9e82de5257519e05fd639770dad9099b4d07abda355ddbf632ce4d4160ddbbe1a6da31ff609274bfa31203bcf453b5941aa8cbfbea138f378d767a9e0726b51d89f014910d40189edf9d915e14d734218e6c1df3b2abd06b2ddafedeeacd3ef8904d37ad1600a550a1a54a73f8b139fd0254e7d479df24a2cf85eb83c21644ef815ff3137aa1724de0bc1f4677fe5593b79fb129e7088e022fa7af89444965b4c3972ceeea5e4f112113910b052bb2e68079048721fa1b39c899f3e2052843a93ba1eb0d112da5198191ca64f66bc334e514c913988dcf584b5671ec479c101664d7486f44bf086b8c209e328353115425032a882cc41141dbb1f16861e437bc5a7b0a3804edd4de50b7bc8d5aa040129352d8cd699667c279f3b65eb7a2275fb8745e73531bf6c1a5a9814f0c0d951759debfbb6c1155e591c77fcbe26025340f42e237040b241d6975c8173bc56248c22ffb35fe9525f374263934da8959db104b2dd273f9efc244cb85fb31e51472052ff9ff6d6ac197ab5d69171c7dab3bf687306371b708ed266d3d0adb4ed1d2ee596370745aecc0932496abd4c22a66fb6e552b146ef30b366144b1e9161e797904e7c85d6899b2c9124f1e82caed6e18a989821dc9de6c8e99d056f5f2126ecf75f556e8f20ca9923924ee7b0e37f75c9342889612da0d44ccd47a4cfdadd9f08f60d1f8bc05d0ef1b47c0098c5a02b3b3491d0d21327a3199002888a21836b0d5a33d3a0ae5dcccc1d46c35f98931f560efef6662c882d71f91e83e5aa94d0922d3ea463c702678dd544ea0636e8edc62246b2a61106b50190001f258ec838071d61827fb69c88c6d49eb4411429 请输入密码","link":"/2024/03/21/4sh-6/"},{"title":"算法知识-背包模板","text":"01 背包问题​ 一共有 N 件物品，第 i（i 从 1 开始）件物品的重量为 w[i]，价值为 v[i]。在总重量不超过背包承载上限 W 的情况下，能够装入背包的最大价值是多少？ 思路： 动规四部曲： 确定 dp 数组及其下标的含义 dp[i][j] 表示从下标为 [0 - i] 的物品里任意取，放进容量为 j 的背包，价值总和最大是多少。 确定递推公式 不放物品 i：由 dp[i - 1][j]推出，即背包容量为 j，里面不放物品 i 的最大价值，此时 dp[i][j]就是 dp[i - 1][j]。(其实就是当物品 i 的重量大于背包 j 的重量时，物品 i 无法放进背包中，所以被背包内的价值依然和前面相同。) 放物品 i：由 dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i] 为背包容量为 j - weight[i]的时候不放物品 i 的最大价值，那么 dp[i - 1][j - weight[i]] + value[i] （物品 i 的价值），就是背包放物品 i 得到的最大价值 递推公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1]j - weight[i]] + value[i]); dp 数组的初始化 首先从 dp[i][j]的定义出发，如果背包容量 j 为 0 的话，即 dp[i][0]，无论是选取哪些物品，背包价值总和一定为 0 状态转移方程 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出 i 是由 i-1 推导出来，那么 i 为 0 的时候就一定要初始化 dp[0][j]：存放编号 0 的物品的时候，各个容量的背包所能存放的最大重量 j。那么很明显当 j &lt; weight[0]时，dp[0][j] 应该是 0（背包容量比编号 0 的物品重量还小）同理，当 j &gt;= weight[0]时，dp[0][j] 应该是 value[0]（背包容量足够放编号 0 物品 确定遍历顺序 先遍历物品还是先遍历背包都是可以的，且第二层 for 循环是从小到大遍历 模板二维数组： 123456789101112131415161718192021222324252627282930313233import java.io.*;public class 零一背包模板 { public static void main(String[] args) throws IOException{ BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); String[] bounds = in.readLine().split(&quot; &quot;); int n = Integer.valueOf(bounds[0]);//物品数量 int maxWeight = Integer.valueOf(bounds[1]);//最大重量 String[] values = in.readLine().split(&quot; &quot;);//物品价值 String[] weights = in.readLine().split(&quot; &quot;);//物品重量 int[][] dp = new int[n + 1][maxWeight + 1]; int initValue = Integer.valueOf(values[0]); int initWeight = Integer.valueOf(weights[0]); //二维数组初始化 for (int i = 0; i &lt;= maxWeight; i ++){ if (initWeight &lt;= i){ dp[0][i] = initValue; } } //动态规划 for (int i = 1; i &lt; n; i ++){ for (int j = 1; j &lt;= maxWeight; j ++){ if (j &lt; Integer.valueOf(weights[i])){ dp[i][j] = dp[i - 1][j];//不放物品 } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - Integer.valueOf(weights[i])] + Integer.valueOf(values[i])); } } } System.out.println(dp[n - 1][maxWeight]);//输出不高于最大重量的最大价值 }} 一维数组： 123456789101112131415161718192021import java.io.*;public class 零一背包模板 { public static void main(String[] args) throws IOException{ BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); String[] bounds = in.readLine().split(&quot; &quot;); int n = Integer.valueOf(bounds[0]);//物品数量 int maxWeight = Integer.valueOf(bounds[1]);//最大重量 String[] values = in.readLine().split(&quot; &quot;);//物品价值 String[] weights = in.readLine().split(&quot; &quot;);//物品重量 int[] dp = new int[maxWeight + 1]; for (int i = 0; i &lt; n; i ++){ for (int j = maxWeight; j &gt;= Integer.valueOf(weights[i]); j --){ dp[j] = dp[j - Integer.valueOf(weights[i])] + Integer.valueOf(values[i]); } } System.out.println(dp[maxWeight]); }} 从大到小遍历的原因：倒序遍历是为了保证物品 i 只被放入一次！但如果一旦正序遍历了，那么物品 0 就会被重复加入多次！ 这么看还是一维数组简单写一些，只不过需要注意数组遍历方向问题~ 完全背包有 N 件物品和一个最多能背重量为 W 的背包。第 i 件物品的重量是 weight[i]，得到的价值是 value[i]。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。完全背包和 01 背包问题唯一不同的地方就是，每种物品有无限件。 模板我们知道 01 背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即： 1234567891011121314151617181920import java.io.*;public class 完全背包模板 { public static void main(String[] args) throws IOException{ BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); String[] bounds = in.readLine().split(&quot; &quot;); int n = Integer.valueOf(bounds[0]); int maxWeight = Integer.valueOf(bounds[1]); String[] values = in.readLine().split(&quot; &quot;); String[] weights = in.readLine().split(&quot; &quot;); int[] dp = new int[maxWeight + 1]; for (int i = 0; i &lt; n; i ++){ for (int j = Integer.valueOf(weights[i]); j &lt;= maxWeight; j ++){ dp[j] = Math.max(dp[j], dp[j - Integer.valueOf(weights[i])] + Integer.valueOf(values[i])); } } System.out.println(dp[maxWeight]); }} 纯完全背包的一维 dp 数组实现，先遍历物品还是先遍历背包都是可以的，且第二层 for 循环是从小到大遍历（因为这样才能实现覆盖和物品无限数量） 多重背包背包最大重量为 10，物品为： 请问背包能背的物品最大价值为多少？ ​ 直接转换成下面的情况！ 这样就变成 01 背包了，代码实现逻辑一样，就不写模板了","link":"/2024/03/21/2sf-10/"},{"title":"生活随记-3月26日","text":"0b2f4e5d6eec5d3dd7df5050da23c5c49779dc0cc5df3cb1964bd32566c501f9db779d65613d5419ad869aff31bc4244fac3a68ad0b4b93c9076861feca1f3c9f61ffe469d3683c8d20713c42220c9b471b9c76d13f844f1f768983e9775a31e62ea41e298914c2b0ee764a9968ce645a5e930593b048456a9746ce6ec1e30be707aef97b590077dfa9e7b6f5ef4c6e4b4eeab67482786a93124bc6fdfbf2f16378cdb05e0bd30dad1a6b69ff0e07ec288af291143edbb4bda86f3cf01da1007255ab3fb2fe042fdce1409854cad5e9d3aacf3a92a7f73f955a2e1052745fe5e419e217713d9bc1f319f883fb3d3343615353840d4123f522900e55b69d575e2a1ec20ef3efea2da0bff585ac268136bef8303755fc712b660f2132df19c7942d00756fb922f656bc769c144808cb4ba07e3a1faf7539affb3bdcbf3f228090555fce0e7b375208c710f5d8802d032e5eda5359dd57ea26c6b98f21bbac403cab5f95938d33e952942687bc7a56e2864a6647f6e3ee8cee2b763eefe40b130a9e92c0c5903f5a84897d3cf0cf02371605e939323066983117fb8f485bdec8f31e7a19101e36e4d1726cb4a4f612f953058b159d7041cd79595cbf512b00ce45aeb323fa5a1b0891d32ff24b43b40b670c6efaf00c0b8d67f4d54c2f427609038c1b645f8cfc8cedd5e7e8e752069fb4fa67e98640e5136b61e4feff07d0c2fee8d5d88a22da60c89908964f10ba9605561918e2aba3c9bf06852bee92600945240d09c0a58d443042a7d55c6c8cb1db9368cafea718f2047299bda4d9ec5a0440bdc99071698e03d32df4c13cdeda50bb89e3e0671958efb0340fb73db8ff4300b41f0a388b8f70cf6e9933f1a9d7592191f0bd404168d495581884f7b87460c12b10628b5f33529be7c2fe9f093b4e267287137eb0ed45e8d11503826b293bdfe7b637b7969de5bbf496852c460dd23608f253a0964bda8e2ac43e88097edba892b1bfec73a2212c09a2edd03c75e1d764eea56ffe748139b6b1b63cd45574927e05e00a54f18696d1530fb9121fefca85c6955ac7feba944c0f9d79ebdebc0977b9d5106512698c3877a4ae5361057993bcaf1ab08fa95add7050f1de33a3c272674f546bb9913fd90c56f8de4710b5e55b1b7fe970341e56ff2142f1cb6a7a7b18d56d06a226da74a211d104d09b45731d0c5a7833e20f13aa821dcdab73fd76e70e2443d1e08d49aef6417479cd6e8fa346eef56d5375292fa65b4bd21c0bbc22fc0f4b4d05eb71c26a40517913074ebb3f2eb0a82e051b081e71463347384601016cfdebcdf2402ce4bab29a24f14ade73bcd5fcbec5e11c163be71a79aaa81bc6a808666e211ecebbef2a1e6ddd9bf7d0f160e39be2df649046f1c2af06b82134fb6dc6cd856933a7424e179f696009707b14464a0c497b80493df89c3ecc606232d70b7baa540a1b202ec00cf2e7dbb1f9288740605d5ab2e58cfe05683f616b3f3f9bf50b1402adbf66aa6db86ad1a6c97f417c3433a62c656b80ca8f6a897a249116d1f1ee0091dd141fb4e8697a83cb13d57b3a05bb12277729891e5953cf4b5f09a4077f89302ff1643b60debcf1622905bf9989ab2e817b3b3989889dce51624b15e0961badbcd2550a69b82acc9ab0928d4dfdb93cf5a6bb7aef123933f28b17a8acf92e47c7606ca9cacaa236ad4034b774cad7333c78213dbd684016a2465c2b48567c27cf7e9db945d851f03182f2ab63a5bff856f32cf9ebb3a5c5abbd861b728d4683ba0aaf411cfee394ceb2ae8076ffe5980550a5384295e9edb6f144be9cd1c781af6a9f980fa202f395c1c344c405ed1f055353bf852da18292f17ee34b482fdad8d65a8463301ebdc30c519971dc6e529d338ce52c5246b7f73f0b7673ef2effa726c3496e0709d2afeacb73a24df2de57b893f6da2da76e44127b8c14f4aefdbcb28152e739776303d6764d08f6f639e5d2402cf0352ad5ef89991f9666fd7c840e5828a8c91d8256e1c238ab0efaa8f76a1ad61adcc204d0a4d340d29988028ee7e6470b4fd98094dd41281b60c30b83cca90ce774b4d9c42a1bb390cef430f7af68ff213f247bc4dc339fd4abb933ec8c48d967b21995f7b6371e0c9eb0c653f64625f4c911e0798aa0176f7449c448faff705c8d1466f343ab6fade0d3bb75fdef88c1b0f6ae32bf7576aef7eb06ac549b990c05b9865f98b28eba42dc55ed17d7d8375d423a32d0250484cc090eb0db33164d9881c635ad3cc464cb7ea82ce23c9984334ad22abd6b9647a8e92f9871bd7ad7717c2e81b70f9353b6211afef2f4c60df886fe14d43ebcfd8ecb3fdd24356b4b462c8858b19bec7e279b7c31a4e7203275335b91d29a14b832366e17e0c35759a2dbc85e3ffff6c76c31ac705e93f61bbe7437d1d1690adf8d71c04848f20f7bda66d30d050ad8036a87b2ebe954881af265a7a705522c5fefe9d98425a91a2672b4cdf501b9ea5a346cea6853563fe594fc4b0bd2ec652be19ae9bee9834bd608cbe6d630dd6ba1ff66123b5991468eb7be5c77cde5c6540ae934b3eed37399c31ee78c4a12792e0fd9d05f6d91a13e5aba1a9047a756eacf9c8f41e60726caa0f7d3a56090929e8270ab16fe8f2b17cabcb793fda0b35e01a423cbe8ea80d80848c571bcfb47b6c6625fd444b7918cc6139ad016b3dd84be1bf5a78cb66bff6777604f7d3eab68630241573ec9c34eeb897ccea797b01e75614b65afe19ff328079d2f23e9ae9763e3697a3d4589ed67a981da6e8512a8eac8fcc7753cfca0f2fc833823ed0eba6d0d142a878d3d98709f2ed6ad78339e2a00294b8d7eefb3544bf68409c8c59ece2f939faa78f9da9a751b6ade30f3628fd28c88c3b3db43f240bfceea49b9be23fbc3ce89660710023f01ea0f24f6584ce1dc386d08af136ac963a6e70935d04696a4977623b8f91b4186dcd17165b814abab1f1d3003f3c00db5dfb6de7971c890024c2754f050c63ac090f33989ae3cffdec397d336d47ed0e827c80dbc59d603a4a99be9606d7e694c69caf44fb083e0666b71e2e82300b385e063bffd77037c048825741b40d558d78cba83f90c166e9a7467ad19473d53b35d8dab0abb4229d64e0d3e737fcfa697477dac3a1c19432dd6d726173e519d3800a3ec506806fe270ecb8929e7f803823176c226469e42e3a855090e4b22ef99986558b62258151e975e25895c105b143eaa6584ae6f37360ffc046fc317e0b8deb639a3dedc0602d513ff51fe40b6b110d197887263d598de4fd4dfda033614268519f34d1bb2f5d88888f1fd28beecdc233d696cf036366393f62ccb089e1b6db831fe35b1e31b211d70db64152c0b65740625e08aac5daf37580b3272716e8ba76eb797f17d53c64ac8020658f607928f834465f8a217a5de1bb8e7c23a3c8aab50ea8bd0b52b7ada22ed049340e83b5af513b9883c81c615ec0092649b3863467fd0bf17418a142eda91e 请输入密码","link":"/2024/03/26/4sh-7/"},{"title":"前段学习-v-for没有对已经修改的数据进行渲染？","text":"今天耗费了我很多精力去找权限的逻辑信息，当我把逻辑信息修改正确时候，并且已经把正确的数组打印出来了，按理说此时显示的应该是正确的数组信息，但是数组渲染结果就是不发生变化，原因竟然是没有加:key这个标签，:key在循环中到底产生了什么作用？ 先简单说下实战中遇到的问题，我通过 pinia 去存储全局状态，然后又通过 storeRefs()和 computed 去实现响应式操作，当我把这些工作做完之后，我发现能将正确的数组打印出来但是不能渲染出来，当我把:key标签加在对应的位置后，功能全部正常 那么咱们就研究研究:key到底起到了什么样的作用？ key 是虚拟 DOM 对象的标识，当数据发生变化时，Vue 会根据【新数据】生成【新的虚拟 DOM】, 随后 Vue 进行【新虚拟 DOM】与【旧虚拟 DOM】的差异比较 对比规则： (1).旧虚拟 DOM 中找到了与新虚拟 DOM 相同的 key： ​ ①.若虚拟 DOM 中内容没变, 直接使用之前的真实 DOM！ ​ ②.若虚拟 DOM 中内容变了, 则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM。 (2).旧虚拟 DOM 中未找到与新虚拟 DOM 相同的 key 创建新的真实 DOM，随后渲染到到页面。 所以在我们进行重新渲染的时候，我们没有通过可以去进行数据比对，当数据发生变化的时候，不能对 DOM 进行操作，进而没有效果的渲染 那么在开发中如何选择 key?: 1.最好使用每条数据的唯一标识作为 key, 比如 id、手机号、身份证号、学号等唯一值。 2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用 index 作为 key 是没有问题的。","link":"/2024/03/27/1qd-6/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"three.js","slug":"three-js","link":"/tags/three-js/"},{"name":"生活小记","slug":"生活小记","link":"/tags/%E7%94%9F%E6%B4%BB%E5%B0%8F%E8%AE%B0/"},{"name":"模板","slug":"模板","link":"/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"面经","slug":"面经","link":"/tags/%E9%9D%A2%E7%BB%8F/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"背包算法","slug":"背包算法","link":"/tags/%E8%83%8C%E5%8C%85%E7%AE%97%E6%B3%95/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"实战","slug":"实战","link":"/tags/%E5%AE%9E%E6%88%98/"}],"categories":[{"name":"效果实现","slug":"效果实现","link":"/categories/%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"three.js","slug":"three-js","link":"/categories/three-js/"},{"name":"生活小记","slug":"生活小记","link":"/categories/%E7%94%9F%E6%B4%BB%E5%B0%8F%E8%AE%B0/"},{"name":"面经","slug":"面经","link":"/categories/%E9%9D%A2%E7%BB%8F/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"}],"pages":[]}