{"posts":[{"title":"第一篇博客当然是HELLO WORLD","text":"","link":"/2024/02/15/hello-world/"},{"title":"歌词滚动效果的实现","text":"话不多说，先看效果图： 歌词随着时间进行变化，那这种效果我们应该怎么去做呢？实现的思路又是怎样的呢？ 1.先找需要的材料我把材料发放在了网盘里，大家通过链接获取，里面有对应的 mp3 文件及数据 链接：https://pan.baidu.com/s/1RdDty0ctUl3k-7o-43-0nw?pwd=388p提取码：388p 2，对得到的资料进行分析，进行数据处理 这个是我们获取到的数据，由于我是在 vue2 项目里面做的，所以我用了 export 将需要的数据引出，然后在对应的页面进行处理 那么问题来了：我们需要的数据是什么？什么样的数据我们才能让歌词与时间联系起来？ answer：其实就是歌词对应在 MP3 文件中对应的播放时间，所以我们需要获取对应歌曲每句歌词所对应的时间 接下来，我们在对应的文件中引入我们歌曲数据 1import lrcSong from &quot;../assets/js/song&quot;; 然后对取到的数据进行处理：将取到的歌词数据变成对象数组 对于取到的数据，我们只需要 lyric 部分，这部分是每句歌词对应的时间的字符串 由于我们取到的数据是字符串形式的，所以需要对字符串进行拆分，理由很简单，我们最后需要的数据是字符数组的形式 所以parseLrc(lrcSong)函数是对取到的数据变换成对象数组的函数，其中调用了parseTime函数，这个函数是我们用来将字符串的时间转换成秒数的格式， 1234567891011121314151617181920212223parseLrc(lrcSong) { let songdata = lrcSong.parseLrc(lrcSong) { let songdata = lrcSong.lyric; let songArr = songdata.split(&quot;\\n&quot;); let result = []; for (var i = 0; i &lt; songArr.length; i++) { // console.log(songArr[i]); let str = songArr[i]; var parts = str.split(&quot;]&quot;); let timeStr = parts[0].substring(1); let obj = { time: this.parseTime(timeStr), words: parts[1] }; result.push(obj); } this.song = result; //我们最后需要的数组对象，如果用纯js的话，那就直接return就行，最后找个变量接收 }, // 处理时间问题 parseTime(time) { let resultArr = time.split(&quot;:&quot;); return +resultArr[0] * 60 + +resultArr[1]; }, 通过这两个函数对数据的处理，我们最后得到了一个对象数组，打印出来是这样的： 3.联系 dom 元素，将歌词填充到 dom 元素里面HTML 的代码 12345678910&lt;div&gt; &lt;!-- 这种做法不能播放 --&gt; &lt;!-- &lt;audio src=&quot;../assets/1480251493.mp3&quot; controls&gt;&lt;/audio&gt; --&gt; &lt;audio controls&gt; &lt;source src=&quot;../assets/1480251493.mp3&quot; /&gt; &lt;/audio&gt; &lt;div class=&quot;container&quot;&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 注：先开始写的时间第一中 audio 的写法不能播放，第二种写法就可以，实战的时候需要注意一下 我们将处理好的数据放入到对应的 dom 元素里面 所以我们先获取 dom 元素 12345678getDom() { let tempdom = { audio: document.querySelector(&quot;audio&quot;), ul: document.querySelector(&quot;.container ul&quot;), container: document.querySelector(&quot;.container&quot;) }; this.doms = tempdom;//如果用纯js的话，那就直接return就行，最后找个变量接收 }, 这样的话，我们就获取到了我们的 dom 元素，下一步就是将歌词填充到对应的 ul 标签 12345678910111213// 创建歌词元素 createLi() { // 为了提高效率，采用文档片段，因为这种做法不涉及reflow，对浏览器渲染主线程不影响 let temp = document.createDocumentFragment(); let data = this.song; for (var i = 0; i &lt; data.length; i++) { let li = document.createElement(&quot;li&quot;); li.textContent = data[i].words; console.log(data[i].words); temp.appendChild(li); } this.doms.ul.appendChild(temp); }, 通过这种方法我们就将歌词填充到了 ul 标签中这样我们就可以看到 ul 里面 li 了 样式代码： 1234567891011121314151617181920212223242526* { margin: 0; padding: 0;}body { background-color: #000000; color: #666; text-align: center;}audio { width: 420px; margin: 30px 0;}.container { overflow: hidden; height: 420px;}.container ul { transition: 0.8s; list-style: none;}.container li { height: 30px; line-height: 30px; transition: 0.2s;} 现在我们将歌词放入到 ul 标签了，最后一步也就是最重要的，我们如何与 mp3 文件进行联系，形成滚动效果呢？ 4.将歌词与时间联系起来首先我们需要完成一个工作，就是需要知道什么时间到了哪句歌词 1234567891011// 看歌词到了那个位置 findindex() { let data = this.song; let currentTime = this.doms.audio.currentTime; for (var i = 0; i &lt; data.length; i++) { if (currentTime &lt; data[i].time) { return i - 1; } } return data.length - 1; }, 让 audio 当前播放时间与处理好的数据进行对比，获取对应的 index，这样我们就知道当前唱到了第几局句歌词 我们获取到了第几句歌词之后，我们就对歌词进行样式渲染了，就实现我们想要的滚动效果了 在实现这个之间，我们需要思考一个问题，滚动的效果是怎么实现的呢？ 看这张图，我们可以知道，其实就是 ul 标签的滚动，container 位置不进行变化，让 ul 标签向上移动，使得两个元素产生相对移动，形成这种滚动的效果，所以我们对于偏移值的把握是十分重要的 1234567891011121314151617181920212223setOffsetAndliStyle() { let containerHeight = this.doms.container.clientHeight; let liheight = this.doms.ul.children[0].clientHeight; let index = this.findindex(); let maxOffset = this.doms.ul.clientHeight - containerHeight; let offset = liheight * index + liheight / 2 - containerHeight / 2; if (offset &lt; 0) { offset = 0; } if (offset &gt; maxOffset) { offset = maxOffset; } let li = this.doms.ul.querySelector(&quot;.active&quot;); if (li) { li.classList.remove(&quot;active&quot;); } li = this.doms.ul.children[index]; if (li) { li.classList.add(&quot;active&quot;); } console.log(offset); this.doms.ul.style.transform = `translateY(-${offset}px)`; }, 当我们实现 ul 移动的时候，移动的多少是一个问题，还要考虑对应的临界值 偏移值的计算： 蓝线就是代表当前高亮显示的标签到 ul 元素顶部的距离 1liheight * index + liheight / 2 棕线就是代表container 元素的一半 这样我们就可以计算出偏移值了 1let offset = liheight * index + liheight / 2 - containerHeight / 2; 但现在还没有结束，我们还需要对偏移值判断 123456if (offset &lt; 0) { offset = 0;}if (offset &gt; maxOffset) { offset = maxOffset;} 这里面的 maxOffset 是最大的偏移值，代表到了最后一句歌词的位置不能上移了，凭个人喜好，加不加都可 那么我们就差最后一步对li 标签的渲染了 12345678let li = this.doms.ul.querySelector(&quot;.active&quot;);if (li) { li.classList.remove(&quot;active&quot;);}li = this.doms.ul.children[index];if (li) { li.classList.add(&quot;active&quot;);} active 样式 1234.container li.active { color: #fff; transform: scale(1.4);} 这样我们就做好歌词的滚动效果了！下面是我的源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152&lt;template&gt; &lt;div&gt; &lt;!-- &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; --&gt; &lt;!-- 这种做法不能播放 --&gt; &lt;!-- &lt;audio src=&quot;../assets/1480251493.mp3&quot; controls&gt;&lt;/audio&gt; --&gt; &lt;audio controls&gt; &lt;source src=&quot;../assets/1480251493.mp3&quot; /&gt; &lt;/audio&gt; &lt;div class=&quot;container&quot;&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import lrcSong from &quot;../assets/js/song&quot;;export default { name: &quot;HelloWorld&quot;, data() { return { song: [], doms: {}, currentIndex: -1, }; }, mounted() { this.parseLrc(lrcSong); this.getDom(); this.createLi(); this.audioStart(); }, methods: { parseLrc(lrcSong) { let songdata = lrcSong.lyric; let songArr = songdata.split(&quot;\\n&quot;); let result = []; for (var i = 0; i &lt; songArr.length; i++) { // console.log(songArr[i]); let str = songArr[i]; var parts = str.split(&quot;]&quot;); let timeStr = parts[0].substring(1); let obj = { time: this.parseTime(timeStr), words: parts[1], }; result.push(obj); } this.song = result; console.log(this.song); }, // 处理时间问题 parseTime(time) { let resultArr = time.split(&quot;:&quot;); return +resultArr[0] * 60 + +resultArr[1]; }, // 获取dom getDom() { let tempdom = { audio: document.querySelector(&quot;audio&quot;), ul: document.querySelector(&quot;.container ul&quot;), container: document.querySelector(&quot;.container&quot;), }; this.doms = tempdom; }, // 创建歌词元素 createLi() { // 为了提高效率，采用文档片段，因为这种做法不涉及reflow，对浏览器渲染主线程不影响 let temp = document.createDocumentFragment(); let data = this.song; for (var i = 0; i &lt; data.length; i++) { let li = document.createElement(&quot;li&quot;); li.textContent = data[i].words; console.log(data[i].words); temp.appendChild(li); } this.doms.ul.appendChild(temp); }, // 看歌词到了那个位置 findindex() { let data = this.song; let currentTime = this.doms.audio.currentTime; for (var i = 0; i &lt; data.length; i++) { if (currentTime &lt; data[i].time) { return i - 1; } } return data.length - 1; }, setOffsetAndliStyle() { let containerHeight = this.doms.container.clientHeight; let liheight = this.doms.ul.children[0].clientHeight; let index = this.findindex(); let maxOffset = this.doms.ul.clientHeight - containerHeight; let offset = liheight * index + liheight / 2 - containerHeight / 2; if (offset &lt; 0) { offset = 0; } if (offset &gt; maxOffset) { offset = maxOffset; } let li = this.doms.ul.querySelector(&quot;.active&quot;); if (li) { li.classList.remove(&quot;active&quot;); } li = this.doms.ul.children[index]; if (li) { li.classList.add(&quot;active&quot;); } console.log(offset); this.doms.ul.style.transform = `translateY(-${offset}px)`; }, audioStart() { this.doms.audio.addEventListener(&quot;timeupdate&quot;, this.setOffsetAndliStyle); }, },};&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style&gt;* { margin: 0; padding: 0;}body { background-color: #000000; color: #666; text-align: center;}audio { width: 420px; margin: 30px 0;}.container { overflow: hidden; height: 420px; /* border: 2px solid #fff; */}.container ul { transition: 0.8s; list-style: none;}.container li { height: 30px; line-height: 30px; transition: 0.2s;}.container li.active { color: #fff; transform: scale(1.4);}&lt;/style&gt; 这个 demo 是结合 vue2 做的，如果用纯 js 做的同学简单改一下变量就可以，里面的方法思路都是适用的~","link":"/2024/02/21/1-gd/"},{"title":"算法知识1-时空复杂度","text":"时间复杂度时间复杂度就是用来方便开发者估算出程序的运行时间，（这里我们默认 CPU 的每个单元运行消耗的时间都是相同的），假设算法的问题规模为 n，那么操作单元数量便用函数 f(n)来表示】 12345for(i=1; i&lt;=n; ++i){ j = i; j++;} 通过「 大 O 符号表示法 」，这段代码的时间复杂度为：O(n) ，为什么呢? 在 大 O 符号表示法中，时间复杂度的公式是： T(n) = O( f(n) )，其中 f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：算法的渐进时间复杂度。，简称时间复杂度，记为 O(f(n)) 常见的时间复杂度量级有： 常数阶 O(1) 对数阶 O(logN) 线性阶 O(n) 线性对数阶 O(nlogN) 平方阶 O(n²) 立方阶 O(n³) K 次方阶 O(n^k) 指数阶(2^n) 上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。 常数阶 O(1) 无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是 O(1)，如： 12345int i = 1;int j = 2;++i;j++;int m = i + j; 线性阶 O(n) 这个在最开始的代码示例中就讲解过了，如： 12345for(i=1; i&lt;=n; ++i){ j = i; j++;} 这段代码，for 循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的，因此这类代码都可以用 O(n)来表示它的时间复杂度。 对数阶 O(logN) 还是先来看代码： 12345int i = 1;while(i&lt;n){ i = i * 2;} 从上面代码可以看到，在 while 循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环 x 次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(logn) 线性对数阶 O(nlogN) 线性对数阶 O(nlogN) 其实非常容易理解，将时间复杂度为 O(logn)的代码循环 N 遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了 O(nlogN)。 就拿上面的代码加一点修改来举例： 12345678for(m=1; m&lt;n; m++){ i = 1; while(i&lt;n) { i = i * 2; }} 平方阶 O(n²) 平方阶 O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。举例： 12345678for(x=1; i&lt;=n; x++){ for(i=1; i&lt;=n; i++) { j = i; j++; }} 这段代码其实就是嵌套了 2 层 n 循环，它的时间复杂度就是 O(n*n)，即 O(n²)如果将其中一层循环的 n 改成 m，即： 12345678for(x=1; i&lt;=m; x++){ for(i=1; i&lt;=n; i++) { j = i; j++; }} 那它的时间复杂度就变成了 O(m*n) 立方阶 O(n³)、K 次方阶 O(n^k) 参考上面的 O(n²) 去理解就好了，O(n³)相当于三层 n 循环，其它的类似。 指数阶(2^n) 斐波那契数列 递归算法 1234567long aFunc(int n) { if (n &lt;= 1) { return n; } else { return aFunc(n - 1) + aFunc(n - 2); }} 求解 F5 依赖 F4 和 F3 ，我们把 F5 作为树的根节点， F4 和 F3 作为左右两个叶子节点，继续向下递归，左节点 F4 继续向下分解为 F3 和 F2 ，右节点 F3 继续向下分解为 F2 和 F1 ，依此类推，如下图所示： 因此，该算法的时间复杂度为 $$O(2^n)$$ 递归性能优化 12345678910111213定义容器存放计算结果函数F（int n){ if (n &lt;= 1){ return 1; } if (n 在容器中有结果){ return 容器中对应n的值 } else {//没查到 结果 = F(n - 1) + F(n - 2); 容器[n] = 结果; return 结果; }} 优化后的程序相当于给之前的递归树做了剪枝操作，相同的节点仅执行一次，因此时间复杂度降为 $$O(n)$$ 循环解法 如果说前面的递归解法是自顶向下将大问题拆解成小问题求解，那么循环解法则是逆向思维，自底向上，先求出小问题的解，再向上一步一步向上求取最终问题的解。 求解过程分为 n 步，将每一步的结果保存在列表中对应下标的位置，代码如下。 12345678int n; cin &gt;&gt; n; int fibs[n] = {0}; fibs[0] = fibs[1] = 1; for (int i = 2; i &lt;= n; i ++){ fibs[i] = fibs[i - 1] + fibs[i - 2]; } cout &lt;&lt; fibs[n - 1]; 时间复杂度分析 单层循环，时间复杂度为 O(n) ，与优化后的递归解法复杂度相当。 性能优化 时间复杂度已经没有优化空间了，但可以使用两个临时变量替换掉长度为 n 的列表，使空间复杂度从 O(n) 降为 O(1) 。代码如下： 12345678910int n; cin &gt;&gt; n; int fibs_a = 0; int fibs_b = 1; for (int i = 2; i &lt;= n; i ++){ int temp = fibs_b; fibs_b = fibs_a + fibs_b; fibs_a = temp; } cout &lt;&lt; fibs_b; 缺点就是如果取小于 n 对应的斐波那契的数时候，又需要重新计算 空间复杂度既然时间复杂度不是用来计算程序具体耗时的，那么我也应该明白，空间复杂度也不是用来计算程序实际占用的空间的。 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。 空间复杂度比较常用的有：O(1)、O(n)、O(n²)，我们下面来看看： 空间复杂度 O(1) 如果算法执行所需要的临时空间不随着某个变量 n 的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)举例： 12345int i = 1;int j = 2;++i;j++;int m = i + j; 代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1) 空间复杂度 O(n) 我们先看一个代码： 123456int[] m = new int[n]for(i=1; i&lt;=n; ++i){ j = i; j++;} 这段代码中，第一行 new 了一个数组出来，这个数据占用的大小为 n，这段代码的 2-6 行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)","link":"/2024/02/22/2sf-1/"},{"title":"算法知识2-C++和Java算法常用方法","text":"&lt;标语&gt; &lt;以下是竞赛中常用的方法，不管是蓝桥杯还是天梯赛都是很常用的方法，所以放在了第二节，比较基础也比较重要&gt; 🔨JAVA📝 字符串 string1234567891011String sl =&quot;hello world&quot;;// 获取s1[2]中的字符char c = sl.charAt(2);char[] chars = sl.toCharArray();chars[1] ='a';String s2 = new String(chars);// 输出: hallo worldSystem.out.printin(s2);//注意，一定要用equals 方法判断字符串是否相同if (sl.equals(s2)) {// s1和s2相同] else [// s和s2不相同//字符串可以用加号进行拼接String s3 = sl +“!&quot;;// 输出: hello world!System.out.printin(s3); Java 的字符串不能直接修改，要用 tocharArray 转化成 char[]类型的数组后进行修改，然后转换回 string 类型 v另外，虽然字符串支持用+进行拼接，但是效率并不高，不建议在 for 循环中使用如果需要进行频繁的字符串拼接，推荐使用 stringBuilder 12345StringBuilder sb = new StringBuilder();for (char c='a';c&lt;='f'; c++)sb.append(c);// append 方法支持拼接字符、字符串、数字等类型sb.append( ' g' ) . append( &quot;hij&quot; ) .append(123) ;String res = sb.toString(); // 输出:abcdefghij123;System.out.printin(res) 📝 动态数组 ArrayList12345678910//初始化一个存储String 类型数据的动态数组ArrayList&lt;String&gt; nums = new ArrayList&lt;&gt;();//判断数组是否为空boolean isEmpty()//返回数组中元素的个数int size()//返回索引index的元素E get(int index)//在数组尾部添加元素eboolean add(E e) 📝 双链表 LinkedList1234567891011121314151617//初始化一个存储 int 类型数据的双链表LinkedList&lt;Integer&gt; nums = new LinkedList&lt;&gt;();//判断链表是否为空boolean isEmpty()// 返回链表中元素的个数int size()// 判断链表中是否存在元素 oboolean contains(0bject o)//在链表尾部添加元素eboolean add(E e)//在链表头部添加元素evoid addFirst(E e)//删除链表头部第一个元素E removeFirst()//删除链表尾部最后一个元素E removeLast() 📝 哈希表 HashMap1234567891011121314151617//整数映射到字符串的哈希表HashMap&lt;Integer，String&gt; map = new HashMap&lt;&gt;();//判断哈希表中是否存在键 keyboolean containsKey(Object key)//获得键 key 对应的值，若 key 不存在，则返回nullV get(0bject key)//将 key和 value 键值对存入哈希表V put(K key，V value)//如果 key存在，删除 key 并返回对应的值V remove(Object key)//获得 key 的值，如果 key 不存在，则返回 defaultValueV getOrDefault(0bject key，V defaultValue)/获得哈希表中的所有 keySet&lt;K&gt; keySet()//如果 key 不存在，则将键值对 key 和 value 存入哈希表//如果 key存在，则什么都不做V putIfAbsent(K key，V value) 📝 哈希集合 HashSet123456789//新建一个存储 String 的哈希集合Set&lt;String&gt; set = new HashSet&lt;&gt;();// 如果 e不存在，则将e 添加到哈希集合boolean add(E e)//判断元素o是否存在于哈希集合中boolean contains(0bject o)// 如果元素0存在，则删除元素 0boolean remove(0bject o) 📝 队列 Queue12345678910111213//新建一个存储String 的队列Queue&lt;String&gt; q = new LinkedList&lt;&gt;();//判断队列是否为空boolean isEmpty()//返回队列中元素的个数int size()// 返回队头的元素E peek()//删除并返回队头的元素E poll()// 将元素 e插入队尾boolean offer(E e) 📝 堆栈 Stack123456789101112Stack&lt;Integer&gt; s = new Stack&lt;&gt;();//判断堆栈是否为空boolean isEmpty()//返回堆栈中元素的个数int size()//将元素压入栈顶 E push(E item)//返回栈顶元素E peek()//删除并返回栈顶元素E pop() 🔨C++📝 动态数组类型 vector​ 所谓动态数组，就是由标准库封装的数组容器，可以自动扩容、缩容，比 C 语言中用 int[]声明数组更高级。​ 建议不要使用 C 语言中的数组，也不要用 malloc 这类函数自己去管理内存。虽然手动分配内存会给算法的效率带来一定的提升但是你要搞清楚自己是来干什么的，把精力更多地集中在算法思维上的性价比比较高 1234567891011121314151617181920vector&lt;int&gt; nums;//初始化一个大小为 n 的数组 nums，数组中的值默认都为 0vector&lt;int&gt; nums(n);// 初始化一个元素为 1、3、5的数组 numsvector&lt;int&gt; nums[1，3，5};//初始化一个大小为 n的数组 nums，其值全都为2vector&lt;int&gt; nums(n，2);// 初始化一个二维int 数组 dpvector&lt;vector&lt;int&gt;&gt; dp;//初始化一个大小为 m*n的布尔数组 dp/其中的值都为 truevector&lt;vector&lt;bool&gt;&gt; dp(m，vector&lt;bool&gt;(n，true));bool empty()//返回数组的元素个数size type size();//返回数组最后一个元素的引用reference back();//在数组尾部插入一个元素 valvoid push back (const value_type&amp; val)//删除数组尾部的那个元素voidpop back(); 📝String123456789size_t size();//判断字符串是否为空bool empty();// 在字符串尾部插入一个字符 cvoid push back(char c);//删除字符串尾部的那个字符void pop back();// 返回从索引 pos 开始，长度为 Len 的子字符串string substr (size t pos,size t len); 📝unordered_map 哈希表1234567891011unordered_map&lt;string，vector&lt;int&gt;&gt; mapping;//返回哈希表的键值对个数size type size();//返回哈希表是否为空bool empty();// 返回哈希表中 key出现的次数//因为哈希表不会出现重复的键，所以该函数只可能返回0或1//可以用于判断键 key 是否存在于哈希表中size type count (const key type&amp; key);//通过 key 清除哈希表中的键值对size type erase (const key_type&amp; key); 📝 哈希集合 unordered_set1234567891011121314//初始化一个存储 int 的哈希集合unordered set&lt;int&gt; visited;// 返回哈希集合的键值对个数size type size();// 返回哈希集合是否为空bool empty();//类似哈希表，如果 key 存在则返回 1，否则返回0size_type count (const key type&amp; key);//向集合中插入一个元素 keypair&lt;iterator,bool&gt; insert (const key type&amp; key);//删除哈希集合中的元素 key//如果删除成功则返回1，如果 key不存在则返回0size_type erase (const key_type&amp; key); 📝 队列 queue123456789101112//初始化一个存储string 的队列queue&lt;string&gt; q;//返回队列是否为空bool empty();//返回队列中元素的个数size type size();//将元素加入队尾void push (const value type&amp; val);//返回队头元素的引用.value type&amp; front();//删除队头元素void pop(); 📝 堆栈 Stack1234567891011Stack&lt;int&gt; stk；//返回堆栈是否为空bool empty();//返回堆栈中元素的个数size type size();//在栈顶添加元素void push (const value type&amp; val);//返回栈顶元素的引用value type&amp; top();//删除栈顶元素void pop();","link":"/2024/02/23/2sf-2/"},{"title":"算法知识3-数组知识及部分习题","text":"数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 ​ 1、二维数组int m[3][4]; 上述语句定义了一个 3 行 4 列的二维数组。 二维数组的定义与一维数组一样，应该遵循相同的原则。 二维数组 m 共有 12 个元素，每个元素都是 int 类型的。 这 12 个元素的下标分别是： 1234567m[0][0]、m[0][1]、m[0][2]、m[0][3]、m[1][0]、m[1][1]、m[1][2]、m[1][3]、m[2][0]、m[2][1]、m[2][2]、m[2][3]、 2、二维数组的内存映像图二维数组在内存中是一维存放的： C 语言中，二维数组中元素排列的顺序是按行存放的，即在内存中先顺序存放第一行的元素，再存放第二行的元素。 查找方法暴力法 就是枚举 12345678910111213141516171819202122232425public class Array02 { public static void main(String[] args) { int[] arr = {11,22,33,10,32,23,43,12,43}; // 找出arr这个数组中12所在的下标。 // 调用方法。 int num = 12; int index = arraySearch(arr,num); System.out.println(index == -1 ? num + &quot;元素不存在！&quot; : num + &quot;元素的下标：&quot; + index);}/** * 从数组检索某个元素的下标,返回的是第一个该元素的下标，因为for循环是从前到后的 * @param arr 被检索的数组 * @param ele 被检索的元素 * @return -1 表示该元素不存在，其他表示返回目标元素的下标。 */public static int arraySearch(int[] arr, int ele) { for (int i = 0; i &lt; arr.length; i++) { if (ele == arr[i]){ return i; } } return -1;} 二分查找对数组有要求，必须是有序数组 123456789101112131415161718192021222324252627282930313233343536373839404142public class ArrayUtil { public static void main(String[] args) { //数组需要满足什么要求？？？ int[] arr = {100,200,230,235,600,1000,2000,9999}; // 找出arr这个数组中200所在的下标。 // 调用方法。 int num = 200; int index = binarySearch(arr,num); System.out.println(index == -1 ? num + &quot;元素不存在！&quot; : num+ &quot;元素的下标：&quot; + index);}/** * 从数组中查找目标元素的下标。 * @param arr 被查找的数组（这个必须已经排序的）。 * @param dest 目标元素 * @return -1 表示该元素不存在，其他表示返回目标元素的下标。 */public static int binarySearch(int[] arr, int dest) { // 开始下标。 int begin = 0; // 结束下标. int end = arr.length - 1; // 开始元素下标只要在结束元素下标的左边，就有机会继续循环。 while(begin &lt;= end){ // 中间元素下标 int mid = (begin + end) / 2; if (arr[mid] == dest){ return mid; } else if (arr[mid] &lt; dest){ // 目标在“中间“的右边。 // 开始元素下标需要发生变化（开始元素的下标需要重新赋值）。 begin = mid + 1; // 一直增。 } else { // arr[mid] &gt; dest // 目标元素在”中间“左边 // 修改结束元素下标 end = mid - 1; // 一直减 } } return -1;} ​ 求三数之和(Three Sum)题目给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ,请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。示例： 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为： 1234[ [-1, 0, 1], [-1, -1, 2]] 暴力解法 12345678910111213141516171819202122232425/*** 循环三次，结果集使用了set集合，避免了返回值重复 */ private List&lt;List&lt;Integer&gt;&gt; directlySolution(int[] nums) { if (nums == null || nums.length &lt;= 2) { return Collections.emptyList(); } Arrays.sort(nums); //set集合去重 Set&lt;List&lt;Integer&gt;&gt; result = new LinkedHashSet&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) { for (int j = i+1; j &lt; nums.length; j++) { for (int k = j+1; k &lt; nums.length; k++) { if (nums[i] + nums[j] + nums[k] == 0) { List&lt;Integer&gt; value = Arrays.asList(nums[i], nums[j], nums[k]); result.add(value); } } } } return new ArrayList&lt;&gt;(result); } 优秀解法：O（n^2)思路 12345678910111213141516171819202122232425262728class Solution { public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList(); int len = nums.length; if(nums == null || len &lt; 3) return ans; Arrays.sort(nums); // 排序 for (int i = 0; i &lt; len ; i++) { if(nums[i] &gt; 0) break; // 如果当前数字大于0，则三数之和一定大于0，所以结束循环 if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; // 去重 int L = i+1; int R = len-1; while(L &lt; R){ int sum = nums[i] + nums[L] + nums[R]; if(sum == 0){ ans.add(Arrays.asList(nums[i],nums[L],nums[R])); while (L&lt;R &amp;&amp; nums[L] == nums[L+1]) L++; // 去重 while (L&lt;R &amp;&amp; nums[R] == nums[R-1]) R--; // 去重 L++; R--; } else if (sum &lt; 0) L++; else if (sum &gt; 0) R--; } } return ans; }} 前缀和一维数组前缀和 如果你没有了解过「前缀和」，可能会写出两重循环：每个 runningSum[i]，累加从 0 位置到 i 位置的 nums[i] 12345678910111213vector&lt;int&gt; runningSum(vector&lt;int&gt;&amp; nums) { const int N = nums.size(); vector&lt;int&gt; preSum(N, 0); for (int i = 0; i &lt; N; ++i) { int sum = 0; for (int j = 0; j &lt;= i; ++j) { sum += nums[j]; } preSum[i] = sum; } return preSum;} 两重循环的时间复杂度是 O(N^2)，效率比较低。 12345678910111213vector&lt;int&gt; runningSum(vector&lt;int&gt;&amp; nums) { const int N = nums.size(); vector&lt;int&gt; preSum(N, 0); for (int i = 0; i &lt; N; ++i) { if (i == 0) { preSum[i] = nums[i]; } else { preSum[i] = preSum[i - 1] + nums[i]; } } return preSum;} 前缀和方法优化=&gt;时间复杂度变成 O(n) 那么什么是前缀和？ 「前缀和」 是从 nums 数组中的第 0 位置开始累加，到第 i 位置的累加结果，我们常把这个结果保存到数组 preSum 中，记为 preSum[i]。 在前面计算「前缀和」的代码中，计算公式为 preSum[i] = preSum[i - 1] + nums[i] ，为了防止当 i = 0 的时候数组越界，所以加了个 if (i == 0) 的判断，即 i == 0 时让 preSum[i] = nums[i]。 事例样图 下面以 [1, 12, -5, -6, 50, 3] 为例，用动图讲解一下如何求 preSum。（只不过改个下标） 拓展：求数组的区间和利用 preSum 数组，可以在 O(1)O(1)O(1) 的时间内快速求出 nums 任意区间 [i,j][i, j][i,j] (两端都包含) 内的所有元素之和。 一维数组前缀和公式 sum(i,j) = preSum[j+1] − preSum[i] 什么原理呢？其实就是消除公共部分即 0~i-1 部分的和，那么就能得到 i~j 部分的区间和。 注意上面的式子中，使用的是 preSum[j + 1] 和 preSum[i]，需要理解为什么这么做。（如果理解不了的知识，那就记不住，所以一定要理解） preSum[j + 1] 表示的是 nums 数组中 [0,j] 的所有数字之和（包含 0 和 j）。 preSum[i]表示的是 nums数组中 [0,i−1] 的所有数字之和（包含 0 和 i−1）。 当两者相减时，结果留下了 nums数组中 [i,j] 的所有数字之和 前缀和再进阶：二维数组前缀和 帮助理解 代码展示 #include &lt;bits/stdc++.h&gt; using namespace std; const int MAXN = 1e3+2; const int MAXM = 1e3+2; int sum[MAXN][MAXM] = {}; int main() { int n,m; cin&gt;&gt;n&gt;&gt;m; int data; for (int i=1; i&lt;=n; i++) { for (int j=1; j&lt;=m; j++) { cin &gt;&gt; data; sum[i][j] = sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+data; } } for (int i=1; i&lt;=n; i++) { for (int j=1; j&lt;=m; j++) { cout &lt;&lt; sum[i][j] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } return 0; } 二维前缀和小提升：根据 preSum 求子矩形面积 帮助理解","link":"/2024/02/23/2sf-3/"},{"title":"算法知识4-二叉树知识","text":"包含递归知识以及二叉树基本的算法知识 注：递归知识主要围绕二叉树知识展开 树的介绍 树的定义树是一种数据结构，它是由 n（n&gt;=1）个有限节点组成一个具有层次关系的集合。 把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点： 每个节点有零个或多个子节点; 没有父节点的节点称为根节点; 每一个非根节点有且仅有一个父节点; 除了根节点以外，每个子节点可以分为多个不想交的子树。 树的基本术语 节点的度：节点拥有的子树的数目。 叶子：度为零的节点。 分支节点：度不为零的节点。 树的度：树中节点的最大的度。 层次：根节点的层次为 1，其余节点的层次等于该节点的双亲节点加 1。 树的高度：树中节点的最大层次。 无序数：如果树中节点的各子树之间的次序是不重要的，可以交换位置。 有序数：如果树中结点的各子树的次序是重要的，不可以交换位置。 森林：0 个或多个不相交的树组成。对森林加上一个跟，森林即成为树；删去跟，树即成为森林。 相关性质 二叉树（简单介绍） 二叉树的定义​ 二叉树是每个节点最多有两个子树的树结构。 ​ 它有五种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；活着左、右子树皆为空。 二叉树与度为 2 的树的区别 度为 2 的的树必须有三个节点以上(否则就不叫度为二了，一定要先存在)，二叉树可以为空。 二叉树的度不一定为 2,比如斜树。 二叉树有左右节点区分，而度为 2 的树没有左右节点的区分。 二叉树的基本性质 性质 1：二叉树第 i 层上的节点数目最多为 2{i-1} (i≥1)。 (01) 当 i=1 时，第 i 层的节点数目为 2{i-1}=2{0}=1。因为第 1 层上只有一个根结点，所以命题成立。(02) 假设当 i&gt;1，第 i 层的节点数目为 2{i-1}。这个是根据(01)推断出来的！下面根据这个假设，推断出”第(i+1)层的节点数目为 2{i}”即可。由于二叉树的每个结点至多有两个孩子，故”第(i+1)层上的结点数目” 最多是 “第 i 层的结点数目的 2 倍”。即，第(i+1)层上的结点数目最大值=2×2{i-1}=2{i}。 性质 2：深度为 k 的二叉树至多有 2{k}-1 个节点（k&gt;=1）。 在具有相同深度的二叉树中，当每一层都含有最大结点数时，其树中结点数最多。利用”性质 1”可知，深度为 k 的二叉树的结点数至多为：20+21+…+2k-1=2k-1 性质 3：包含 n 个节点的二叉树的高度至少为 log2 (n+1)。 根据”性质 2”可知，高度为 h 的二叉树最多有 2{h}–1 个结点。反之，对于包含 n 个节点的二叉树的高度至少为 log2(n+1)。 性质 4：在任意一颗二叉树中，若终端节点的个数为 n0，度为 2 的节点数为 n2，则 n0=n2+1。 因为二叉树中所有结点的度数均不大于 2，所以结点总数(记为 n)=”0 度结点数(n0)” + “1 度结点数(n1)” + “2 度结点数(n2)”。由此，得到等式一。(等式一) n=n0+n1+n2 另一方面，0 度结点没有孩子，1 度结点有一个孩子，2 度结点有两个孩子，故二叉树中孩子结点总数是：n1+2n2。此外，只有根不是任何结点的孩子。故二叉树中的结点总数又可表示为等式二。(等式二) n=n1+2n2+1由(等式一)和(等式二)计算得到：n0=n2+1。 二叉树的种类满二叉树高度为 h，并且由 2{h} –1 个结点的二叉树，被称为满二叉树。 ![5d6d36fbea67c9e611fbdcf9c84eca67 (1)](F:\\goole 下载\\5d6d36fbea67c9e611fbdcf9c84eca67 (1).png) 完全二叉树一颗二叉树中，只有最下面两层节点的度可以小于 2，并且最下层的叶节点集中在靠左的若干位置上。 一颗满二叉树必定是一颗完全二叉树，而完全而二叉树不一定是满二叉树。 二叉查找树 若任意节点的左子树不空，则左子树上所有的值均小于根节点的值 若任意节点的右子树不空，则右子树上所有节点的值均大于根节点的值（更大于左子树上的值） 任意节点的左、右子树也分别为二叉查找树 没有键值相等的节点 平衡二叉搜索树AVL(Adelson-Velsky and Landis)树，具有以下性质：它是一颗空树或者它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一颗平衡二叉树。 二叉树的存储方式链式存储​ 通过指针把分布在散落在各个地址的节点串联在一起，链式存储如图所示： 顺序存储​ 就是用数组来存储二叉树，顺序存储的方式如图： 数组存储的遍历 ​ 如果父节点的数组下标是 i,那么它的左孩子就是 2 _ i + 1,右孩子就是 i _ 2 + 2。（但是用链式表示的二叉树更有利于我们理解，一般都是用链式存储二叉树） 二叉树的遍历 二叉树的创建参考https://blog.csdn.net/new_aiden/article/details/50968112 前序遍历、中序遍历、后序遍历、层序遍历4 种方式。 前序遍历=&gt;根左右若二叉树非空，则执行以下操作：访问根结点；先序遍历左子树；先序遍历右子树。 123456789// 前序递归遍历 public static void preOrderRecursively(TreeNode tree) { if (tree == null) { return; } System.out.print(tree.val + &quot;\\t&quot;); preOrderRecursively(tree.left); preOrderRecursively(tree.right); } 中序遍历=&gt;左根右若二叉树非空，则执行以下操作：中序遍历左子树；访问根结点；中序遍历右子树。 123456789public static void inOrderRecursively(TreeNode tree) { if (tree == null) { return; } inOrderRecursively(tree.left); System.out.print(tree.val + &quot;\\t&quot;); inOrderRecursively(tree.right); } 后序遍历=&gt;左右根若二叉树非空，则执行以下操作：后序遍历左子树；后序遍历右子树；访问根结点。 123456789// 后序递归遍历 public static void postOrderRecursively(TreeNode tree) { if (tree == null) { return; } postOrderRecursively(tree.left); postOrderRecursively(tree.right); System.out.print(tree.val + &quot;\\t&quot;); } 层序遍历=&gt;逐层遍历，从左到右123456789101112131415161718192021// 层次遍历并顺序打印（借助队列） public static void levelOrder1(TreeNode tree) { if (tree == null) { return; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(tree); TreeNode temp = null; while (!queue.isEmpty()) { temp = queue.poll(); System.out.print(temp.val + &quot;\\t&quot;); if (temp.left != null) { queue.offer(temp.left); } if (temp.right != null) { queue.offer(temp.right); } } System.out.println(); }","link":"/2024/02/24/2sf-4/"},{"title":"算法知识5-递归算法","text":"递归 根据上述二叉树的知识，对递归知识能有更好的理解。 什么是递归？ 递归递归，一个是“递”，一个是“归”。 举个从小就听过的例子： 从前有座山，山中有座庙，庙里有个老和尚，老和尚在给小和尚讲故事：“ 从前有座山，山中有座庙，庙里有个老和尚，老和尚在给小和尚讲故事：“ 从前有座山，山中有座庙，庙里有个老和尚，老和尚在给小和尚讲故事：“ 从前有座山，山中有座庙，庙里有个老和尚，老和尚在给小和尚讲故事：“太困了不讲了”，于是都回去睡觉了。”于是都回去睡觉了。”于是都回去睡觉了。”于是都回去睡觉了。 ​ 在讲故事的过程中，可以看成一个递的过程，在“太困了不讲了”可以看成一个递的边界，接下来执行“归”的过程。所以我理解的递归无非是在边界条件前不断执行“递”的过程，在达到边界值后，执行“归”的过程。 ​ 递归的基本思想是某个函数直接或者间接地调用自身，这样原问题的求解就转换为了许多性质相同但是规模更小的子问题。求解时只需要关注如何把原问题划分成符合条件的子问题，而不需要过分关注这个子问题是如何被解决的。 递归的思想递归有三大要素 第一要素：明确你这个函数想要干什么 对于递归，我觉得很重要的一个事就是，这个函数的功能是什么，他要完成什么样的一件事，而这个，是完全由你自己来定义的。也就是说，我们先不管函数里面的代码什么，而是要先明白，你这个函数是要用来干什么。 12// 算 n 的阶乘(假设n不为0)int f(int n){} 第二要素：寻找递归结束条件 所谓递归，就是会在函数内部代码中，调用这个函数本身，所以，我们必须要找出递归的结束条件，不然的话，会一直调用自己，进入无底洞。也就是说，我们需要找出当参数为啥时，递归结束，之后直接把结果返回，请注意，这个时候我们必须能根据这个参数的值，能够直接知道函数的结果是什么。 123456// 算 n 的阶乘(假设n不为0)int f(int n){ if(n == 1){ return 1; }} 第三要素：找出函数的等价关系式 第三要素就是，我们要不断缩小参数的范围，缩小之后，我们可以通过一些辅助的变量或者操作，使原函数的结果不变。 例如，f(n) 这个范围比较大，我们可以让 f(n) = n * f(n-1)。这样，范围就由 n 变成了 n-1 了，范围变小了，并且为了原函数 f(n) 不变，我们需要让 f(n-1) 乘以 n。 说白了，就是要找到原函数的一个等价关系式，f(n) 的等价关系式为 n * f(n-1)，即 f(n) = n * f(n-1)。 12345678910111213int f(int n){ if(n == 1){ return 1; } else return n * f(n - 1);}int f(int n){ int s = 1; for (int i = 1; i &lt;= n; i ++){ s *= i; } return s;} 题目二叉树的最大深度定义二叉树： 12345678910111213141516171819202122class TreeNode{ /** * 值 */ int val; /** * 左孩子 */ TreeNode left; /** * 右孩子 */ TreeNode right; /** * 构造方法 * @param x */ TreeNode(int x){ this.val=x; } } 代码 12345678910111213141516171819public int maxDepth(TreeNode root) { //如果根结点为空 if (null == root) { //即二叉树的最大深度为0 return 0; } else { //递归调用 //获取左孩子的深度 int left_height = maxDepth(root.left); //获取右孩子的深度 int right_height = maxDepth(root.right); //java.lang.Math.max(参数1，参数2)是一个静态的工具方法，主要用来比较两个相同类型参数的大小， // 支持的类型有double，float，int，long四种类型 // 只要左边孩子或者右边孩子不为空则深度+1 // 返回两个数字中最大的那一个 return Math.max(left_height, right_height) + 1; } }","link":"/2024/02/24/2sf-5/"},{"title":"算法知识4-二叉树的构造","text":"🌺 构建方法二叉树的前序、中序和后序序列中的任何一个都不能唯一确定一棵二叉树， 给出一个遍历序列 A、B、C、D、E 若遍历序列为前序构造： 若遍历序列为中序构造： 若遍历序列为后序构造： 由此可见，通过某一种遍历序列不能精准构造出二叉树，构造的二叉树会有很多种 二叉树的构建主要有三大方法。 通过前序和中序建立二叉树 通过后序和中序建立二叉树 通过层序和中序建立二叉树 前、后、层次序列用来提供根结点信息，中序序列用来区分左右子树； 思考：可否通过前序遍历和后序遍历构造二叉树？ 🌻 通过前序和中序建立二叉树构建过程： 根据给定的树写出前序和中序序列； 前序序列中的第一个数字为根结点，构造根结点； 找到根结点在中序序列中的位置，中序中根结点左右两边分别为左子树和右子树的中序序列，根据左右子树 结点数量可以在前序序列根节点后面分别找到左子树和右子树的前序序列； 递归处理左右子树，返回根结点，完成构造。 实例： 前序序列：A、B、C、D、E 中序序列：C、D、B、E、A 根据前序序列和中序序列构造二叉树 练习： 前序遍历序列为：{1,2,4,7,3,5,6,8}，中序遍历序列为：{4,7,2,1,5,3,8,6}。 根据前序遍历和中序遍历构建唯一的二叉树。 前序序列： 中序序列： 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { if(preorder==null||inorder==null){ return null; } return buildtree(preorder, 0,preorder.length-1,inorder,0,inorder.length-1); } public TreeNode buildtree(int[] preorder, int pleft,int pright,int[] inorder,int ileft,int iright){ if(pleft&gt;pright||ileft&gt;iright){ return null; } //根节点值是前序遍历的第一个 TreeNode root=new TreeNode(preorder[pleft]); //中序遍历第一个为起始点 int middle=ileft; //左子树节点长度 int len=0; //找到中序遍历中的根节点位置记为middle for(;middle&lt;inorder.length;middle++){ if(inorder[middle]==preorder[pleft]){ break; } //计算左子树节点长度len len++; } //递归调用求解左右子树 //左子树：前序遍历为根后一个到根加左子树长度，中序遍历为第一个到根节点位置前一个 root.left=buildtree(preorder,pleft+1,pleft+len,inorder,ileft,middle-1); //右子树：前序遍历为左子树后一个到最后一个，中序为根节点后一个到最后一个 root.right=buildtree(preorder,pleft+len+1,pright,inorder,middle+1,iright); return root; }} map 优化 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); int length = inorder.length; for (int i = 0;i &lt; length;i++) { map.put(inorder[i],i); } return build(map,preorder,inorder,0,length-1,0,length-1); } private TreeNode build(Map&lt;Integer,Integer&gt; map,int[] preorder, int[] inorder,int pl,int pr,int il,int ir) { if (pr &lt; pl || ir &lt; il) { return null; } //首先构建一下根节点 TreeNode root = new TreeNode(preorder[pl]); //定位根节点在中序中的位置 int index = map.get(preorder[pl]); //左子树个数 int leftCount = index-il; //构建根节点的左子树和右子树 //前序的pl+1到pl+leftCount对应着中序的il到index-1 root.left = build(map,preorder,inorder,pl+1,pl+leftCount,il,index-1); //前序的pl+leftCount+1到pr对应着中序的index+1到ir root.right = build(map,preorder,inorder,pl+leftCount+1,pr,index+1,ir); return root; }} 🌻 通过前序和中序建立二叉树构建过程。 根据给定的二叉树，得到后序序列 和中序序列为 后序序列中的最后一个数字为根结点，构造根结点； 找到根结点在中序序列中的位置，中序中根结点左右两边分别为左子树和右子树的中序序列，根据左右子树结点数量可以在后序序列根节点前面分别找到左子树和右子树的后序序列； 递归处理左右子树，返回根结点，完成构造。 实例： 前序序列：C、D、B、E、A 中序序列：C、D、B、E、A 根据后序序列和中序序列构造二叉树 练习： 前序遍历序列为：{1,2,4,7,3,5,6,8}，中序遍历序列为：{4,7,2,1,5,3,8,6}。 根据前序遍历和中序遍历构建唯一的二叉树。 后序序列： 中序序列： 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public TreeNode buildTree(int[] inorder, int[] postorder) { if(postorder==null||postorder==null){ return null; } return buildtree(inorder,0,inorder.length-1,postorder,0,postorder.length-1); } public TreeNode buildtree(int[] inorder,int ileft,int iright,int[] postorder,int pleft,int pright){ if(ileft&gt;iright||pleft&gt;pright){ return null; } //根节点值为后序遍历最后一个 TreeNode root=new TreeNode(postorder[pright]); //中序遍历第一个为起始点 int middle=ileft; //左子树节点长度len int len=0; for(;middle&lt;iright;middle++){ //找到中序遍历中的根节点位置 if(inorder[middle]==postorder[pright]){ break; } //记录左子树节点长度 len++; } //递归调用求解左右子树 //左子树：中序遍历为第一个到根节点前一个，后序遍历为第一个到第一个加左子树节点长度-1 root.left=buildtree(inorder,ileft,middle-1,postorder,pleft,pleft+len-1); //右子树：中序遍历为根节点后一个到最后，后续遍历为第一个加左子树节点长度到最后一个前一个 root.right=buildtree(inorder,middle+1,iright,postorder,pleft+len,pright-1); return root; }} 🌻 通过层序和中序建立二叉树构建过程。 根据给定的二叉树，得到层次序列 {1,2,3,4,5,6,7,8} 和中序序列为 {4,7,2,1,5,3,8,6}； 层次序列中的第一个数字为根结点，构造根结点； 找到根结点在中序序列中的位置，中序中根结点左右两边分别为左子树和右子树的中序序列。根据左右子树结点值在层次序列中按顺序找到左子树和右子树的层次序列； 递归处理左右子树，返回根结点，完成构造。 层次序列： 中序序列： 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// @brief: 根据后序+中序序列构建二叉树// @ret: 二叉树的根结点BinaryTreeNode* constructLevelMid(const vector&lt;int&gt;&amp; levelorder, const vector&lt;int&gt;&amp; midorder) { // 参数检查 if (levelorder.size() == 0 || midorder.size() == 0 || levelorder.size() != midorder.size()) { return nullptr; } // 层次序列的第一个值是根结点 int rootKey = levelorder.front(); BinaryTreeNode* root = new BinaryTreeNode; root-&gt;m_key = rootKey; // 只有一个结点 if (levelorder.size() == 1) { if (levelorder.front() == midorder.front()){ return root; } else { return nullptr; } } // 在中序序列中找到根结点下标 int index = 0; while(index &lt; midorder.size()-1 &amp;&amp; midorder.at(index)!= rootKey) { index++; } // 从层次序列中找到左子树和右子树的层次序列 vector&lt;int&gt; lLevelorder, rLevelorder; for (int i = 1; i &lt; levelorder.size(); i++) { bool isLeft = false; for (int j = 0; j &lt; index; j++) { if (levelorder.at(i) == midorder.at(j)) { isLeft = true; break; } } if (isLeft) { lLevelorder.push_back(levelorder.at(i)); } else { rLevelorder.push_back(levelorder.at(i)); } } // 从中序序列找到左子树和右子树的中序序列 vector&lt;int&gt; lMidorder, rMidorder; for (int i = 0; i &lt; midorder.size(); i++) { if (i &lt; index){ lMidorder.push_back(midorder.at(i)); } else if (i &gt; index) { rMidorder.push_back(midorder.at(i)); } } // 构建左子树 if (lLevelorder.size() &gt; 0) { root-&gt;m_pLeft=constructLevelMid(lLevelorder, lMidorder); } // 构建右子树 if (rLevelorder.size() &gt; 0){ root-&gt;m_pRight = constructLevelMid(rLevelorder, rMidorder); } return root;} 🌻 通过前序和后序建立二叉树通过前序和后序不能建立唯一的二叉树，但是可以对二叉树进行重构 为什么通过前序和后序不能建立唯一的二叉树？ 重构二叉树： ​ 给定两个整数数组，preorder 和 postorder ，其中 preorder 是一个具有 无重复 值的二叉树的前序遍历，postorder 是同一棵树的后序遍历，重构并返回二叉树。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode constructFromPrePost(int[] preorder, int[] postorder) { return build(preorder, 0, preorder.length - 1, postorder, 0, postorder.length - 1); } // 定义：根据 preorder[preStart..preEnd] 和 postorder[postStart..postEnd] // 构建⼆叉树，并返回根节点。 TreeNode build(int[] preorder, int preStart, int preEnd, int[] postorder, int postStart, int postEnd) { if (preStart &gt; preEnd) { return null; } if (preStart == preEnd) { return new TreeNode(preorder[preStart]); } // root 节点对应的值就是前序遍历数组的第⼀个元素 int rootVal = preorder[preStart]; // root.left 的值是前序遍历第⼆个元素 // 通过前序和后序遍历构造⼆叉树的关键在于通过左⼦树的根节点 // 确定 preorder 和 postorder 中左右⼦树的元素区间 int leftRootVal = preorder[preStart + 1]; // leftRootVal 在后序遍历数组中的索引 int index = 0; for (int i = postStart; i &lt; postEnd; i++) { if (postorder[i] == leftRootVal) { index = i; break; } } // 左⼦树的元素个数 int leftSize = index - postStart + 1; // 先构造出当前根节点 TreeNode root = new TreeNode(rootVal); // 递归构造左右⼦树 // 根据左⼦树的根节点索引和元素个数推导左右⼦树的索引边界 root.left = build(preorder, preStart + 1, preStart + leftSize, postorder, postStart, index); root.right = build(preorder, preStart + leftSize + 1, preEnd, postorder, index + 1, postEnd - 1); return root; } }","link":"/2024/02/24/2sf-6/"},{"title":"vue+three.js环境的搭建","text":"在这篇文章中直接讲明关于 three.js 源码包初使用的操作步骤，其他构建项目的过程一带而过。 第一步，创建自己的 vue 项目由于电脑全局安装的还是之前的 vue2 版本，而且在写项目的时候也是一直使用的 vue2，所以这次还是 vue2 创建项目，使用口令 1vue init webpack 项目名 第二步，安装 three 源码包在这里，我遇到很多问题，在之后构建项目的时候，出现了引入的部件 undefined 的情况，我也试过重装的方法，但是都不行，最后我发现我安装的是three.js，而不是three，这两个是有很大区别的！ 以上是 three 资源包的目录，在 three.js 中虽然能找到对应需要引入的部件，但是在项目中是不好用的，会出现对应部件的语法错误的问题，这个地方也是因为马虎的一个小坑。 在我们知道安装 three 而不是 three.js 之后的问题之后，我们就正常使用 npm 安装命令就可以了 1npm i three --save 但是如果单纯是自己测试娱乐的话，可以把 three.js 下载在本地，然后 live example 去跑跑样例，或者是写一些简单的代码运行也可以 通过这种方法引入 轨道控制器 OrbitControls的时候，要注意对应的版本，要不然会出现出错的情况","link":"/2024/02/26/3th-1/"},{"title":"three.js-3D场景Scene的创建","text":"能把模型展示在屏幕上，当然少不了对 3D 场景的创建 三维场景Scene你可以把三维场景Scene (opens new window)对象理解为虚拟的 3D 场景，用来表示模拟生活中的真实三维场景,或者说三维世界。 12// 创建3D场景对象Sceneconst scene = new THREE.Scene(); 接着我们去看如何在场景中添加物体 在我们生活当中的物体，比如棉花，我们知道它是形状不定、蓬松柔软的。在 three.js 中也是如此，也需要对应的形状和材质才能确定这个物体。 那么创建物体第一步，创建一个几何形状 Three.js 提供了各种各样的几何体 API，用来表示三维物体的几何形状。 如果你想定义物体的外观效果，比如颜色，就需要通过材质Material相关的 API 实现。 12//创建一个长方体几何对象Geometryconst geometry = new THREE.BoxGeometry(100, 100, 100); 第二步，创建物体的材质 threejs 不同材质渲染效果不同，下面就以 threejs 最简单的网格基础材质MeshBasicMaterial (opens new window)为例实现一个红色材质效果 1234//创建一个材质对象Materialconst material = new THREE.MeshBasicMaterial({ color: 0xff0000, //0xff0000设置材质颜色为红色}); 最后一步，创建网格模型 12// 两个参数分别为几何体geometry、材质materialconst mesh = new THREE.Mesh(geometry, material); //网格模型对象Mesh 创建好网格模型之后，还需要确定模型位置.position 实际生活中，一个物体往往是有位置的，对于 threejs 而言也是一样的，你可以通过位置属性.position定义网格模型Mesh在三维场景Scene中的位置。 123const mesh = new THREE.Mesh(geometry, material); //网格模型对象Mesh//设置网格模型在三维空间中的位置坐标，默认是坐标原点mesh.position.set(0, 10, 0); 这个时候我们场景 scene和网格模型都已经搭建好了，我们需要使用.add方法将网格模型添加到我们的场景当中 1scene.add(mesh);","link":"/2024/02/27/3th-2/"},{"title":"生活小记-魔方三阶复原公式(初级篇)","text":"目前一共开了四个专栏，前端学习、算法小记、three.js、生活小记，生活小记就是记录生活的小事，可能是学习了什么东西或者对什么东西的感受 1. 黄心白色十字 2.确定中点和最下层一致 并做成白心白色十字对齐固定中点与最下层中点一致 翻转向下 90 度 此时白色为底色 置于最下层 3.确定最下层与中心方块一致当第一层有白色混合棱角 移到另外两色块中间 使用右手公式（上左下右） 多次切换 4.确定第二层与中心方块一致当第一层有不含黄色方块将其面向色块与中心色块保持一致 另一色块在其一侧 移动上层 使其远离另一色块如果方向为左 做右手公式（上左下右） 再将白色方块置于左侧 做左手公式（上右下左）如果方向为右 做左手公式（上右下左） 再将白色方块置于右侧 做右手公式（上左下右）当第一层均包含黄色方块将第二次异常方块置于右手 做右手公式（上左下右） 再将白色方块置于左侧 做左手公式（上右下左）此时异常方块已移动到最上层 再重复（当第一层有不含黄色方块） 5.确定最上层黄心十字当上层无 L 型或横型 选任意方向 前方顺时针 90 度 做右手公式（上左下右） 前方逆时针 90 度此时为 L 型 两边朝向右手 前方顺时针 90 度 做右手公式（上左下右） 前方逆时针 90 度此时为横型 平行横线 前方顺时针 90 度 做右手公式（上左下右） 前方逆时针 90 度 6.确定最上层上平面下右上右下右右上此时有小鱼图样 （有且只有三个黄色块）鱼头朝上 下右上右下右右上此时有两个非黄色色块侧面黄色置于左上朝外 下右上右下右右上此时有小鱼图样 （有且只有三个黄色块）鱼头朝上 下右上右下右右上 7.确定最上层角块有角块颜色一致选择角块颜色一致的朝下 面向黄色 上右上 下面 180° 下左上 下面 180° 右面 180°无角块颜色一致选择任意朝下 面向黄色 上右上 下面 180° 下左上 下面 180° 右面 180°有角块颜色一致 8.确定最上层中点有好的一面好的一面对准自己 下左下右 下右下左 上左 180°没好的一面任意一面对准自己 下左下右 下右下左 上左 180°好的一面 我一定要学会 CFOP！~","link":"/2024/02/28/4sh-1/"},{"title":"生活小记-开学日","text":"0b2f4e5d6eec5d3dd7df5050da23c5c48069d06e8251935a3460c26e532f4749441816f60f8296cfdfa80b3f44648732afd424d40d829741d49eaa055494840e52a208e3e532bb7a534b52090b25f61568f55f50e682ae86dabe435b538b3aff984994d9d4a8024a866df7bd2e0d1b96db4414f360aba828d4b68a207cfa294c58935677185b0399c9d03ecbc03252731af60b6ac4786f99c3e8f1e765a21395983f15a7476299ee59b4e90898a6a0db8739f79e704160d2a418aff9093e387a6605f3aef04aec1654283e4bb83bd655e770fe23db30021af01406facfbf7abea58ba9d9fe1513b7af4b82b4d7cf0456c9e962600752273227b6957e691865a356cd7b2ed2c707899a597810444fcdeeecdba850581130ef85dac0597cb7cd291727dae8a0e262417d60a0fd5a51d1f4821e7293e297fb9255cb3b5b1510d35ea8fc4ac4719b389363951069fe43b595c3a062acebd59557073c8299570a222d74eb8d77902f080289ce65ce1bdefd602bb2983b9f5f5ccaffe23670dbaeea563358f689c1695bbbf9e20f82ee8878f5b928b4bed7c943d39b91e4831b0b6b8d2b88f6662a80b8ad97ad9ee1336b7b4a7eb92895224d834f00c8efe45877ea32fa8d41c2c3f18db1c8729d846b06910987d98ba00b80ce0076cb40c90b644dc230702d6c37b9bf97258a58ee31279a522695b5381f3de50f64acbb1756dc972e0eef04b7928e062f0e8595d7701c696616cc9404adf66ae3b132185e9cfe1279bab9d533cb390e032bdb52cbb106707a8835784b2439970736f637722b987802fdfb102edc41d65807126ffeae0e2db41f96a8d11ed09821125cec130c88cf5eda297d5acd76f650fca0c1b7b258e78f7e281cb3cd293cd02511fd49a982dd7387d269a82e98a9b63d6128ef123f531393adc09443a9f45ea08b710bb8b74b79f3bd6b896b7e966f14bc3d9a919d8481c5765f814105eac7a4876d4eff90e2dc97b5e7c130716e1e6c0627bc3c2f2a0a34eecf7c6f44e33cfa821ecef2f074892215cd5cc701a913280928aa9db35b3908eae51036623184e1a65f3e333098a8fd6fae0043ec50a7dccdbf067e0ed1fb444173435cb36758b6d088bec478ae7de233739af2eff7715fd9ad9016f92c6b9a7400f21fc4342d94c8a775ad0a34fb16901eefede8593a980a8d0cf4900620299f93384c3fcf1fd6a5b6955efa62705df2df89a17c209ef94f234cad6ed35685578b774b3f81ab945dd43ded400f0138ddc95231edae1b5c4344352452c239f28cbe3be35841a30d24bff1d2fab104e2271e309bbf946be51941f1f45e49deb2bd6e8a8999f4f949db847087b6152ead270c6cac35940ffc0aa039b3137cbe8eb8727c5ff2ccf2706c780ab6b8ada542ca293d688a92fb87440cf4ace203d329a112f0a8a9a390d4c88abd0f42323d2d3b7fcc8db5aa3ed3745879f88124f0cb423defe4b2737a1bd44831a9dd5bcbb8cfe256f5bc8677807420071de58793276ecf2a2467cbf6d04e6c5fc52dfd9318a685da0ccb637c3494eae3a1f3ce2a027a5af93ae5c9a45692ba6c47c4566cec05f8309db8cb32a02172808897ea14b205ff0313c7353baba1cdfd181000576a8f0e4d4ab7835c7eb59169bd780dacef7eb1f0867c518276409da59795055db8111d0ebc0201bcd0ed4e99463e3f6c0346ef36326fdbb8ce8b8c399282104dad84c278a24df114b2c29922ec593be00c31096bccdfd9f11d913d2fb4add0c3a4816a928c2bf30c7fa712752066d68c41ddf196870d3e96929252cf9b96146fdcaba622b2c050d0885ce3349e899c47a20a074f5c117f8986e2d1c9b76f722eb7b9e3cf8ab17970fd9f6573c41bc482d8476eb7ec725d4a35edde40415bc154f98f8f5a2c66afbc4e445f575c49b65444ece6724e554c1dd9d1c4785e19b0871f2b059a20d0a02a9213edf68ae555ec9710a42c487b419679016ebf1bf5cc4ac42287819826df486350122f377e0373b58f93fd0df53c07bfb9cbecea669b68000d1a7000f051d0d9b843e111c0eeab371435dad5bf9afa0c10668f28db4983668b37def71a216fefd4d1de233e5397b0266006d6523e1f043973ce5917a7ccd47f24cd4b0a05e0d68b1a39589ea2bb24ac749560056185c48784b5bdf4f3f6 请输入密码","link":"/2024/03/02/4sh-2/"},{"title":"three.js-加载glb模型(含踩坑)","text":"在假期学了 three.js 的教程，但是也只停留在听的层次，没有练习过，听能听懂，但是到实操的时候问题比比皆是，这篇文章是关于如何用 three.js 去加载 glb 模型的，包含找了很久也没解决但是最后成功了的方法 在上一节的 three.js 教程中，学会了怎么搭建一个场景，以及是怎么渲染出来了，再用一句话去概括一下这个过程 这就好比我们的生活中，我们通过眼睛去看这个世界，这个世界里面有很多东西，这个就是由物体和环境构成的场景，也就是我们说的scene，再者，我们通过眼睛去看这个环境的一草一木，一人一物，这个就是对应的camera，也就是那个相机，但是我们随着时间的流逝，也就物体在运动，也可能在静止状态，但是我们不能通过这一瞬间知道物体之后的状态，所以渲染器的持续渲染(实时渲染)就很重要了，有了renderer我们才能知道我们观察物体的状态及运动。 在场景、相机以及渲染器都调试好了之后，我们可以加载我们的模型了，其实加载模型不难，直接用 loader 里面的 load 方法加载不就行了嘛。没错当我在弄得时候也是这么想的，但是在实操的时候我忽略了几个问题： 模型的路径问题 模型放在哪个文件里 这两个问题困扰我很长时间，第二个问题比较好解决。但是第一个问题我找了很多帖子，在我这就是不好用 o(╥﹏╥)o 下面开始一步步在加载模型 1.引用加载器这次加载的模型用到这两个模型 12import { GLTFLoader } from &quot;three/examples/jsm/loaders/GLTFLoader&quot;;import { DRACOLoader } from &quot;three/examples/jsm/loaders/DRACOLoader&quot;; 关于这两个加载器的介绍 GLTFLoader 用于载入glTF 2.0资源的加载器 DRACOLoader DRACOLoader：一个用于加载经过 Draco 压缩的图形库。 Draco是一个开源的库，主要用于压缩和解压缩三维模型及点云。 以客户端上解压缩为代价，显著减少压缩的图形。 2.结合使用123456789const loader = new GLTFLoader();const dracoLoader = new DRACOLoader();dracoLoader.setDecoderPath(&quot;/static/draco/&quot;);// 使用js方式解压dracoLoader.setDecoderConfig({ type: &quot;js&quot; });// 初始化_initDecoder 解码器dracoLoader.preload();loader.setDRACOLoader(dracoLoader); 在这里就需要进行很多操作了，首先先说下这段代码的意思 setDecoderPath：设置解压的路径，这里不是模型的路径，而是采用哪种压缩的方法（我的理解） 然后再进行 js 方式解压，并初始化 Decoder 解码器，最后将初始化好的 dracoLoader 加载器作为 gltf 加载器，这样能提高浏览器响应 那么对应的操作是什么？先看我的文件目录 当时我的 glb 文件就是加载不上，所以听从了网上的建议，将对应的 glb 文件放在static文件夹中，但是我用的 vue2，所以只能新建一个了，说明我的模型文件为静态文件，不需要进行对应的打包，然后将里面的gltf 里面的文件和 gltf 整个文件夹放在 draco 里面，至于怎么在 draco 的文件里面，因为当时我们设置的DecoderPath就是在 static 文件下的 draco 文件夹下，我们需要使用到 draco 里面的文件，自然而然就放到 draco 文件夹下。 3.加载模型当上面都设置好了之后，那就没什么问题了吧？？？ 错错错！精彩才刚刚开始！！！ 因为模型的路径问题，我耗费了整整小一天（也许是我太废物了） 步入正题，首先需要确认模型放在哪？ 我们在上面创建了 static 文件夹，再创建data文件夹，将我们的 glb 文件放在我们data文件夹中 然后我们为我们 glb 资源文件创建一个对象 1234567891011const carModel = [ { name: &quot;EXT&quot;, path: &quot;/static/data/lynkco09/model/Lynkco09_EXT_d.glb&quot;, }, { name: &quot;INT&quot;, path: &quot;/static/data/lynkco09/model/Lynkco09_INT_d.glb&quot;, }, ... ]; 这块问题就很多了，我最先开始不知道将 glb 文件放在 static/data 文件夹下，走了很多坑，一直在试，主要也很奇怪，我用其他的 glb 文件没有问题，但是就是用这个车模的 glb 文件出了问题，所以一直在试错阶段。第二个问题就是资源文件的前缀，要加上/static，我在网上找了很多教程都是不加的，反正也没看到有加的，没加的时候我的资源文件就是不好用的，但是在加了之后，我的 glb 资源文件就可以通过 three.js 渲染出来了，很神奇~ 写到这，其实问题大差不差就解决好了，就是运用 group 将各个 glb 资源文件通过加载器加载，然后组合成一个 model，组合之后放在 scene 里面就行了。最后的代码是这样的 12345678const model = new THREE.Group(); //声明一个组对象，用来添加加载成功的三维场景carModel.forEach((item) =&gt; { loader.load(item.path, (gltf) =&gt; { console.log(gltf); model.add(gltf.scene); });});return model; 让我们看一下最后的渲染结果： 至于为什么问题这么多还加载这个模型，一是踩坑有经验，二是这个车模比较帅哈哈","link":"/2024/02/29/3th-3/"},{"title":"three.js-创建渲染器renderer","text":"到这里，我们所需要的环境 scene（物体在环境中）、看这个三维世界的眼睛 Camera 都有了，但是我们还差一步，就是对这个世界的感受和渲染，这时候就需要 renderer 了 WebGL 渲染器WebGLRenderer通过 WebGL 渲染器WebGLRenderer (opens new window)可以实例化一个 WebGL 渲染器对象。 12// 创建渲染器对象const renderer = new THREE.WebGLRenderer(); 设置 Canvas 画布尺寸.setSize()1234// 定义threejs输出画布的尺寸(单位:像素px)const width = 800; //宽度const height = 500; //高度renderer.setSize(width, height); //设置three.js渲染区域的尺寸(像素px) 但是通过这种方法的话，当窗口大小发生变化的时候，渲染区域不进行变化，这时候在调用 BOM 方法就好了，示例代码： 123456//当窗口变化的时候，窗口实时渲染window.onresize = function () { renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();}; 渲染器渲染方法.render()渲染器WebGLRenderer执行渲染方法.render()就可以生成一个 Canvas 画布(照片)，并把三维场景 Scene 呈现在 canvas 画布上面,你可以把.render()理解为相机的拍照动作“咔”。 1renderer.render(scene, camera); //执行渲染操作 因为是在场景和相机上进行渲染的，所以里面的参数分别是scene和Camera 渲染器 Canvas 画布属性.domElement渲染器WebGLRenderer通过属性.domElement可以获得渲染方法.render()生成的 Canvas 画布，.domElement本质上就是一个 HTML 元素：Canvas 画布。 1document.body.appendChild(renderer.domElement); 我们在网页看 3D 的背景的时候，我们看里面的 HTML 节点都会发现有 canvas 节点 我们除了放在 body 节点下，我们也可以直接插在其他的 DOM 节点下 Canvas 画布插入到任意 HTML 元素中12&lt;div id=&quot;webgl&quot; style=&quot;margin-top: 200px;margin-left: 100px;&quot;&gt;&lt;/div&gt;document.getElementById('webgl').appendChild(renderer.domElement);","link":"/2024/02/28/3th-5/"},{"title":"three.js-创建相机camera","text":"我们通过眼睛去看这个世界，当然当我们去渲染我们的三维场景的时候也需要一个“眼睛”去将这个三维场景渲染出来，所以这个时候相机 camera 就起作用了，充当这个三维世界的眼睛 透视投影相机 PerspectiveCameraThreejs 提供了正投影相机OrthographicCamera (opens new window)和透视投影相机PerspectiveCamera (opens new window)关于这两个相机的介绍 正投影相机 这一摄像机使用orthographic projection（正交投影）来进行投影。 在这种投影模式下，无论物体距离相机距离远或者近，在最终渲染的图片中物体的大小都保持不变。 透视投影相机 这一摄像机使用perspective projection（透视投影）来进行投影。 这一投影模式被用来模拟人眼所看到的景象，它是 3D 场景的渲染中使用得最普遍的投影模式。 12// 实例化一个透视投影相机对象const camera = new THREE.PerspectiveCamera(); 实例方法相机位置.position生活中用相机拍照，你相机位置不同，拍照结果也不同，threejs 中虚拟相机同样如此。 比如有一间房子，你拿着相机站在房间里面，看到的是房间内部，站在房子外面看到的是房子外面效果。 相机对象Camera具有位置属性.position，通过位置属性.position可以设置相机的位置。 123//相机在Three.js三维坐标系中的位置// 根据需要设置相机位置具体值camera.position.set(200, 200, 200); 相机观察目标.lookAt()你用相机拍照你需要控制相机的拍照目标，具体说相机镜头对准哪个物体或说哪个坐标。对于 threejs 相机而言，就是设置.lookAt()方法的参数，指定一个 3D 坐标。 1234//相机观察目标指向Threejs 3D空间中某个位置camera.lookAt(0, 0, 0); //坐标原点camera.lookAt(0, 10, 0); //y轴上位置10camera.lookAt(mesh.position); //指向mesh对应的位置 透视投影相机PerspectiveCamera：视锥体透视投影相机的四个参数fov, aspect, near, far构成一个四棱台3D 空间，被称为视锥体，只有视锥体之内的物体，才会渲染出来，视锥体范围之外的物体不会显示在 Canvas 画布上。 这就好比，我们正在向前面看的时候，既不能看到脚下有什么，也不能看到极远处有什么。 12345// width和height用来设置Three.js输出的Canvas画布尺寸(像素px)const width = 800; //宽度const height = 500; //高度// 30:视场角度, width / height:Canvas画布宽高比, 1:近裁截面, 3000：远裁截面const camera = new THREE.PerspectiveCamera(30, width / height, 1, 3000); PerspectiveCamera参数介绍： 1PerspectiveCamera(fov, aspect, near, far); 参数 含义 默认值 fov 相机视锥体竖直方向视野角度 50 aspect 相机视锥体水平方向和竖直方向长度比，一般设置为 Canvas 画布宽高比 width / height 1 near 相机视锥体近裁截面相对相机距离 0.1 far 相机视锥体远裁截面相对相机距离，far-near 构成了视锥体高度方向 2000","link":"/2024/02/28/3th-4/"},{"title":"生活小记-所想所记3-6","text":"0b2f4e5d6eec5d3dd7df5050da23c5c44739b64c9ecfc068d86ca413ab32bb26164bafc552ed0f378cd6fb1dd0e3f95b227797b8ef9691f3b0904d142a99d5e009cb7281019c5fd101e1420404ba9ad1a22736d707c142e2a41a65493ded92f22ced2e1bff9335836fee727cbf9e11d475a57adbd257cdac59ecdeeb16d767a27743088a8f9664e49d2df4c5c298303a560a9f3eb9b8b109cc5dc3436dbd4b3c786f25c8bb5752cb11208d537ea9ff6c95301ea11e88ecd5e07651d926c9dd558663369dce2a5063fe35d45fb6b9cf7fff9266846752b986f0eda4189951ff77fc218cef99fe1f16e385982d5d1da262dc59f5c657c1ca3958cc1dfd2b83138a5c86a07f84856bd66324957fc8c01f8ecf29c7e448c3b2cfc77a1b7df84c4c49207d3da7a4c293af44eabf5fe983a2568774bfd628d639b1834f3b732be197c9e2f41b9687d0e8f17ba9f7e8cf90ac5a605503992ef27aadac713499e08e5c3f19e56503252f8ce85a8f33d2e8b18f83b1631d234c623912e284cac3cc19f53c7a02bcd2eeea76cafa108be5bb849d84bbe8c1fcefb346a8c67d35c4fd8a30acff55546af7f58c9ee26c644e2835a50be93d1f5a0f3b5148ee80eb4a335fcd2c3e7bf9ec7f414bd5121b45ebcc98e7cfba817db6c88fa50db6048becc46a1624f14f830348a7555b478a51a3b95dac9288e53f820bcee467e7b20dd9186e696dbaf68b257566d033a6fa494d229a072f9ae1ae3feb3962f53a654ed73e7877ce40734c23be622a357d1c03ca00131354442942eea925abb50ac3f3b2758bdf329a68804ffd3a9085b36fa45f430376b41451c103943f3bdc680748cb713df4d9912c73ed22219d8717fd6e90fe50d67f5f15211f3e9beb353670cbe92e3019041e05e753d6a66fe3dbe4f0556c28f6ee7181941c2f00e73e6ebc7cd84b897f8e3bac86d3e22b97ecb16dd7417d1f7e04722889d983adea3c8bd3c8edda1f1ad12fc0910b3549ba19fc05779d893061ac457a36334d3ba0c77a8a3ed66c5bd9b46df9b904c7b11141f6525664587f0c910491e10307021ef5a035226849ba450854dd90bbb9237b24c0c9087e793d73492e01179a614f1dde7a0274f4bfc9c2dbb0a7c480fab72c398d6c556392322f3d37660459443b90e1eeb810c01652bae94b3c94cbdc8a1aeca9702407cbf2e980853ac16b0c05d749edc11e6e4235c20d9ff4103eb7b210ef71a9b0d599ec36ba9b2dd2971a42f3108e2f40a1af8e677ed0e3a479515216bfda979647b68b2cffa1609cf861b2657678aa5f126374343b644f1ec8cdc162eb8e14768826c85343e3f0079c78c99273bca64a40078a58da042a804afd21d6691b60e8a69ce673b005e7202a8851aa93baffedd7d482d7ad1933c38f57ef7f0e1e8090f9ea0d674bcf81ce6d931c24ab199721b430e5e26ee0ea52a774da48f6c3848421405647cc96eff78332c990d0b1054f541fe9043ceac113b71f4c04664959db7612117b596fbfa5ad733a784951c6438ae111c3804cf4a5173e75ee788f889fb3821f12308bc1647a477868cc5a0bf1a2379dc05ad188e2f179c7c7e4d1733774c95ffbc9187a078f1c4894dec7b307819d9b4b860d87e864b36df78326b8466440fb8c8722019b3ddb042a75096db6ab42afd9a66903254d917229c974d05fca820f79939d056d20b0401e237890d8ebb8e1b36845930759f8437b747e6bcb02cf2db5cb23f115ffeba642c553ad760f9adab1495e4c2f01f4211a7223e31f61180ed5ec272e0c7604815cd6f4c7bac7cd11e05da672ebf15058977a34d64aff5b021e0b2b3c120b3e2097a2fa89fc85318ebf89692a9426daf9d7b05e8db56e5aaad17eae50ed5620098919d16c494d9aab1b7b862c9af148d84dcc35b2dd17669a85be916af1e5700e8d2e6c5716083831dab159357e80f1bcd36d710b9e9a4766f8b5264af79f90157d87d231329081c67365a542e481112f24056e09f5254f10e250c60e0cba7e4addcde33a8df96eb08afd4f9d9224260526c8c08b29ed7b1dd9974137330e6ac4c0702a53ef3f932871a3491e19c8edfe5586af3df88e48e292f247897ab88e1ae4ccdf2b535a822b33ae9f86156415dd35afaaa13b8fb969e9b3b08f7a7874d676e5c8f08b5d6b2238d32a5395ec17bd597b514ec1fe22cbf32675aa89c021966677dc8b4a6307dad79f2843823c1b70b36274c4b4dfa8a05772eccbd358726b6835eb3f59a91daea26199b2ea0a34120165705452a6baed47ed0362c0fa1754379e26876624571dc50fde65af92421bdeb61f9d282466bb3a168a4437d407b2852afe3e9811f8753b99d33d8466f7ae8830430aef9f72b8dea528d7f916ef98c5f8a4f203d903bd1702ab96f83a6fa50b36f42915445ff44e7877f952da90fa4338f972e265f6a45b1502ba187d4dd9790634667db7b77e8513d462bac195078994f4097730ee890eb2433380f581073482ac70a008f5cdeb12129537dd9786dabfb17c2606ae287dea8823ce496d1c1c22eb0e8d8d4d4b519dcabdf11968c1afc0d09846eaa2eba48a529d31198f8961b35d3821d953763ae3adad0ea3f15a1121e0859c8d1913a343 请输入密码","link":"/2024/03/06/4sh-3/"},{"title":"生活小记-所想所记3-11","text":"0b2f4e5d6eec5d3dd7df5050da23c5c48069d06e8251935a3460c26e532f47496d6d8bcf7ee954733572ad06e3371a6207440eaa72c3ecd416e2bee13d8184b924a4a3434d7934e415b5f524bed91bdf0c1a0459e5728373e8028c2af69ff3d8a61784d8b0a075164e400aaaf394939bced1796d56b0f03fde3efbfce6b54fbbe2ee57e1738c58950177c84c0ee0a0ec86503ee77c716c203e4377774b8644fa4d2e886959c9108fdedf4815b4d35edc40ffbf1eaaace0b7489e201b1d9966b5d3ff184222da7a156f8898cab88b406fb2dbd120ae2a3018775444e9ce6bed386e5372522fb9cbd9fb261d4ca8447b26a8aed67205ca93ce4657e7372aaa6b1bff48a643c254dcdb9b41a31080ad28d7dddc2eda5691dc8b2e5a68920edd67364590403e6300a716eb745f31af60cb65554d1c01e7a6f365d62db71ac6cc8fffcfc5845f04567a4394a5b8e1476bd9e8c8b5c5620e66120f78f0d3fbde07f612033bca278eead4ac3067f98ca6da356180e2b1f7aed2a522c8c536e684b0af2ec77353decd201e9929112192d098db5c3427187c433ca20f4b8d6bb9034643ac4062471a4280fd2121bea721bd17dfca3331895270f35f7c0d00725c10bde90df2e217f71ce939c0551376a0cd79eacec96b540ee5d90ea7c5b3a1209f139780da291c048dfe70c3fd4addd0fbb9c760e7e0e7b5a2394ce0e719c6ea7d5093382470322ba89b978664a81e89548c82386320908338451831b174fa905a1d1a0a8813c8fa5ef2f7b59817e44b96d0c6c286772ec93743a79a0e8663f5963960c7e50c0eca2daa358533317e17ee91e452540743640ca7494e4cce5fcd07d349a917577699ba278293e476d5267fca2ee23dad0937aba9b67eddbaafcc55f6c93678a44e008ff27d95ca4119eee82e993019f3ea6c8d46c43c52ad16477255c521e469f78a008fbc7978f0a706a3cc3b3d63453e7629e28f0431c66eb5a7f85669e8c24f76bb669d9f953b0d79beafe5abfcd46eb93524ebe353be62ae2b6c108034bd96fa21c10eae7753d068f2b04e3865853865d3b0d49d52a42577837d889b9db107391f1df94b6ee76d3e5cd80972f0556576e20420a7dd6f48e11e43e719477c5331a9c633e840251f5255a584040717810914101e49b0045021c11eccb7f25e85ffd3556216232c878a28eaa86840eaf028258eed858b98de2f64fbd132bb3ad3922900919d0b59aa3db89ee24f11af91e085635f04acb398bd6710cd7272d57e68630582dd654b4ae9d7716362524671642f64d1409d19d8d4c100002e6f1bf10b816ba60208e45c8b6d5d287dacf185d707ce10186d3c8096eb24c3b72af51ec28d90c2d4272fd37d0a15e0c23d85612329cdf42138e5906c46973927aac6842c1b656b5836d65b5b66d87729e503f1f9be25e6a9b6c024060ad3d008e499663a9fba637892f9cde01140df04ba4eb92bd0ba79becb18d5443e5e7624ad33b1bd73c318411155e5079bc78953a9b31d070085504435e3e4a4d640e96b5e9fb4069795b9ba853ab91d3cd7684fed3f48125bc7d1ffc54b874432cf7b9a405f49c90b799ba47f4c09e4b3f19f39e96ec23571115abcdb7a6cacef856d3709f640622399943d5e221445ab56a170 请输入密码","link":"/2024/03/11/4sh-4/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"three.js","slug":"three-js","link":"/tags/three-js/"},{"name":"生活小记","slug":"生活小记","link":"/tags/%E7%94%9F%E6%B4%BB%E5%B0%8F%E8%AE%B0/"}],"categories":[{"name":"效果实现","slug":"效果实现","link":"/categories/%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"three.js","slug":"three-js","link":"/categories/three-js/"},{"name":"生活小记","slug":"生活小记","link":"/categories/%E7%94%9F%E6%B4%BB%E5%B0%8F%E8%AE%B0/"}],"pages":[]}