{"posts":[{"title":"第一篇博客当然是HELLO WORLD","text":"","link":"/2024/02/15/hello-world/"},{"title":"歌词滚动效果的实现","text":"话不多说，先看效果图： 歌词随着时间进行变化，那这种效果我们应该怎么去做呢？实现的思路又是怎样的呢？ 1.先找需要的材料我把材料发放在了网盘里，大家通过链接获取，里面有对应的 mp3 文件及数据 链接：https://pan.baidu.com/s/1RdDty0ctUl3k-7o-43-0nw?pwd=388p提取码：388p 2，对得到的资料进行分析，进行数据处理 这个是我们获取到的数据，由于我是在 vue2 项目里面做的，所以我用了 export 将需要的数据引出，然后在对应的页面进行处理 那么问题来了：我们需要的数据是什么？什么样的数据我们才能让歌词与时间联系起来？ answer：其实就是歌词对应在 MP3 文件中对应的播放时间，所以我们需要获取对应歌曲每句歌词所对应的时间 接下来，我们在对应的文件中引入我们歌曲数据 1import lrcSong from &quot;../assets/js/song&quot;; 然后对取到的数据进行处理：将取到的歌词数据变成对象数组 对于取到的数据，我们只需要 lyric 部分，这部分是每句歌词对应的时间的字符串 由于我们取到的数据是字符串形式的，所以需要对字符串进行拆分，理由很简单，我们最后需要的数据是字符数组的形式 所以parseLrc(lrcSong)函数是对取到的数据变换成对象数组的函数，其中调用了parseTime函数，这个函数是我们用来将字符串的时间转换成秒数的格式， 1234567891011121314151617181920212223parseLrc(lrcSong) { let songdata = lrcSong.parseLrc(lrcSong) { let songdata = lrcSong.lyric; let songArr = songdata.split(&quot;\\n&quot;); let result = []; for (var i = 0; i &lt; songArr.length; i++) { // console.log(songArr[i]); let str = songArr[i]; var parts = str.split(&quot;]&quot;); let timeStr = parts[0].substring(1); let obj = { time: this.parseTime(timeStr), words: parts[1] }; result.push(obj); } this.song = result; //我们最后需要的数组对象，如果用纯js的话，那就直接return就行，最后找个变量接收 }, // 处理时间问题 parseTime(time) { let resultArr = time.split(&quot;:&quot;); return +resultArr[0] * 60 + +resultArr[1]; }, 通过这两个函数对数据的处理，我们最后得到了一个对象数组，打印出来是这样的： 3.联系 dom 元素，将歌词填充到 dom 元素里面HTML 的代码 12345678910&lt;div&gt; &lt;!-- 这种做法不能播放 --&gt; &lt;!-- &lt;audio src=&quot;../assets/1480251493.mp3&quot; controls&gt;&lt;/audio&gt; --&gt; &lt;audio controls&gt; &lt;source src=&quot;../assets/1480251493.mp3&quot; /&gt; &lt;/audio&gt; &lt;div class=&quot;container&quot;&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 注：先开始写的时间第一中 audio 的写法不能播放，第二种写法就可以，实战的时候需要注意一下 我们将处理好的数据放入到对应的 dom 元素里面 所以我们先获取 dom 元素 12345678getDom() { let tempdom = { audio: document.querySelector(&quot;audio&quot;), ul: document.querySelector(&quot;.container ul&quot;), container: document.querySelector(&quot;.container&quot;) }; this.doms = tempdom;//如果用纯js的话，那就直接return就行，最后找个变量接收 }, 这样的话，我们就获取到了我们的 dom 元素，下一步就是将歌词填充到对应的 ul 标签 12345678910111213// 创建歌词元素 createLi() { // 为了提高效率，采用文档片段，因为这种做法不涉及reflow，对浏览器渲染主线程不影响 let temp = document.createDocumentFragment(); let data = this.song; for (var i = 0; i &lt; data.length; i++) { let li = document.createElement(&quot;li&quot;); li.textContent = data[i].words; console.log(data[i].words); temp.appendChild(li); } this.doms.ul.appendChild(temp); }, 通过这种方法我们就将歌词填充到了 ul 标签中这样我们就可以看到 ul 里面 li 了 样式代码： 1234567891011121314151617181920212223242526* { margin: 0; padding: 0;}body { background-color: #000000; color: #666; text-align: center;}audio { width: 420px; margin: 30px 0;}.container { overflow: hidden; height: 420px;}.container ul { transition: 0.8s; list-style: none;}.container li { height: 30px; line-height: 30px; transition: 0.2s;} 现在我们将歌词放入到 ul 标签了，最后一步也就是最重要的，我们如何与 mp3 文件进行联系，形成滚动效果呢？ 4.将歌词与时间联系起来首先我们需要完成一个工作，就是需要知道什么时间到了哪句歌词 1234567891011// 看歌词到了那个位置 findindex() { let data = this.song; let currentTime = this.doms.audio.currentTime; for (var i = 0; i &lt; data.length; i++) { if (currentTime &lt; data[i].time) { return i - 1; } } return data.length - 1; }, 让 audio 当前播放时间与处理好的数据进行对比，获取对应的 index，这样我们就知道当前唱到了第几局句歌词 我们获取到了第几句歌词之后，我们就对歌词进行样式渲染了，就实现我们想要的滚动效果了 在实现这个之间，我们需要思考一个问题，滚动的效果是怎么实现的呢？ 看这张图，我们可以知道，其实就是 ul 标签的滚动，container 位置不进行变化，让 ul 标签向上移动，使得两个元素产生相对移动，形成这种滚动的效果，所以我们对于偏移值的把握是十分重要的 1234567891011121314151617181920212223setOffsetAndliStyle() { let containerHeight = this.doms.container.clientHeight; let liheight = this.doms.ul.children[0].clientHeight; let index = this.findindex(); let maxOffset = this.doms.ul.clientHeight - containerHeight; let offset = liheight * index + liheight / 2 - containerHeight / 2; if (offset &lt; 0) { offset = 0; } if (offset &gt; maxOffset) { offset = maxOffset; } let li = this.doms.ul.querySelector(&quot;.active&quot;); if (li) { li.classList.remove(&quot;active&quot;); } li = this.doms.ul.children[index]; if (li) { li.classList.add(&quot;active&quot;); } console.log(offset); this.doms.ul.style.transform = `translateY(-${offset}px)`; }, 当我们实现 ul 移动的时候，移动的多少是一个问题，还要考虑对应的临界值 偏移值的计算： 蓝线就是代表当前高亮显示的标签到 ul 元素顶部的距离 1liheight * index + liheight / 2 棕线就是代表container 元素的一半 这样我们就可以计算出偏移值了 1let offset = liheight * index + liheight / 2 - containerHeight / 2; 但现在还没有结束，我们还需要对偏移值判断 123456if (offset &lt; 0) { offset = 0;}if (offset &gt; maxOffset) { offset = maxOffset;} 这里面的 maxOffset 是最大的偏移值，代表到了最后一句歌词的位置不能上移了，凭个人喜好，加不加都可 那么我们就差最后一步对li 标签的渲染了 12345678let li = this.doms.ul.querySelector(&quot;.active&quot;);if (li) { li.classList.remove(&quot;active&quot;);}li = this.doms.ul.children[index];if (li) { li.classList.add(&quot;active&quot;);} active 样式 1234.container li.active { color: #fff; transform: scale(1.4);} 这样我们就做好歌词的滚动效果了！下面是我的源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152&lt;template&gt; &lt;div&gt; &lt;!-- &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; --&gt; &lt;!-- 这种做法不能播放 --&gt; &lt;!-- &lt;audio src=&quot;../assets/1480251493.mp3&quot; controls&gt;&lt;/audio&gt; --&gt; &lt;audio controls&gt; &lt;source src=&quot;../assets/1480251493.mp3&quot; /&gt; &lt;/audio&gt; &lt;div class=&quot;container&quot;&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import lrcSong from &quot;../assets/js/song&quot;;export default { name: &quot;HelloWorld&quot;, data() { return { song: [], doms: {}, currentIndex: -1, }; }, mounted() { this.parseLrc(lrcSong); this.getDom(); this.createLi(); this.audioStart(); }, methods: { parseLrc(lrcSong) { let songdata = lrcSong.lyric; let songArr = songdata.split(&quot;\\n&quot;); let result = []; for (var i = 0; i &lt; songArr.length; i++) { // console.log(songArr[i]); let str = songArr[i]; var parts = str.split(&quot;]&quot;); let timeStr = parts[0].substring(1); let obj = { time: this.parseTime(timeStr), words: parts[1], }; result.push(obj); } this.song = result; console.log(this.song); }, // 处理时间问题 parseTime(time) { let resultArr = time.split(&quot;:&quot;); return +resultArr[0] * 60 + +resultArr[1]; }, // 获取dom getDom() { let tempdom = { audio: document.querySelector(&quot;audio&quot;), ul: document.querySelector(&quot;.container ul&quot;), container: document.querySelector(&quot;.container&quot;), }; this.doms = tempdom; }, // 创建歌词元素 createLi() { // 为了提高效率，采用文档片段，因为这种做法不涉及reflow，对浏览器渲染主线程不影响 let temp = document.createDocumentFragment(); let data = this.song; for (var i = 0; i &lt; data.length; i++) { let li = document.createElement(&quot;li&quot;); li.textContent = data[i].words; console.log(data[i].words); temp.appendChild(li); } this.doms.ul.appendChild(temp); }, // 看歌词到了那个位置 findindex() { let data = this.song; let currentTime = this.doms.audio.currentTime; for (var i = 0; i &lt; data.length; i++) { if (currentTime &lt; data[i].time) { return i - 1; } } return data.length - 1; }, setOffsetAndliStyle() { let containerHeight = this.doms.container.clientHeight; let liheight = this.doms.ul.children[0].clientHeight; let index = this.findindex(); let maxOffset = this.doms.ul.clientHeight - containerHeight; let offset = liheight * index + liheight / 2 - containerHeight / 2; if (offset &lt; 0) { offset = 0; } if (offset &gt; maxOffset) { offset = maxOffset; } let li = this.doms.ul.querySelector(&quot;.active&quot;); if (li) { li.classList.remove(&quot;active&quot;); } li = this.doms.ul.children[index]; if (li) { li.classList.add(&quot;active&quot;); } console.log(offset); this.doms.ul.style.transform = `translateY(-${offset}px)`; }, audioStart() { this.doms.audio.addEventListener(&quot;timeupdate&quot;, this.setOffsetAndliStyle); }, },};&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style&gt;* { margin: 0; padding: 0;}body { background-color: #000000; color: #666; text-align: center;}audio { width: 420px; margin: 30px 0;}.container { overflow: hidden; height: 420px; /* border: 2px solid #fff; */}.container ul { transition: 0.8s; list-style: none;}.container li { height: 30px; line-height: 30px; transition: 0.2s;}.container li.active { color: #fff; transform: scale(1.4);}&lt;/style&gt; 这个 demo 是结合 vue2 做的，如果用纯 js 做的同学简单改一下变量就可以，里面的方法思路都是适用的~","link":"/2024/02/21/1-gd/"},{"title":"算法知识1-时空复杂度","text":"时间复杂度时间复杂度就是用来方便开发者估算出程序的运行时间，（这里我们默认 CPU 的每个单元运行消耗的时间都是相同的），假设算法的问题规模为 n，那么操作单元数量便用函数 f(n)来表示】 12345for(i=1; i&lt;=n; ++i){ j = i; j++;} 通过「 大 O 符号表示法 」，这段代码的时间复杂度为：O(n) ，为什么呢? 在 大 O 符号表示法中，时间复杂度的公式是： T(n) = O( f(n) )，其中 f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：算法的渐进时间复杂度。，简称时间复杂度，记为 O(f(n)) 常见的时间复杂度量级有： 常数阶 O(1) 对数阶 O(logN) 线性阶 O(n) 线性对数阶 O(nlogN) 平方阶 O(n²) 立方阶 O(n³) K 次方阶 O(n^k) 指数阶(2^n) 上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。 常数阶 O(1) 无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是 O(1)，如： 12345int i = 1;int j = 2;++i;j++;int m = i + j; 线性阶 O(n) 这个在最开始的代码示例中就讲解过了，如： 12345for(i=1; i&lt;=n; ++i){ j = i; j++;} 这段代码，for 循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的，因此这类代码都可以用 O(n)来表示它的时间复杂度。 对数阶 O(logN) 还是先来看代码： 12345int i = 1;while(i&lt;n){ i = i * 2;} 从上面代码可以看到，在 while 循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环 x 次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(logn) 线性对数阶 O(nlogN) 线性对数阶 O(nlogN) 其实非常容易理解，将时间复杂度为 O(logn)的代码循环 N 遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了 O(nlogN)。 就拿上面的代码加一点修改来举例： 12345678for(m=1; m&lt;n; m++){ i = 1; while(i&lt;n) { i = i * 2; }} 平方阶 O(n²) 平方阶 O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。举例： 12345678for(x=1; i&lt;=n; x++){ for(i=1; i&lt;=n; i++) { j = i; j++; }} 这段代码其实就是嵌套了 2 层 n 循环，它的时间复杂度就是 O(n*n)，即 O(n²)如果将其中一层循环的 n 改成 m，即： 12345678for(x=1; i&lt;=m; x++){ for(i=1; i&lt;=n; i++) { j = i; j++; }} 那它的时间复杂度就变成了 O(m*n) 立方阶 O(n³)、K 次方阶 O(n^k) 参考上面的 O(n²) 去理解就好了，O(n³)相当于三层 n 循环，其它的类似。 指数阶(2^n) 斐波那契数列 递归算法 1234567long aFunc(int n) { if (n &lt;= 1) { return n; } else { return aFunc(n - 1) + aFunc(n - 2); }} 求解 F5 依赖 F4 和 F3 ，我们把 F5 作为树的根节点， F4 和 F3 作为左右两个叶子节点，继续向下递归，左节点 F4 继续向下分解为 F3 和 F2 ，右节点 F3 继续向下分解为 F2 和 F1 ，依此类推，如下图所示： 因此，该算法的时间复杂度为 $$O(2^n)$$ 递归性能优化 12345678910111213定义容器存放计算结果函数F（int n){ if (n &lt;= 1){ return 1; } if (n 在容器中有结果){ return 容器中对应n的值 } else {//没查到 结果 = F(n - 1) + F(n - 2); 容器[n] = 结果; return 结果; }} 优化后的程序相当于给之前的递归树做了剪枝操作，相同的节点仅执行一次，因此时间复杂度降为 $$O(n)$$ 循环解法 如果说前面的递归解法是自顶向下将大问题拆解成小问题求解，那么循环解法则是逆向思维，自底向上，先求出小问题的解，再向上一步一步向上求取最终问题的解。 求解过程分为 n 步，将每一步的结果保存在列表中对应下标的位置，代码如下。 12345678int n; cin &gt;&gt; n; int fibs[n] = {0}; fibs[0] = fibs[1] = 1; for (int i = 2; i &lt;= n; i ++){ fibs[i] = fibs[i - 1] + fibs[i - 2]; } cout &lt;&lt; fibs[n - 1]; 时间复杂度分析 单层循环，时间复杂度为 O(n) ，与优化后的递归解法复杂度相当。 性能优化 时间复杂度已经没有优化空间了，但可以使用两个临时变量替换掉长度为 n 的列表，使空间复杂度从 O(n) 降为 O(1) 。代码如下： 12345678910int n; cin &gt;&gt; n; int fibs_a = 0; int fibs_b = 1; for (int i = 2; i &lt;= n; i ++){ int temp = fibs_b; fibs_b = fibs_a + fibs_b; fibs_a = temp; } cout &lt;&lt; fibs_b; 缺点就是如果取小于 n 对应的斐波那契的数时候，又需要重新计算 空间复杂度既然时间复杂度不是用来计算程序具体耗时的，那么我也应该明白，空间复杂度也不是用来计算程序实际占用的空间的。 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。 空间复杂度比较常用的有：O(1)、O(n)、O(n²)，我们下面来看看： 空间复杂度 O(1) 如果算法执行所需要的临时空间不随着某个变量 n 的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)举例： 12345int i = 1;int j = 2;++i;j++;int m = i + j; 代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1) 空间复杂度 O(n) 我们先看一个代码： 123456int[] m = new int[n]for(i=1; i&lt;=n; ++i){ j = i; j++;} 这段代码中，第一行 new 了一个数组出来，这个数据占用的大小为 n，这段代码的 2-6 行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)","link":"/2024/02/22/2sf-1/"},{"title":"算法知识2-C++和Java算法常用方法","text":"&lt;标语&gt; &lt;以下是竞赛中常用的方法，不管是蓝桥杯还是天梯赛都是很常用的方法，所以放在了第二节，比较基础也比较重要&gt; 🔨JAVA📝 字符串 string1234567891011String sl =&quot;hello world&quot;;// 获取s1[2]中的字符char c = sl.charAt(2);char[] chars = sl.toCharArray();chars[1] ='a';String s2 = new String(chars);// 输出: hallo worldSystem.out.printin(s2);//注意，一定要用equals 方法判断字符串是否相同if (sl.equals(s2)) {// s1和s2相同] else [// s和s2不相同//字符串可以用加号进行拼接String s3 = sl +“!&quot;;// 输出: hello world!System.out.printin(s3); Java 的字符串不能直接修改，要用 tocharArray 转化成 char[]类型的数组后进行修改，然后转换回 string 类型 v另外，虽然字符串支持用+进行拼接，但是效率并不高，不建议在 for 循环中使用如果需要进行频繁的字符串拼接，推荐使用 stringBuilder 12345StringBuilder sb = new StringBuilder();for (char c='a';c&lt;='f'; c++)sb.append(c);// append 方法支持拼接字符、字符串、数字等类型sb.append( ' g' ) . append( &quot;hij&quot; ) .append(123) ;String res = sb.toString(); // 输出:abcdefghij123;System.out.printin(res) 📝 动态数组 ArrayList12345678910//初始化一个存储String 类型数据的动态数组ArrayList&lt;String&gt; nums = new ArrayList&lt;&gt;();//判断数组是否为空boolean isEmpty()//返回数组中元素的个数int size()//返回索引index的元素E get(int index)//在数组尾部添加元素eboolean add(E e) 📝 双链表 LinkedList1234567891011121314151617//初始化一个存储 int 类型数据的双链表LinkedList&lt;Integer&gt; nums = new LinkedList&lt;&gt;();//判断链表是否为空boolean isEmpty()// 返回链表中元素的个数int size()// 判断链表中是否存在元素 oboolean contains(0bject o)//在链表尾部添加元素eboolean add(E e)//在链表头部添加元素evoid addFirst(E e)//删除链表头部第一个元素E removeFirst()//删除链表尾部最后一个元素E removeLast() 📝 哈希表 HashMap1234567891011121314151617//整数映射到字符串的哈希表HashMap&lt;Integer，String&gt; map = new HashMap&lt;&gt;();//判断哈希表中是否存在键 keyboolean containsKey(Object key)//获得键 key 对应的值，若 key 不存在，则返回nullV get(0bject key)//将 key和 value 键值对存入哈希表V put(K key，V value)//如果 key存在，删除 key 并返回对应的值V remove(Object key)//获得 key 的值，如果 key 不存在，则返回 defaultValueV getOrDefault(0bject key，V defaultValue)/获得哈希表中的所有 keySet&lt;K&gt; keySet()//如果 key 不存在，则将键值对 key 和 value 存入哈希表//如果 key存在，则什么都不做V putIfAbsent(K key，V value) 📝 哈希集合 HashSet123456789//新建一个存储 String 的哈希集合Set&lt;String&gt; set = new HashSet&lt;&gt;();// 如果 e不存在，则将e 添加到哈希集合boolean add(E e)//判断元素o是否存在于哈希集合中boolean contains(0bject o)// 如果元素0存在，则删除元素 0boolean remove(0bject o) 📝 队列 Queue12345678910111213//新建一个存储String 的队列Queue&lt;String&gt; q = new LinkedList&lt;&gt;();//判断队列是否为空boolean isEmpty()//返回队列中元素的个数int size()// 返回队头的元素E peek()//删除并返回队头的元素E poll()// 将元素 e插入队尾boolean offer(E e) 📝 堆栈 Stack123456789101112Stack&lt;Integer&gt; s = new Stack&lt;&gt;();//判断堆栈是否为空boolean isEmpty()//返回堆栈中元素的个数int size()//将元素压入栈顶 E push(E item)//返回栈顶元素E peek()//删除并返回栈顶元素E pop() 🔨C++📝 动态数组类型 vector​ 所谓动态数组，就是由标准库封装的数组容器，可以自动扩容、缩容，比 C 语言中用 int[]声明数组更高级。​ 建议不要使用 C 语言中的数组，也不要用 malloc 这类函数自己去管理内存。虽然手动分配内存会给算法的效率带来一定的提升但是你要搞清楚自己是来干什么的，把精力更多地集中在算法思维上的性价比比较高 1234567891011121314151617181920vector&lt;int&gt; nums;//初始化一个大小为 n 的数组 nums，数组中的值默认都为 0vector&lt;int&gt; nums(n);// 初始化一个元素为 1、3、5的数组 numsvector&lt;int&gt; nums[1，3，5};//初始化一个大小为 n的数组 nums，其值全都为2vector&lt;int&gt; nums(n，2);// 初始化一个二维int 数组 dpvector&lt;vector&lt;int&gt;&gt; dp;//初始化一个大小为 m*n的布尔数组 dp/其中的值都为 truevector&lt;vector&lt;bool&gt;&gt; dp(m，vector&lt;bool&gt;(n，true));bool empty()//返回数组的元素个数size type size();//返回数组最后一个元素的引用reference back();//在数组尾部插入一个元素 valvoid push back (const value_type&amp; val)//删除数组尾部的那个元素voidpop back(); 📝String123456789size_t size();//判断字符串是否为空bool empty();// 在字符串尾部插入一个字符 cvoid push back(char c);//删除字符串尾部的那个字符void pop back();// 返回从索引 pos 开始，长度为 Len 的子字符串string substr (size t pos,size t len); 📝unordered_map 哈希表1234567891011unordered_map&lt;string，vector&lt;int&gt;&gt; mapping;//返回哈希表的键值对个数size type size();//返回哈希表是否为空bool empty();// 返回哈希表中 key出现的次数//因为哈希表不会出现重复的键，所以该函数只可能返回0或1//可以用于判断键 key 是否存在于哈希表中size type count (const key type&amp; key);//通过 key 清除哈希表中的键值对size type erase (const key_type&amp; key); 📝 哈希集合 unordered_set1234567891011121314//初始化一个存储 int 的哈希集合unordered set&lt;int&gt; visited;// 返回哈希集合的键值对个数size type size();// 返回哈希集合是否为空bool empty();//类似哈希表，如果 key 存在则返回 1，否则返回0size_type count (const key type&amp; key);//向集合中插入一个元素 keypair&lt;iterator,bool&gt; insert (const key type&amp; key);//删除哈希集合中的元素 key//如果删除成功则返回1，如果 key不存在则返回0size_type erase (const key_type&amp; key); 📝 队列 queue123456789101112//初始化一个存储string 的队列queue&lt;string&gt; q;//返回队列是否为空bool empty();//返回队列中元素的个数size type size();//将元素加入队尾void push (const value type&amp; val);//返回队头元素的引用.value type&amp; front();//删除队头元素void pop(); 📝 堆栈 Stack1234567891011Stack&lt;int&gt; stk；//返回堆栈是否为空bool empty();//返回堆栈中元素的个数size type size();//在栈顶添加元素void push (const value type&amp; val);//返回栈顶元素的引用value type&amp; top();//删除栈顶元素void pop();","link":"/2024/02/23/2sf-2/"},{"title":"算法知识3-数组知识及部分习题","text":"数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 ​ 1、二维数组int m[3][4]; 上述语句定义了一个 3 行 4 列的二维数组。 二维数组的定义与一维数组一样，应该遵循相同的原则。 二维数组 m 共有 12 个元素，每个元素都是 int 类型的。 这 12 个元素的下标分别是： 1234567m[0][0]、m[0][1]、m[0][2]、m[0][3]、m[1][0]、m[1][1]、m[1][2]、m[1][3]、m[2][0]、m[2][1]、m[2][2]、m[2][3]、 2、二维数组的内存映像图二维数组在内存中是一维存放的： C 语言中，二维数组中元素排列的顺序是按行存放的，即在内存中先顺序存放第一行的元素，再存放第二行的元素。 查找方法暴力法 就是枚举 12345678910111213141516171819202122232425public class Array02 { public static void main(String[] args) { int[] arr = {11,22,33,10,32,23,43,12,43}; // 找出arr这个数组中12所在的下标。 // 调用方法。 int num = 12; int index = arraySearch(arr,num); System.out.println(index == -1 ? num + &quot;元素不存在！&quot; : num + &quot;元素的下标：&quot; + index);}/** * 从数组检索某个元素的下标,返回的是第一个该元素的下标，因为for循环是从前到后的 * @param arr 被检索的数组 * @param ele 被检索的元素 * @return -1 表示该元素不存在，其他表示返回目标元素的下标。 */public static int arraySearch(int[] arr, int ele) { for (int i = 0; i &lt; arr.length; i++) { if (ele == arr[i]){ return i; } } return -1;} 二分查找对数组有要求，必须是有序数组 123456789101112131415161718192021222324252627282930313233343536373839404142public class ArrayUtil { public static void main(String[] args) { //数组需要满足什么要求？？？ int[] arr = {100,200,230,235,600,1000,2000,9999}; // 找出arr这个数组中200所在的下标。 // 调用方法。 int num = 200; int index = binarySearch(arr,num); System.out.println(index == -1 ? num + &quot;元素不存在！&quot; : num+ &quot;元素的下标：&quot; + index);}/** * 从数组中查找目标元素的下标。 * @param arr 被查找的数组（这个必须已经排序的）。 * @param dest 目标元素 * @return -1 表示该元素不存在，其他表示返回目标元素的下标。 */public static int binarySearch(int[] arr, int dest) { // 开始下标。 int begin = 0; // 结束下标. int end = arr.length - 1; // 开始元素下标只要在结束元素下标的左边，就有机会继续循环。 while(begin &lt;= end){ // 中间元素下标 int mid = (begin + end) / 2; if (arr[mid] == dest){ return mid; } else if (arr[mid] &lt; dest){ // 目标在“中间“的右边。 // 开始元素下标需要发生变化（开始元素的下标需要重新赋值）。 begin = mid + 1; // 一直增。 } else { // arr[mid] &gt; dest // 目标元素在”中间“左边 // 修改结束元素下标 end = mid - 1; // 一直减 } } return -1;} ​ 求三数之和(Three Sum)题目给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ,请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。示例： 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为： 1234[ [-1, 0, 1], [-1, -1, 2]] 暴力解法 12345678910111213141516171819202122232425/*** 循环三次，结果集使用了set集合，避免了返回值重复 */ private List&lt;List&lt;Integer&gt;&gt; directlySolution(int[] nums) { if (nums == null || nums.length &lt;= 2) { return Collections.emptyList(); } Arrays.sort(nums); //set集合去重 Set&lt;List&lt;Integer&gt;&gt; result = new LinkedHashSet&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) { for (int j = i+1; j &lt; nums.length; j++) { for (int k = j+1; k &lt; nums.length; k++) { if (nums[i] + nums[j] + nums[k] == 0) { List&lt;Integer&gt; value = Arrays.asList(nums[i], nums[j], nums[k]); result.add(value); } } } } return new ArrayList&lt;&gt;(result); } 优秀解法：O（n^2)思路 12345678910111213141516171819202122232425262728class Solution { public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList(); int len = nums.length; if(nums == null || len &lt; 3) return ans; Arrays.sort(nums); // 排序 for (int i = 0; i &lt; len ; i++) { if(nums[i] &gt; 0) break; // 如果当前数字大于0，则三数之和一定大于0，所以结束循环 if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; // 去重 int L = i+1; int R = len-1; while(L &lt; R){ int sum = nums[i] + nums[L] + nums[R]; if(sum == 0){ ans.add(Arrays.asList(nums[i],nums[L],nums[R])); while (L&lt;R &amp;&amp; nums[L] == nums[L+1]) L++; // 去重 while (L&lt;R &amp;&amp; nums[R] == nums[R-1]) R--; // 去重 L++; R--; } else if (sum &lt; 0) L++; else if (sum &gt; 0) R--; } } return ans; }} 前缀和一维数组前缀和 如果你没有了解过「前缀和」，可能会写出两重循环：每个 runningSum[i]，累加从 0 位置到 i 位置的 nums[i] 12345678910111213vector&lt;int&gt; runningSum(vector&lt;int&gt;&amp; nums) { const int N = nums.size(); vector&lt;int&gt; preSum(N, 0); for (int i = 0; i &lt; N; ++i) { int sum = 0; for (int j = 0; j &lt;= i; ++j) { sum += nums[j]; } preSum[i] = sum; } return preSum;} 两重循环的时间复杂度是 O(N^2)，效率比较低。 12345678910111213vector&lt;int&gt; runningSum(vector&lt;int&gt;&amp; nums) { const int N = nums.size(); vector&lt;int&gt; preSum(N, 0); for (int i = 0; i &lt; N; ++i) { if (i == 0) { preSum[i] = nums[i]; } else { preSum[i] = preSum[i - 1] + nums[i]; } } return preSum;} 前缀和方法优化=&gt;时间复杂度变成 O(n) 那么什么是前缀和？ 「前缀和」 是从 nums 数组中的第 0 位置开始累加，到第 i 位置的累加结果，我们常把这个结果保存到数组 preSum 中，记为 preSum[i]。 在前面计算「前缀和」的代码中，计算公式为 preSum[i] = preSum[i - 1] + nums[i] ，为了防止当 i = 0 的时候数组越界，所以加了个 if (i == 0) 的判断，即 i == 0 时让 preSum[i] = nums[i]。 事例样图 下面以 [1, 12, -5, -6, 50, 3] 为例，用动图讲解一下如何求 preSum。（只不过改个下标） 拓展：求数组的区间和利用 preSum 数组，可以在 O(1)O(1)O(1) 的时间内快速求出 nums 任意区间 [i,j][i, j][i,j] (两端都包含) 内的所有元素之和。 一维数组前缀和公式 sum(i,j) = preSum[j+1] − preSum[i] 什么原理呢？其实就是消除公共部分即 0~i-1 部分的和，那么就能得到 i~j 部分的区间和。 注意上面的式子中，使用的是 preSum[j + 1] 和 preSum[i]，需要理解为什么这么做。（如果理解不了的知识，那就记不住，所以一定要理解） preSum[j + 1] 表示的是 nums 数组中 [0,j] 的所有数字之和（包含 0 和 j）。 preSum[i]表示的是 nums数组中 [0,i−1] 的所有数字之和（包含 0 和 i−1）。 当两者相减时，结果留下了 nums数组中 [i,j] 的所有数字之和 前缀和再进阶：二维数组前缀和 帮助理解 代码展示 #include &lt;bits/stdc++.h&gt; using namespace std; const int MAXN = 1e3+2; const int MAXM = 1e3+2; int sum[MAXN][MAXM] = {}; int main() { int n,m; cin&gt;&gt;n&gt;&gt;m; int data; for (int i=1; i&lt;=n; i++) { for (int j=1; j&lt;=m; j++) { cin &gt;&gt; data; sum[i][j] = sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+data; } } for (int i=1; i&lt;=n; i++) { for (int j=1; j&lt;=m; j++) { cout &lt;&lt; sum[i][j] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } return 0; } 二维前缀和小提升：根据 preSum 求子矩形面积 帮助理解","link":"/2024/02/23/2sf-3/"},{"title":"算法知识4-二叉树知识","text":"包含递归知识以及二叉树基本的算法知识 注：递归知识主要围绕二叉树知识展开 树的介绍 树的定义树是一种数据结构，它是由 n（n&gt;=1）个有限节点组成一个具有层次关系的集合。 把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点： 每个节点有零个或多个子节点; 没有父节点的节点称为根节点; 每一个非根节点有且仅有一个父节点; 除了根节点以外，每个子节点可以分为多个不想交的子树。 树的基本术语 节点的度：节点拥有的子树的数目。 叶子：度为零的节点。 分支节点：度不为零的节点。 树的度：树中节点的最大的度。 层次：根节点的层次为 1，其余节点的层次等于该节点的双亲节点加 1。 树的高度：树中节点的最大层次。 无序数：如果树中节点的各子树之间的次序是不重要的，可以交换位置。 有序数：如果树中结点的各子树的次序是重要的，不可以交换位置。 森林：0 个或多个不相交的树组成。对森林加上一个跟，森林即成为树；删去跟，树即成为森林。 相关性质 二叉树（简单介绍） 二叉树的定义​ 二叉树是每个节点最多有两个子树的树结构。 ​ 它有五种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；活着左、右子树皆为空。 二叉树与度为 2 的树的区别 度为 2 的的树必须有三个节点以上(否则就不叫度为二了，一定要先存在)，二叉树可以为空。 二叉树的度不一定为 2,比如斜树。 二叉树有左右节点区分，而度为 2 的树没有左右节点的区分。 二叉树的基本性质 性质 1：二叉树第 i 层上的节点数目最多为 2{i-1} (i≥1)。 (01) 当 i=1 时，第 i 层的节点数目为 2{i-1}=2{0}=1。因为第 1 层上只有一个根结点，所以命题成立。(02) 假设当 i&gt;1，第 i 层的节点数目为 2{i-1}。这个是根据(01)推断出来的！下面根据这个假设，推断出”第(i+1)层的节点数目为 2{i}”即可。由于二叉树的每个结点至多有两个孩子，故”第(i+1)层上的结点数目” 最多是 “第 i 层的结点数目的 2 倍”。即，第(i+1)层上的结点数目最大值=2×2{i-1}=2{i}。 性质 2：深度为 k 的二叉树至多有 2{k}-1 个节点（k&gt;=1）。 在具有相同深度的二叉树中，当每一层都含有最大结点数时，其树中结点数最多。利用”性质 1”可知，深度为 k 的二叉树的结点数至多为：20+21+…+2k-1=2k-1 性质 3：包含 n 个节点的二叉树的高度至少为 log2 (n+1)。 根据”性质 2”可知，高度为 h 的二叉树最多有 2{h}–1 个结点。反之，对于包含 n 个节点的二叉树的高度至少为 log2(n+1)。 性质 4：在任意一颗二叉树中，若终端节点的个数为 n0，度为 2 的节点数为 n2，则 n0=n2+1。 因为二叉树中所有结点的度数均不大于 2，所以结点总数(记为 n)=”0 度结点数(n0)” + “1 度结点数(n1)” + “2 度结点数(n2)”。由此，得到等式一。(等式一) n=n0+n1+n2 另一方面，0 度结点没有孩子，1 度结点有一个孩子，2 度结点有两个孩子，故二叉树中孩子结点总数是：n1+2n2。此外，只有根不是任何结点的孩子。故二叉树中的结点总数又可表示为等式二。(等式二) n=n1+2n2+1由(等式一)和(等式二)计算得到：n0=n2+1。 二叉树的种类满二叉树高度为 h，并且由 2{h} –1 个结点的二叉树，被称为满二叉树。 ![5d6d36fbea67c9e611fbdcf9c84eca67 (1)](F:\\goole 下载\\5d6d36fbea67c9e611fbdcf9c84eca67 (1).png) 完全二叉树一颗二叉树中，只有最下面两层节点的度可以小于 2，并且最下层的叶节点集中在靠左的若干位置上。 一颗满二叉树必定是一颗完全二叉树，而完全而二叉树不一定是满二叉树。 二叉查找树 若任意节点的左子树不空，则左子树上所有的值均小于根节点的值 若任意节点的右子树不空，则右子树上所有节点的值均大于根节点的值（更大于左子树上的值） 任意节点的左、右子树也分别为二叉查找树 没有键值相等的节点 平衡二叉搜索树AVL(Adelson-Velsky and Landis)树，具有以下性质：它是一颗空树或者它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一颗平衡二叉树。 二叉树的存储方式链式存储​ 通过指针把分布在散落在各个地址的节点串联在一起，链式存储如图所示： 顺序存储​ 就是用数组来存储二叉树，顺序存储的方式如图： 数组存储的遍历 ​ 如果父节点的数组下标是 i,那么它的左孩子就是 2 _ i + 1,右孩子就是 i _ 2 + 2。（但是用链式表示的二叉树更有利于我们理解，一般都是用链式存储二叉树） 二叉树的遍历 二叉树的创建参考https://blog.csdn.net/new_aiden/article/details/50968112 前序遍历、中序遍历、后序遍历、层序遍历4 种方式。 前序遍历=&gt;根左右若二叉树非空，则执行以下操作：访问根结点；先序遍历左子树；先序遍历右子树。 123456789// 前序递归遍历 public static void preOrderRecursively(TreeNode tree) { if (tree == null) { return; } System.out.print(tree.val + &quot;\\t&quot;); preOrderRecursively(tree.left); preOrderRecursively(tree.right); } 中序遍历=&gt;左根右若二叉树非空，则执行以下操作：中序遍历左子树；访问根结点；中序遍历右子树。 123456789public static void inOrderRecursively(TreeNode tree) { if (tree == null) { return; } inOrderRecursively(tree.left); System.out.print(tree.val + &quot;\\t&quot;); inOrderRecursively(tree.right); } 后序遍历=&gt;左右根若二叉树非空，则执行以下操作：后序遍历左子树；后序遍历右子树；访问根结点。 123456789// 后序递归遍历 public static void postOrderRecursively(TreeNode tree) { if (tree == null) { return; } postOrderRecursively(tree.left); postOrderRecursively(tree.right); System.out.print(tree.val + &quot;\\t&quot;); } 层序遍历=&gt;逐层遍历，从左到右123456789101112131415161718192021// 层次遍历并顺序打印（借助队列） public static void levelOrder1(TreeNode tree) { if (tree == null) { return; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(tree); TreeNode temp = null; while (!queue.isEmpty()) { temp = queue.poll(); System.out.print(temp.val + &quot;\\t&quot;); if (temp.left != null) { queue.offer(temp.left); } if (temp.right != null) { queue.offer(temp.right); } } System.out.println(); }","link":"/2024/02/24/2sf-4/"},{"title":"算法知识5-递归算法","text":"递归 根据上述二叉树的知识，对递归知识能有更好的理解。 什么是递归？ 递归递归，一个是“递”，一个是“归”。 举个从小就听过的例子： 从前有座山，山中有座庙，庙里有个老和尚，老和尚在给小和尚讲故事：“ 从前有座山，山中有座庙，庙里有个老和尚，老和尚在给小和尚讲故事：“ 从前有座山，山中有座庙，庙里有个老和尚，老和尚在给小和尚讲故事：“ 从前有座山，山中有座庙，庙里有个老和尚，老和尚在给小和尚讲故事：“太困了不讲了”，于是都回去睡觉了。”于是都回去睡觉了。”于是都回去睡觉了。”于是都回去睡觉了。 ​ 在讲故事的过程中，可以看成一个递的过程，在“太困了不讲了”可以看成一个递的边界，接下来执行“归”的过程。所以我理解的递归无非是在边界条件前不断执行“递”的过程，在达到边界值后，执行“归”的过程。 ​ 递归的基本思想是某个函数直接或者间接地调用自身，这样原问题的求解就转换为了许多性质相同但是规模更小的子问题。求解时只需要关注如何把原问题划分成符合条件的子问题，而不需要过分关注这个子问题是如何被解决的。 递归的思想递归有三大要素 第一要素：明确你这个函数想要干什么 对于递归，我觉得很重要的一个事就是，这个函数的功能是什么，他要完成什么样的一件事，而这个，是完全由你自己来定义的。也就是说，我们先不管函数里面的代码什么，而是要先明白，你这个函数是要用来干什么。 12// 算 n 的阶乘(假设n不为0)int f(int n){} 第二要素：寻找递归结束条件 所谓递归，就是会在函数内部代码中，调用这个函数本身，所以，我们必须要找出递归的结束条件，不然的话，会一直调用自己，进入无底洞。也就是说，我们需要找出当参数为啥时，递归结束，之后直接把结果返回，请注意，这个时候我们必须能根据这个参数的值，能够直接知道函数的结果是什么。 123456// 算 n 的阶乘(假设n不为0)int f(int n){ if(n == 1){ return 1; }} 第三要素：找出函数的等价关系式 第三要素就是，我们要不断缩小参数的范围，缩小之后，我们可以通过一些辅助的变量或者操作，使原函数的结果不变。 例如，f(n) 这个范围比较大，我们可以让 f(n) = n * f(n-1)。这样，范围就由 n 变成了 n-1 了，范围变小了，并且为了原函数 f(n) 不变，我们需要让 f(n-1) 乘以 n。 说白了，就是要找到原函数的一个等价关系式，f(n) 的等价关系式为 n * f(n-1)，即 f(n) = n * f(n-1)。 12345678910111213int f(int n){ if(n == 1){ return 1; } else return n * f(n - 1);}int f(int n){ int s = 1; for (int i = 1; i &lt;= n; i ++){ s *= i; } return s;}","link":"/2024/02/24/2sf-5/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"categories":[{"name":"效果实现","slug":"效果实现","link":"/categories/%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}],"pages":[{"title":"Vue","text":"{% vueComponent helloWorld %}","link":"/vue/index.html"}]}