{"posts":[{"title":"第一篇博客当然是HELLO WORLD","text":"","link":"/2024/02/15/hello-world/"},{"title":"歌词滚动效果的实现","text":"话不多说，先看效果图： 歌词随着时间进行变化，那这种效果我们应该怎么去做呢？实现的思路又是怎样的呢？ 1.先找需要的材料我把材料发放在了网盘里，大家通过链接获取，里面有对应的 mp3 文件及数据 链接：https://pan.baidu.com/s/1RdDty0ctUl3k-7o-43-0nw?pwd=388p提取码：388p 2，对得到的资料进行分析，进行数据处理 这个是我们获取到的数据，由于我是在 vue2 项目里面做的，所以我用了 export 将需要的数据引出，然后在对应的页面进行处理 那么问题来了：我们需要的数据是什么？什么样的数据我们才能让歌词与时间联系起来？ answer：其实就是歌词对应在 MP3 文件中对应的播放时间，所以我们需要获取对应歌曲每句歌词所对应的时间 接下来，我们在对应的文件中引入我们歌曲数据 1import lrcSong from &quot;../assets/js/song&quot;; 然后对取到的数据进行处理：将取到的歌词数据变成对象数组 对于取到的数据，我们只需要 lyric 部分，这部分是每句歌词对应的时间的字符串 由于我们取到的数据是字符串形式的，所以需要对字符串进行拆分，理由很简单，我们最后需要的数据是字符数组的形式 所以parseLrc(lrcSong)函数是对取到的数据变换成对象数组的函数，其中调用了parseTime函数，这个函数是我们用来将字符串的时间转换成秒数的格式， 1234567891011121314151617181920212223parseLrc(lrcSong) { let songdata = lrcSong.parseLrc(lrcSong) { let songdata = lrcSong.lyric; let songArr = songdata.split(&quot;\\n&quot;); let result = []; for (var i = 0; i &lt; songArr.length; i++) { // console.log(songArr[i]); let str = songArr[i]; var parts = str.split(&quot;]&quot;); let timeStr = parts[0].substring(1); let obj = { time: this.parseTime(timeStr), words: parts[1] }; result.push(obj); } this.song = result; //我们最后需要的数组对象，如果用纯js的话，那就直接return就行，最后找个变量接收 }, // 处理时间问题 parseTime(time) { let resultArr = time.split(&quot;:&quot;); return +resultArr[0] * 60 + +resultArr[1]; }, 通过这两个函数对数据的处理，我们最后得到了一个对象数组，打印出来是这样的： 3.联系 dom 元素，将歌词填充到 dom 元素里面HTML 的代码 12345678910&lt;div&gt; &lt;!-- 这种做法不能播放 --&gt; &lt;!-- &lt;audio src=&quot;../assets/1480251493.mp3&quot; controls&gt;&lt;/audio&gt; --&gt; &lt;audio controls&gt; &lt;source src=&quot;../assets/1480251493.mp3&quot; /&gt; &lt;/audio&gt; &lt;div class=&quot;container&quot;&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 注：先开始写的时间第一中 audio 的写法不能播放，第二种写法就可以，实战的时候需要注意一下 我们将处理好的数据放入到对应的 dom 元素里面 所以我们先获取 dom 元素 12345678getDom() { let tempdom = { audio: document.querySelector(&quot;audio&quot;), ul: document.querySelector(&quot;.container ul&quot;), container: document.querySelector(&quot;.container&quot;) }; this.doms = tempdom;//如果用纯js的话，那就直接return就行，最后找个变量接收 }, 这样的话，我们就获取到了我们的 dom 元素，下一步就是将歌词填充到对应的 ul 标签 12345678910111213// 创建歌词元素 createLi() { // 为了提高效率，采用文档片段，因为这种做法不涉及reflow，对浏览器渲染主线程不影响 let temp = document.createDocumentFragment(); let data = this.song; for (var i = 0; i &lt; data.length; i++) { let li = document.createElement(&quot;li&quot;); li.textContent = data[i].words; console.log(data[i].words); temp.appendChild(li); } this.doms.ul.appendChild(temp); }, 通过这种方法我们就将歌词填充到了 ul 标签中这样我们就可以看到 ul 里面 li 了 样式代码： 1234567891011121314151617181920212223242526* { margin: 0; padding: 0;}body { background-color: #000000; color: #666; text-align: center;}audio { width: 420px; margin: 30px 0;}.container { overflow: hidden; height: 420px;}.container ul { transition: 0.8s; list-style: none;}.container li { height: 30px; line-height: 30px; transition: 0.2s;} 现在我们将歌词放入到 ul 标签了，最后一步也就是最重要的，我们如何与 mp3 文件进行联系，形成滚动效果呢？ 4.将歌词与时间联系起来首先我们需要完成一个工作，就是需要知道什么时间到了哪句歌词 1234567891011// 看歌词到了那个位置 findindex() { let data = this.song; let currentTime = this.doms.audio.currentTime; for (var i = 0; i &lt; data.length; i++) { if (currentTime &lt; data[i].time) { return i - 1; } } return data.length - 1; }, 让 audio 当前播放时间与处理好的数据进行对比，获取对应的 index，这样我们就知道当前唱到了第几局句歌词 我们获取到了第几句歌词之后，我们就对歌词进行样式渲染了，就实现我们想要的滚动效果了 在实现这个之间，我们需要思考一个问题，滚动的效果是怎么实现的呢？ 看这张图，我们可以知道，其实就是 ul 标签的滚动，container 位置不进行变化，让 ul 标签向上移动，使得两个元素产生相对移动，形成这种滚动的效果，所以我们对于偏移值的把握是十分重要的 1234567891011121314151617181920212223setOffsetAndliStyle() { let containerHeight = this.doms.container.clientHeight; let liheight = this.doms.ul.children[0].clientHeight; let index = this.findindex(); let maxOffset = this.doms.ul.clientHeight - containerHeight; let offset = liheight * index + liheight / 2 - containerHeight / 2; if (offset &lt; 0) { offset = 0; } if (offset &gt; maxOffset) { offset = maxOffset; } let li = this.doms.ul.querySelector(&quot;.active&quot;); if (li) { li.classList.remove(&quot;active&quot;); } li = this.doms.ul.children[index]; if (li) { li.classList.add(&quot;active&quot;); } console.log(offset); this.doms.ul.style.transform = `translateY(-${offset}px)`; }, 当我们实现 ul 移动的时候，移动的多少是一个问题，还要考虑对应的临界值 偏移值的计算： 蓝线就是代表当前高亮显示的标签到 ul 元素顶部的距离 1liheight * index + liheight / 2 棕线就是代表container 元素的一半 这样我们就可以计算出偏移值了 1let offset = liheight * index + liheight / 2 - containerHeight / 2; 但现在还没有结束，我们还需要对偏移值判断 123456if (offset &lt; 0) { offset = 0;}if (offset &gt; maxOffset) { offset = maxOffset;} 这里面的 maxOffset 是最大的偏移值，代表到了最后一句歌词的位置不能上移了，凭个人喜好，加不加都可 那么我们就差最后一步对li 标签的渲染了 12345678let li = this.doms.ul.querySelector(&quot;.active&quot;);if (li) { li.classList.remove(&quot;active&quot;);}li = this.doms.ul.children[index];if (li) { li.classList.add(&quot;active&quot;);} active 样式 1234.container li.active { color: #fff; transform: scale(1.4);} 这样我们就做好歌词的滚动效果了！下面是我的源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152&lt;template&gt; &lt;div&gt; &lt;!-- &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; --&gt; &lt;!-- 这种做法不能播放 --&gt; &lt;!-- &lt;audio src=&quot;../assets/1480251493.mp3&quot; controls&gt;&lt;/audio&gt; --&gt; &lt;audio controls&gt; &lt;source src=&quot;../assets/1480251493.mp3&quot; /&gt; &lt;/audio&gt; &lt;div class=&quot;container&quot;&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import lrcSong from &quot;../assets/js/song&quot;;export default { name: &quot;HelloWorld&quot;, data() { return { song: [], doms: {}, currentIndex: -1, }; }, mounted() { this.parseLrc(lrcSong); this.getDom(); this.createLi(); this.audioStart(); }, methods: { parseLrc(lrcSong) { let songdata = lrcSong.lyric; let songArr = songdata.split(&quot;\\n&quot;); let result = []; for (var i = 0; i &lt; songArr.length; i++) { // console.log(songArr[i]); let str = songArr[i]; var parts = str.split(&quot;]&quot;); let timeStr = parts[0].substring(1); let obj = { time: this.parseTime(timeStr), words: parts[1], }; result.push(obj); } this.song = result; console.log(this.song); }, // 处理时间问题 parseTime(time) { let resultArr = time.split(&quot;:&quot;); return +resultArr[0] * 60 + +resultArr[1]; }, // 获取dom getDom() { let tempdom = { audio: document.querySelector(&quot;audio&quot;), ul: document.querySelector(&quot;.container ul&quot;), container: document.querySelector(&quot;.container&quot;), }; this.doms = tempdom; }, // 创建歌词元素 createLi() { // 为了提高效率，采用文档片段，因为这种做法不涉及reflow，对浏览器渲染主线程不影响 let temp = document.createDocumentFragment(); let data = this.song; for (var i = 0; i &lt; data.length; i++) { let li = document.createElement(&quot;li&quot;); li.textContent = data[i].words; console.log(data[i].words); temp.appendChild(li); } this.doms.ul.appendChild(temp); }, // 看歌词到了那个位置 findindex() { let data = this.song; let currentTime = this.doms.audio.currentTime; for (var i = 0; i &lt; data.length; i++) { if (currentTime &lt; data[i].time) { return i - 1; } } return data.length - 1; }, setOffsetAndliStyle() { let containerHeight = this.doms.container.clientHeight; let liheight = this.doms.ul.children[0].clientHeight; let index = this.findindex(); let maxOffset = this.doms.ul.clientHeight - containerHeight; let offset = liheight * index + liheight / 2 - containerHeight / 2; if (offset &lt; 0) { offset = 0; } if (offset &gt; maxOffset) { offset = maxOffset; } let li = this.doms.ul.querySelector(&quot;.active&quot;); if (li) { li.classList.remove(&quot;active&quot;); } li = this.doms.ul.children[index]; if (li) { li.classList.add(&quot;active&quot;); } console.log(offset); this.doms.ul.style.transform = `translateY(-${offset}px)`; }, audioStart() { this.doms.audio.addEventListener(&quot;timeupdate&quot;, this.setOffsetAndliStyle); }, },};&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style&gt;* { margin: 0; padding: 0;}body { background-color: #000000; color: #666; text-align: center;}audio { width: 420px; margin: 30px 0;}.container { overflow: hidden; height: 420px; /* border: 2px solid #fff; */}.container ul { transition: 0.8s; list-style: none;}.container li { height: 30px; line-height: 30px; transition: 0.2s;}.container li.active { color: #fff; transform: scale(1.4);}&lt;/style&gt; 这个 demo 是结合 vue2 做的，如果用纯 js 做的同学简单改一下变量就可以，里面的方法思路都是适用的~","link":"/2024/02/21/1-gd/"},{"title":"算法知识1-时空复杂度","text":"时间复杂度时间复杂度就是用来方便开发者估算出程序的运行时间，（这里我们默认 CPU 的每个单元运行消耗的时间都是相同的），假设算法的问题规模为 n，那么操作单元数量便用函数 f(n)来表示】 12345for(i=1; i&lt;=n; ++i){ j = i; j++;} 通过「 大 O 符号表示法 」，这段代码的时间复杂度为：O(n) ，为什么呢? 在 大 O 符号表示法中，时间复杂度的公式是： T(n) = O( f(n) )，其中 f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：算法的渐进时间复杂度。，简称时间复杂度，记为 O(f(n)) 常见的时间复杂度量级有： 常数阶 O(1) 对数阶 O(logN) 线性阶 O(n) 线性对数阶 O(nlogN) 平方阶 O(n²) 立方阶 O(n³) K 次方阶 O(n^k) 指数阶(2^n) 上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。 常数阶 O(1) 无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是 O(1)，如： 12345int i = 1;int j = 2;++i;j++;int m = i + j; 线性阶 O(n) 这个在最开始的代码示例中就讲解过了，如： 12345for(i=1; i&lt;=n; ++i){ j = i; j++;} 这段代码，for 循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的，因此这类代码都可以用 O(n)来表示它的时间复杂度。 对数阶 O(logN) 还是先来看代码： 12345int i = 1;while(i&lt;n){ i = i * 2;} 从上面代码可以看到，在 while 循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环 x 次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(logn) 线性对数阶 O(nlogN) 线性对数阶 O(nlogN) 其实非常容易理解，将时间复杂度为 O(logn)的代码循环 N 遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了 O(nlogN)。 就拿上面的代码加一点修改来举例： 12345678for(m=1; m&lt;n; m++){ i = 1; while(i&lt;n) { i = i * 2; }} 平方阶 O(n²) 平方阶 O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。举例： 12345678for(x=1; i&lt;=n; x++){ for(i=1; i&lt;=n; i++) { j = i; j++; }} 这段代码其实就是嵌套了 2 层 n 循环，它的时间复杂度就是 O(n*n)，即 O(n²)如果将其中一层循环的 n 改成 m，即： 12345678for(x=1; i&lt;=m; x++){ for(i=1; i&lt;=n; i++) { j = i; j++; }} 那它的时间复杂度就变成了 O(m*n) 立方阶 O(n³)、K 次方阶 O(n^k) 参考上面的 O(n²) 去理解就好了，O(n³)相当于三层 n 循环，其它的类似。 指数阶(2^n) 斐波那契数列 递归算法 1234567long aFunc(int n) { if (n &lt;= 1) { return n; } else { return aFunc(n - 1) + aFunc(n - 2); }} 求解 F5 依赖 F4 和 F3 ，我们把 F5 作为树的根节点， F4 和 F3 作为左右两个叶子节点，继续向下递归，左节点 F4 继续向下分解为 F3 和 F2 ，右节点 F3 继续向下分解为 F2 和 F1 ，依此类推，如下图所示： 因此，该算法的时间复杂度为 $$O(2^n)$$ 递归性能优化 12345678910111213定义容器存放计算结果函数F（int n){ if (n &lt;= 1){ return 1; } if (n 在容器中有结果){ return 容器中对应n的值 } else {//没查到 结果 = F(n - 1) + F(n - 2); 容器[n] = 结果; return 结果; }} 优化后的程序相当于给之前的递归树做了剪枝操作，相同的节点仅执行一次，因此时间复杂度降为 $$O(n)$$ 循环解法 如果说前面的递归解法是自顶向下将大问题拆解成小问题求解，那么循环解法则是逆向思维，自底向上，先求出小问题的解，再向上一步一步向上求取最终问题的解。 求解过程分为 n 步，将每一步的结果保存在列表中对应下标的位置，代码如下。 12345678int n; cin &gt;&gt; n; int fibs[n] = {0}; fibs[0] = fibs[1] = 1; for (int i = 2; i &lt;= n; i ++){ fibs[i] = fibs[i - 1] + fibs[i - 2]; } cout &lt;&lt; fibs[n - 1]; 时间复杂度分析 单层循环，时间复杂度为 O(n) ，与优化后的递归解法复杂度相当。 性能优化 时间复杂度已经没有优化空间了，但可以使用两个临时变量替换掉长度为 n 的列表，使空间复杂度从 O(n) 降为 O(1) 。代码如下： 12345678910int n; cin &gt;&gt; n; int fibs_a = 0; int fibs_b = 1; for (int i = 2; i &lt;= n; i ++){ int temp = fibs_b; fibs_b = fibs_a + fibs_b; fibs_a = temp; } cout &lt;&lt; fibs_b; 缺点就是如果取小于 n 对应的斐波那契的数时候，又需要重新计算 空间复杂度既然时间复杂度不是用来计算程序具体耗时的，那么我也应该明白，空间复杂度也不是用来计算程序实际占用的空间的。 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。 空间复杂度比较常用的有：O(1)、O(n)、O(n²)，我们下面来看看： 空间复杂度 O(1) 如果算法执行所需要的临时空间不随着某个变量 n 的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)举例： 12345int i = 1;int j = 2;++i;j++;int m = i + j; 代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1) 空间复杂度 O(n) 我们先看一个代码： 123456int[] m = new int[n]for(i=1; i&lt;=n; ++i){ j = i; j++;} 这段代码中，第一行 new 了一个数组出来，这个数据占用的大小为 n，这段代码的 2-6 行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)","link":"/2024/02/22/2sf-1/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"效果实现","slug":"效果实现","link":"/categories/%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}],"pages":[{"title":"Vue","text":"{% vueComponent helloWorld %}","link":"/vue/index.html"}]}